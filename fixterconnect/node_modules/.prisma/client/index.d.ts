
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Contractor
 * 
 */
export type Contractor = $Result.DefaultSelection<Prisma.$ContractorPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model ContractorLanguage
 * 
 */
export type ContractorLanguage = $Result.DefaultSelection<Prisma.$ContractorLanguagePayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ContractorService
 * 
 */
export type ContractorService = $Result.DefaultSelection<Prisma.$ContractorServicePayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model JobCompletion
 * 
 */
export type JobCompletion = $Result.DefaultSelection<Prisma.$JobCompletionPayload>
/**
 * Model JobPhoto
 * 
 */
export type JobPhoto = $Result.DefaultSelection<Prisma.$JobPhotoPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model FlaggedMessage
 * 
 */
export type FlaggedMessage = $Result.DefaultSelection<Prisma.$FlaggedMessagePayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Availability
 * 
 */
export type Availability = $Result.DefaultSelection<Prisma.$AvailabilityPayload>
/**
 * Model TimeSlot
 * 
 */
export type TimeSlot = $Result.DefaultSelection<Prisma.$TimeSlotPayload>
/**
 * Model ServiceArea
 * 
 */
export type ServiceArea = $Result.DefaultSelection<Prisma.$ServiceAreaPayload>
/**
 * Model ContractorServiceArea
 * 
 */
export type ContractorServiceArea = $Result.DefaultSelection<Prisma.$ContractorServiceAreaPayload>
/**
 * Model FavoriteContractor
 * 
 */
export type FavoriteContractor = $Result.DefaultSelection<Prisma.$FavoriteContractorPayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AuthProvider: {
  EMAIL: 'EMAIL',
  GOOGLE: 'GOOGLE',
  FACEBOOK: 'FACEBOOK',
  PHONE: 'PHONE'
};

export type AuthProvider = (typeof AuthProvider)[keyof typeof AuthProvider]


export const UserType: {
  CLIENT: 'CLIENT',
  CONTRACTOR: 'CONTRACTOR',
  ADMIN: 'ADMIN'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const SubscriptionTier: {
  FREE: 'FREE',
  PREMIUM: 'PREMIUM'
};

export type SubscriptionTier = (typeof SubscriptionTier)[keyof typeof SubscriptionTier]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  PAST_DUE: 'PAST_DUE',
  CANCELED: 'CANCELED',
  TRIALING: 'TRIALING',
  INCOMPLETE: 'INCOMPLETE'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const PhotoType: {
  BEFORE: 'BEFORE',
  AFTER: 'AFTER',
  ADDITIONAL: 'ADDITIONAL'
};

export type PhotoType = (typeof PhotoType)[keyof typeof PhotoType]


export const MessageStatus: {
  READ: 'READ',
  UNREAD: 'UNREAD'
};

export type MessageStatus = (typeof MessageStatus)[keyof typeof MessageStatus]


export const SenderType: {
  CONTRACTOR: 'CONTRACTOR',
  CLIENT: 'CLIENT'
};

export type SenderType = (typeof SenderType)[keyof typeof SenderType]


export const FlaggedByType: {
  CONTRACTOR: 'CONTRACTOR',
  CLIENT: 'CLIENT'
};

export type FlaggedByType = (typeof FlaggedByType)[keyof typeof FlaggedByType]


export const FlagStatus: {
  PENDING: 'PENDING',
  REVIEWED: 'REVIEWED',
  RESOLVED: 'RESOLVED',
  DISMISSED: 'DISMISSED'
};

export type FlagStatus = (typeof FlagStatus)[keyof typeof FlagStatus]


export const ReportType: {
  USER_PROFILE: 'USER_PROFILE',
  BOOKING_DISPUTE: 'BOOKING_DISPUTE',
  PAYMENT_DISPUTE: 'PAYMENT_DISPUTE',
  PLATFORM_ABUSE: 'PLATFORM_ABUSE'
};

export type ReportType = (typeof ReportType)[keyof typeof ReportType]


export const ReporterType: {
  CLIENT: 'CLIENT',
  CONTRACTOR: 'CONTRACTOR'
};

export type ReporterType = (typeof ReporterType)[keyof typeof ReporterType]


export const ReportStatus: {
  PENDING: 'PENDING',
  UNDER_REVIEW: 'UNDER_REVIEW',
  RESOLVED: 'RESOLVED',
  DISMISSED: 'DISMISSED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const ReportPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type ReportPriority = (typeof ReportPriority)[keyof typeof ReportPriority]


export const InvoiceStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const SlotType: {
  JOB: 'JOB',
  TRAVEL: 'TRAVEL',
  BLOCKED: 'BLOCKED'
};

export type SlotType = (typeof SlotType)[keyof typeof SlotType]


export const ActivitySeverity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type ActivitySeverity = (typeof ActivitySeverity)[keyof typeof ActivitySeverity]

}

export type AuthProvider = $Enums.AuthProvider

export const AuthProvider: typeof $Enums.AuthProvider

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type SubscriptionTier = $Enums.SubscriptionTier

export const SubscriptionTier: typeof $Enums.SubscriptionTier

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type PhotoType = $Enums.PhotoType

export const PhotoType: typeof $Enums.PhotoType

export type MessageStatus = $Enums.MessageStatus

export const MessageStatus: typeof $Enums.MessageStatus

export type SenderType = $Enums.SenderType

export const SenderType: typeof $Enums.SenderType

export type FlaggedByType = $Enums.FlaggedByType

export const FlaggedByType: typeof $Enums.FlaggedByType

export type FlagStatus = $Enums.FlagStatus

export const FlagStatus: typeof $Enums.FlagStatus

export type ReportType = $Enums.ReportType

export const ReportType: typeof $Enums.ReportType

export type ReporterType = $Enums.ReporterType

export const ReporterType: typeof $Enums.ReporterType

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type ReportPriority = $Enums.ReportPriority

export const ReportPriority: typeof $Enums.ReportPriority

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type SlotType = $Enums.SlotType

export const SlotType: typeof $Enums.SlotType

export type ActivitySeverity = $Enums.ActivitySeverity

export const ActivitySeverity: typeof $Enums.ActivitySeverity

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contractor`: Exposes CRUD operations for the **Contractor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contractors
    * const contractors = await prisma.contractor.findMany()
    * ```
    */
  get contractor(): Prisma.ContractorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contractorLanguage`: Exposes CRUD operations for the **ContractorLanguage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractorLanguages
    * const contractorLanguages = await prisma.contractorLanguage.findMany()
    * ```
    */
  get contractorLanguage(): Prisma.ContractorLanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contractorService`: Exposes CRUD operations for the **ContractorService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractorServices
    * const contractorServices = await prisma.contractorService.findMany()
    * ```
    */
  get contractorService(): Prisma.ContractorServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobCompletion`: Exposes CRUD operations for the **JobCompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobCompletions
    * const jobCompletions = await prisma.jobCompletion.findMany()
    * ```
    */
  get jobCompletion(): Prisma.JobCompletionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobPhoto`: Exposes CRUD operations for the **JobPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPhotos
    * const jobPhotos = await prisma.jobPhoto.findMany()
    * ```
    */
  get jobPhoto(): Prisma.JobPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flaggedMessage`: Exposes CRUD operations for the **FlaggedMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlaggedMessages
    * const flaggedMessages = await prisma.flaggedMessage.findMany()
    * ```
    */
  get flaggedMessage(): Prisma.FlaggedMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.availability`: Exposes CRUD operations for the **Availability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Availabilities
    * const availabilities = await prisma.availability.findMany()
    * ```
    */
  get availability(): Prisma.AvailabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeSlot`: Exposes CRUD operations for the **TimeSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeSlots
    * const timeSlots = await prisma.timeSlot.findMany()
    * ```
    */
  get timeSlot(): Prisma.TimeSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceArea`: Exposes CRUD operations for the **ServiceArea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceAreas
    * const serviceAreas = await prisma.serviceArea.findMany()
    * ```
    */
  get serviceArea(): Prisma.ServiceAreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contractorServiceArea`: Exposes CRUD operations for the **ContractorServiceArea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractorServiceAreas
    * const contractorServiceAreas = await prisma.contractorServiceArea.findMany()
    * ```
    */
  get contractorServiceArea(): Prisma.ContractorServiceAreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favoriteContractor`: Exposes CRUD operations for the **FavoriteContractor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FavoriteContractors
    * const favoriteContractors = await prisma.favoriteContractor.findMany()
    * ```
    */
  get favoriteContractor(): Prisma.FavoriteContractorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Client: 'Client',
    Contractor: 'Contractor',
    Subscription: 'Subscription',
    Language: 'Language',
    ContractorLanguage: 'ContractorLanguage',
    Service: 'Service',
    ContractorService: 'ContractorService',
    Booking: 'Booking',
    JobCompletion: 'JobCompletion',
    JobPhoto: 'JobPhoto',
    Message: 'Message',
    ChatMessage: 'ChatMessage',
    FlaggedMessage: 'FlaggedMessage',
    Report: 'Report',
    Review: 'Review',
    Invoice: 'Invoice',
    Payment: 'Payment',
    Availability: 'Availability',
    TimeSlot: 'TimeSlot',
    ServiceArea: 'ServiceArea',
    ContractorServiceArea: 'ContractorServiceArea',
    FavoriteContractor: 'FavoriteContractor',
    Material: 'Material',
    ActivityLog: 'ActivityLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "client" | "contractor" | "subscription" | "language" | "contractorLanguage" | "service" | "contractorService" | "booking" | "jobCompletion" | "jobPhoto" | "message" | "chatMessage" | "flaggedMessage" | "report" | "review" | "invoice" | "payment" | "availability" | "timeSlot" | "serviceArea" | "contractorServiceArea" | "favoriteContractor" | "material" | "activityLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Contractor: {
        payload: Prisma.$ContractorPayload<ExtArgs>
        fields: Prisma.ContractorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorPayload>
          }
          findFirst: {
            args: Prisma.ContractorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorPayload>
          }
          findMany: {
            args: Prisma.ContractorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorPayload>[]
          }
          create: {
            args: Prisma.ContractorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorPayload>
          }
          createMany: {
            args: Prisma.ContractorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorPayload>[]
          }
          delete: {
            args: Prisma.ContractorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorPayload>
          }
          update: {
            args: Prisma.ContractorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorPayload>
          }
          deleteMany: {
            args: Prisma.ContractorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorPayload>[]
          }
          upsert: {
            args: Prisma.ContractorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorPayload>
          }
          aggregate: {
            args: Prisma.ContractorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractor>
          }
          groupBy: {
            args: Prisma.ContractorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractorCountArgs<ExtArgs>
            result: $Utils.Optional<ContractorCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      ContractorLanguage: {
        payload: Prisma.$ContractorLanguagePayload<ExtArgs>
        fields: Prisma.ContractorLanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractorLanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorLanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractorLanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorLanguagePayload>
          }
          findFirst: {
            args: Prisma.ContractorLanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorLanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractorLanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorLanguagePayload>
          }
          findMany: {
            args: Prisma.ContractorLanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorLanguagePayload>[]
          }
          create: {
            args: Prisma.ContractorLanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorLanguagePayload>
          }
          createMany: {
            args: Prisma.ContractorLanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractorLanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorLanguagePayload>[]
          }
          delete: {
            args: Prisma.ContractorLanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorLanguagePayload>
          }
          update: {
            args: Prisma.ContractorLanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorLanguagePayload>
          }
          deleteMany: {
            args: Prisma.ContractorLanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractorLanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractorLanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorLanguagePayload>[]
          }
          upsert: {
            args: Prisma.ContractorLanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorLanguagePayload>
          }
          aggregate: {
            args: Prisma.ContractorLanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractorLanguage>
          }
          groupBy: {
            args: Prisma.ContractorLanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractorLanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractorLanguageCountArgs<ExtArgs>
            result: $Utils.Optional<ContractorLanguageCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ContractorService: {
        payload: Prisma.$ContractorServicePayload<ExtArgs>
        fields: Prisma.ContractorServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractorServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractorServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServicePayload>
          }
          findFirst: {
            args: Prisma.ContractorServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractorServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServicePayload>
          }
          findMany: {
            args: Prisma.ContractorServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServicePayload>[]
          }
          create: {
            args: Prisma.ContractorServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServicePayload>
          }
          createMany: {
            args: Prisma.ContractorServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractorServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServicePayload>[]
          }
          delete: {
            args: Prisma.ContractorServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServicePayload>
          }
          update: {
            args: Prisma.ContractorServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServicePayload>
          }
          deleteMany: {
            args: Prisma.ContractorServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractorServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractorServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServicePayload>[]
          }
          upsert: {
            args: Prisma.ContractorServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServicePayload>
          }
          aggregate: {
            args: Prisma.ContractorServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractorService>
          }
          groupBy: {
            args: Prisma.ContractorServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractorServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractorServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ContractorServiceCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      JobCompletion: {
        payload: Prisma.$JobCompletionPayload<ExtArgs>
        fields: Prisma.JobCompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobCompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobCompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobCompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobCompletionPayload>
          }
          findFirst: {
            args: Prisma.JobCompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobCompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobCompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobCompletionPayload>
          }
          findMany: {
            args: Prisma.JobCompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobCompletionPayload>[]
          }
          create: {
            args: Prisma.JobCompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobCompletionPayload>
          }
          createMany: {
            args: Prisma.JobCompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobCompletionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobCompletionPayload>[]
          }
          delete: {
            args: Prisma.JobCompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobCompletionPayload>
          }
          update: {
            args: Prisma.JobCompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobCompletionPayload>
          }
          deleteMany: {
            args: Prisma.JobCompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobCompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobCompletionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobCompletionPayload>[]
          }
          upsert: {
            args: Prisma.JobCompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobCompletionPayload>
          }
          aggregate: {
            args: Prisma.JobCompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobCompletion>
          }
          groupBy: {
            args: Prisma.JobCompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobCompletionGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobCompletionCountArgs<ExtArgs>
            result: $Utils.Optional<JobCompletionCountAggregateOutputType> | number
          }
        }
      }
      JobPhoto: {
        payload: Prisma.$JobPhotoPayload<ExtArgs>
        fields: Prisma.JobPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPhotoPayload>
          }
          findFirst: {
            args: Prisma.JobPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPhotoPayload>
          }
          findMany: {
            args: Prisma.JobPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPhotoPayload>[]
          }
          create: {
            args: Prisma.JobPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPhotoPayload>
          }
          createMany: {
            args: Prisma.JobPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPhotoPayload>[]
          }
          delete: {
            args: Prisma.JobPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPhotoPayload>
          }
          update: {
            args: Prisma.JobPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPhotoPayload>
          }
          deleteMany: {
            args: Prisma.JobPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPhotoPayload>[]
          }
          upsert: {
            args: Prisma.JobPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPhotoPayload>
          }
          aggregate: {
            args: Prisma.JobPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobPhoto>
          }
          groupBy: {
            args: Prisma.JobPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<JobPhotoCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      FlaggedMessage: {
        payload: Prisma.$FlaggedMessagePayload<ExtArgs>
        fields: Prisma.FlaggedMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlaggedMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlaggedMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlaggedMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlaggedMessagePayload>
          }
          findFirst: {
            args: Prisma.FlaggedMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlaggedMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlaggedMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlaggedMessagePayload>
          }
          findMany: {
            args: Prisma.FlaggedMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlaggedMessagePayload>[]
          }
          create: {
            args: Prisma.FlaggedMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlaggedMessagePayload>
          }
          createMany: {
            args: Prisma.FlaggedMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlaggedMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlaggedMessagePayload>[]
          }
          delete: {
            args: Prisma.FlaggedMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlaggedMessagePayload>
          }
          update: {
            args: Prisma.FlaggedMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlaggedMessagePayload>
          }
          deleteMany: {
            args: Prisma.FlaggedMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlaggedMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlaggedMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlaggedMessagePayload>[]
          }
          upsert: {
            args: Prisma.FlaggedMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlaggedMessagePayload>
          }
          aggregate: {
            args: Prisma.FlaggedMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlaggedMessage>
          }
          groupBy: {
            args: Prisma.FlaggedMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlaggedMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlaggedMessageCountArgs<ExtArgs>
            result: $Utils.Optional<FlaggedMessageCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Availability: {
        payload: Prisma.$AvailabilityPayload<ExtArgs>
        fields: Prisma.AvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          findFirst: {
            args: Prisma.AvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          findMany: {
            args: Prisma.AvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          create: {
            args: Prisma.AvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          createMany: {
            args: Prisma.AvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvailabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          delete: {
            args: Prisma.AvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          update: {
            args: Prisma.AvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.AvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AvailabilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          upsert: {
            args: Prisma.AvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          aggregate: {
            args: Prisma.AvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvailability>
          }
          groupBy: {
            args: Prisma.AvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityCountAggregateOutputType> | number
          }
        }
      }
      TimeSlot: {
        payload: Prisma.$TimeSlotPayload<ExtArgs>
        fields: Prisma.TimeSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          findFirst: {
            args: Prisma.TimeSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          findMany: {
            args: Prisma.TimeSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
          }
          create: {
            args: Prisma.TimeSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          createMany: {
            args: Prisma.TimeSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeSlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
          }
          delete: {
            args: Prisma.TimeSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          update: {
            args: Prisma.TimeSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          deleteMany: {
            args: Prisma.TimeSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimeSlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
          }
          upsert: {
            args: Prisma.TimeSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          aggregate: {
            args: Prisma.TimeSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeSlot>
          }
          groupBy: {
            args: Prisma.TimeSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeSlotCountArgs<ExtArgs>
            result: $Utils.Optional<TimeSlotCountAggregateOutputType> | number
          }
        }
      }
      ServiceArea: {
        payload: Prisma.$ServiceAreaPayload<ExtArgs>
        fields: Prisma.ServiceAreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceAreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceAreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAreaPayload>
          }
          findFirst: {
            args: Prisma.ServiceAreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceAreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAreaPayload>
          }
          findMany: {
            args: Prisma.ServiceAreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAreaPayload>[]
          }
          create: {
            args: Prisma.ServiceAreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAreaPayload>
          }
          createMany: {
            args: Prisma.ServiceAreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceAreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAreaPayload>[]
          }
          delete: {
            args: Prisma.ServiceAreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAreaPayload>
          }
          update: {
            args: Prisma.ServiceAreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAreaPayload>
          }
          deleteMany: {
            args: Prisma.ServiceAreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceAreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceAreaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAreaPayload>[]
          }
          upsert: {
            args: Prisma.ServiceAreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAreaPayload>
          }
          aggregate: {
            args: Prisma.ServiceAreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceArea>
          }
          groupBy: {
            args: Prisma.ServiceAreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceAreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceAreaCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceAreaCountAggregateOutputType> | number
          }
        }
      }
      ContractorServiceArea: {
        payload: Prisma.$ContractorServiceAreaPayload<ExtArgs>
        fields: Prisma.ContractorServiceAreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractorServiceAreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServiceAreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractorServiceAreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServiceAreaPayload>
          }
          findFirst: {
            args: Prisma.ContractorServiceAreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServiceAreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractorServiceAreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServiceAreaPayload>
          }
          findMany: {
            args: Prisma.ContractorServiceAreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServiceAreaPayload>[]
          }
          create: {
            args: Prisma.ContractorServiceAreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServiceAreaPayload>
          }
          createMany: {
            args: Prisma.ContractorServiceAreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractorServiceAreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServiceAreaPayload>[]
          }
          delete: {
            args: Prisma.ContractorServiceAreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServiceAreaPayload>
          }
          update: {
            args: Prisma.ContractorServiceAreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServiceAreaPayload>
          }
          deleteMany: {
            args: Prisma.ContractorServiceAreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractorServiceAreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractorServiceAreaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServiceAreaPayload>[]
          }
          upsert: {
            args: Prisma.ContractorServiceAreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorServiceAreaPayload>
          }
          aggregate: {
            args: Prisma.ContractorServiceAreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractorServiceArea>
          }
          groupBy: {
            args: Prisma.ContractorServiceAreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractorServiceAreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractorServiceAreaCountArgs<ExtArgs>
            result: $Utils.Optional<ContractorServiceAreaCountAggregateOutputType> | number
          }
        }
      }
      FavoriteContractor: {
        payload: Prisma.$FavoriteContractorPayload<ExtArgs>
        fields: Prisma.FavoriteContractorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteContractorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteContractorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteContractorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteContractorPayload>
          }
          findFirst: {
            args: Prisma.FavoriteContractorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteContractorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteContractorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteContractorPayload>
          }
          findMany: {
            args: Prisma.FavoriteContractorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteContractorPayload>[]
          }
          create: {
            args: Prisma.FavoriteContractorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteContractorPayload>
          }
          createMany: {
            args: Prisma.FavoriteContractorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteContractorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteContractorPayload>[]
          }
          delete: {
            args: Prisma.FavoriteContractorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteContractorPayload>
          }
          update: {
            args: Prisma.FavoriteContractorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteContractorPayload>
          }
          deleteMany: {
            args: Prisma.FavoriteContractorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteContractorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FavoriteContractorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteContractorPayload>[]
          }
          upsert: {
            args: Prisma.FavoriteContractorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteContractorPayload>
          }
          aggregate: {
            args: Prisma.FavoriteContractorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavoriteContractor>
          }
          groupBy: {
            args: Prisma.FavoriteContractorGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteContractorGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteContractorCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteContractorCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    client?: ClientOmit
    contractor?: ContractorOmit
    subscription?: SubscriptionOmit
    language?: LanguageOmit
    contractorLanguage?: ContractorLanguageOmit
    service?: ServiceOmit
    contractorService?: ContractorServiceOmit
    booking?: BookingOmit
    jobCompletion?: JobCompletionOmit
    jobPhoto?: JobPhotoOmit
    message?: MessageOmit
    chatMessage?: ChatMessageOmit
    flaggedMessage?: FlaggedMessageOmit
    report?: ReportOmit
    review?: ReviewOmit
    invoice?: InvoiceOmit
    payment?: PaymentOmit
    availability?: AvailabilityOmit
    timeSlot?: TimeSlotOmit
    serviceArea?: ServiceAreaOmit
    contractorServiceArea?: ContractorServiceAreaOmit
    favoriteContractor?: FavoriteContractorOmit
    material?: MaterialOmit
    activityLog?: ActivityLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    bookings: number
    reviews: number
    messages: number
    flaggedMessages: number
    favorites: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ClientCountOutputTypeCountBookingsArgs
    reviews?: boolean | ClientCountOutputTypeCountReviewsArgs
    messages?: boolean | ClientCountOutputTypeCountMessagesArgs
    flaggedMessages?: boolean | ClientCountOutputTypeCountFlaggedMessagesArgs
    favorites?: boolean | ClientCountOutputTypeCountFavoritesArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountFlaggedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlaggedMessageWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteContractorWhereInput
  }


  /**
   * Count Type ContractorCountOutputType
   */

  export type ContractorCountOutputType = {
    services: number
    bookings: number
    reviews: number
    messages: number
    availability: number
    timeSlots: number
    serviceAreas: number
    flaggedMessages: number
    favoritedBy: number
    materials: number
    languages: number
  }

  export type ContractorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ContractorCountOutputTypeCountServicesArgs
    bookings?: boolean | ContractorCountOutputTypeCountBookingsArgs
    reviews?: boolean | ContractorCountOutputTypeCountReviewsArgs
    messages?: boolean | ContractorCountOutputTypeCountMessagesArgs
    availability?: boolean | ContractorCountOutputTypeCountAvailabilityArgs
    timeSlots?: boolean | ContractorCountOutputTypeCountTimeSlotsArgs
    serviceAreas?: boolean | ContractorCountOutputTypeCountServiceAreasArgs
    flaggedMessages?: boolean | ContractorCountOutputTypeCountFlaggedMessagesArgs
    favoritedBy?: boolean | ContractorCountOutputTypeCountFavoritedByArgs
    materials?: boolean | ContractorCountOutputTypeCountMaterialsArgs
    languages?: boolean | ContractorCountOutputTypeCountLanguagesArgs
  }

  // Custom InputTypes
  /**
   * ContractorCountOutputType without action
   */
  export type ContractorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCountOutputType
     */
    select?: ContractorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractorCountOutputType without action
   */
  export type ContractorCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractorServiceWhereInput
  }

  /**
   * ContractorCountOutputType without action
   */
  export type ContractorCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * ContractorCountOutputType without action
   */
  export type ContractorCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * ContractorCountOutputType without action
   */
  export type ContractorCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ContractorCountOutputType without action
   */
  export type ContractorCountOutputTypeCountAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
  }

  /**
   * ContractorCountOutputType without action
   */
  export type ContractorCountOutputTypeCountTimeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSlotWhereInput
  }

  /**
   * ContractorCountOutputType without action
   */
  export type ContractorCountOutputTypeCountServiceAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractorServiceAreaWhereInput
  }

  /**
   * ContractorCountOutputType without action
   */
  export type ContractorCountOutputTypeCountFlaggedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlaggedMessageWhereInput
  }

  /**
   * ContractorCountOutputType without action
   */
  export type ContractorCountOutputTypeCountFavoritedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteContractorWhereInput
  }

  /**
   * ContractorCountOutputType without action
   */
  export type ContractorCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * ContractorCountOutputType without action
   */
  export type ContractorCountOutputTypeCountLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractorLanguageWhereInput
  }


  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    contractors: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractors?: boolean | LanguageCountOutputTypeCountContractorsArgs
  }

  // Custom InputTypes
  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountContractorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractorLanguageWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    contractors: number
    bookings: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractors?: boolean | ServiceCountOutputTypeCountContractorsArgs
    bookings?: boolean | ServiceCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountContractorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractorServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    photos: number
    payments: number
    reports: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | BookingCountOutputTypeCountPhotosArgs
    payments?: boolean | BookingCountOutputTypeCountPaymentsArgs
    reports?: boolean | BookingCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPhotoWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    chatMessages: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatMessages?: boolean | MessageCountOutputTypeCountChatMessagesArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountChatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    type: $Enums.UserType | null
    authProvider: $Enums.AuthProvider | null
    googleId: string | null
    facebookId: string | null
    phoneNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    type: $Enums.UserType | null
    authProvider: $Enums.AuthProvider | null
    googleId: string | null
    facebookId: string | null
    phoneNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    type: number
    authProvider: number
    googleId: number
    facebookId: number
    phoneNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    type?: true
    authProvider?: true
    googleId?: true
    facebookId?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    type?: true
    authProvider?: true
    googleId?: true
    facebookId?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    type?: true
    authProvider?: true
    googleId?: true
    facebookId?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    type: $Enums.UserType
    authProvider: $Enums.AuthProvider
    googleId: string | null
    facebookId: string | null
    phoneNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    type?: boolean
    authProvider?: boolean
    googleId?: boolean
    facebookId?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | User$clientArgs<ExtArgs>
    contractor?: boolean | User$contractorArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    type?: boolean
    authProvider?: boolean
    googleId?: boolean
    facebookId?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    type?: boolean
    authProvider?: boolean
    googleId?: boolean
    facebookId?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    type?: boolean
    authProvider?: boolean
    googleId?: boolean
    facebookId?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "type" | "authProvider" | "googleId" | "facebookId" | "phoneNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | User$clientArgs<ExtArgs>
    contractor?: boolean | User$contractorArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      contractor: Prisma.$ContractorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      type: $Enums.UserType
      authProvider: $Enums.AuthProvider
      googleId: string | null
      facebookId: string | null
      phoneNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends User$clientArgs<ExtArgs> = {}>(args?: Subset<T, User$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contractor<T extends User$contractorArgs<ExtArgs> = {}>(args?: Subset<T, User$contractorArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly type: FieldRef<"User", 'UserType'>
    readonly authProvider: FieldRef<"User", 'AuthProvider'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly facebookId: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.client
   */
  export type User$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * User.contractor
   */
  export type User$contractorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contractor
     */
    select?: ContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contractor
     */
    omit?: ContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorInclude<ExtArgs> | null
    where?: ContractorWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ClientSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: number | null
    userId: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    notificationEmail: boolean | null
    notificationSms: boolean | null
    profilePicture: string | null
    isActive: boolean | null
    isBanned: boolean | null
    suspendedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    notificationEmail: boolean | null
    notificationSms: boolean | null
    profilePicture: string | null
    isActive: boolean | null
    isBanned: boolean | null
    suspendedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    address: number
    city: number
    state: number
    zip: number
    notificationEmail: number
    notificationSms: number
    profilePicture: number
    isActive: number
    isBanned: number
    suspendedUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ClientSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    notificationEmail?: true
    notificationSms?: true
    profilePicture?: true
    isActive?: true
    isBanned?: true
    suspendedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    notificationEmail?: true
    notificationSms?: true
    profilePicture?: true
    isActive?: true
    isBanned?: true
    suspendedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    notificationEmail?: true
    notificationSms?: true
    profilePicture?: true
    isActive?: true
    isBanned?: true
    suspendedUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: number
    userId: number
    firstName: string
    lastName: string
    email: string
    phone: string
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    notificationEmail: boolean
    notificationSms: boolean
    profilePicture: string | null
    isActive: boolean
    isBanned: boolean
    suspendedUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: boolean
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookings?: boolean | Client$bookingsArgs<ExtArgs>
    reviews?: boolean | Client$reviewsArgs<ExtArgs>
    messages?: boolean | Client$messagesArgs<ExtArgs>
    flaggedMessages?: boolean | Client$flaggedMessagesArgs<ExtArgs>
    favorites?: boolean | Client$favoritesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: boolean
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: boolean
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: boolean
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "email" | "phone" | "address" | "city" | "state" | "zip" | "notificationEmail" | "notificationSms" | "profilePicture" | "isActive" | "isBanned" | "suspendedUntil" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookings?: boolean | Client$bookingsArgs<ExtArgs>
    reviews?: boolean | Client$reviewsArgs<ExtArgs>
    messages?: boolean | Client$messagesArgs<ExtArgs>
    flaggedMessages?: boolean | Client$flaggedMessagesArgs<ExtArgs>
    favorites?: boolean | Client$favoritesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      flaggedMessages: Prisma.$FlaggedMessagePayload<ExtArgs>[]
      favorites: Prisma.$FavoriteContractorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      firstName: string
      lastName: string
      email: string
      phone: string
      address: string | null
      city: string | null
      state: string | null
      zip: string | null
      notificationEmail: boolean
      notificationSms: boolean
      profilePicture: string | null
      isActive: boolean
      isBanned: boolean
      suspendedUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends Client$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Client$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Client$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Client$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Client$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Client$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flaggedMessages<T extends Client$flaggedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Client$flaggedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlaggedMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends Client$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Client$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteContractorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'Int'>
    readonly userId: FieldRef<"Client", 'Int'>
    readonly firstName: FieldRef<"Client", 'String'>
    readonly lastName: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly address: FieldRef<"Client", 'String'>
    readonly city: FieldRef<"Client", 'String'>
    readonly state: FieldRef<"Client", 'String'>
    readonly zip: FieldRef<"Client", 'String'>
    readonly notificationEmail: FieldRef<"Client", 'Boolean'>
    readonly notificationSms: FieldRef<"Client", 'Boolean'>
    readonly profilePicture: FieldRef<"Client", 'String'>
    readonly isActive: FieldRef<"Client", 'Boolean'>
    readonly isBanned: FieldRef<"Client", 'Boolean'>
    readonly suspendedUntil: FieldRef<"Client", 'DateTime'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.bookings
   */
  export type Client$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Client.reviews
   */
  export type Client$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Client.messages
   */
  export type Client$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Client.flaggedMessages
   */
  export type Client$flaggedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlaggedMessage
     */
    select?: FlaggedMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlaggedMessage
     */
    omit?: FlaggedMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlaggedMessageInclude<ExtArgs> | null
    where?: FlaggedMessageWhereInput
    orderBy?: FlaggedMessageOrderByWithRelationInput | FlaggedMessageOrderByWithRelationInput[]
    cursor?: FlaggedMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlaggedMessageScalarFieldEnum | FlaggedMessageScalarFieldEnum[]
  }

  /**
   * Client.favorites
   */
  export type Client$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteContractor
     */
    select?: FavoriteContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteContractor
     */
    omit?: FavoriteContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteContractorInclude<ExtArgs> | null
    where?: FavoriteContractorWhereInput
    orderBy?: FavoriteContractorOrderByWithRelationInput | FavoriteContractorOrderByWithRelationInput[]
    cursor?: FavoriteContractorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteContractorScalarFieldEnum | FavoriteContractorScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Contractor
   */

  export type AggregateContractor = {
    _count: ContractorCountAggregateOutputType | null
    _avg: ContractorAvgAggregateOutputType | null
    _sum: ContractorSumAggregateOutputType | null
    _min: ContractorMinAggregateOutputType | null
    _max: ContractorMaxAggregateOutputType | null
  }

  export type ContractorAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    yearsInBusiness: number | null
    hourlyRate: number | null
    taxRate: number | null
    rating: number | null
    reviewCount: number | null
  }

  export type ContractorSumAggregateOutputType = {
    id: number | null
    userId: number | null
    yearsInBusiness: number | null
    hourlyRate: number | null
    taxRate: number | null
    rating: number | null
    reviewCount: number | null
  }

  export type ContractorMinAggregateOutputType = {
    id: number | null
    userId: number | null
    firstName: string | null
    lastName: string | null
    name: string | null
    email: string | null
    phone: string | null
    description: string | null
    yearsInBusiness: number | null
    location: string | null
    googleBusinessUrl: string | null
    verified: boolean | null
    licensed: boolean | null
    insured: boolean | null
    afterHoursAvailable: boolean | null
    speaksSpanish: boolean | null
    hourlyRate: number | null
    taxRate: number | null
    rating: number | null
    reviewCount: number | null
    profilePicture: string | null
    isActive: boolean | null
    isBanned: boolean | null
    suspendedUntil: Date | null
    stripeAccountId: string | null
    stripeOnboardingComplete: boolean | null
    stripeChargesEnabled: boolean | null
    stripePayoutsEnabled: boolean | null
    bookingPageSlug: string | null
    bookingPageEnabled: boolean | null
    bookingPagePrimaryColor: string | null
    bookingPageAccentColor: string | null
    bookingPageTagline: string | null
    bookingPageLogo: string | null
    bookingPageShowReviews: boolean | null
    bookingPageShowPrices: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractorMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    firstName: string | null
    lastName: string | null
    name: string | null
    email: string | null
    phone: string | null
    description: string | null
    yearsInBusiness: number | null
    location: string | null
    googleBusinessUrl: string | null
    verified: boolean | null
    licensed: boolean | null
    insured: boolean | null
    afterHoursAvailable: boolean | null
    speaksSpanish: boolean | null
    hourlyRate: number | null
    taxRate: number | null
    rating: number | null
    reviewCount: number | null
    profilePicture: string | null
    isActive: boolean | null
    isBanned: boolean | null
    suspendedUntil: Date | null
    stripeAccountId: string | null
    stripeOnboardingComplete: boolean | null
    stripeChargesEnabled: boolean | null
    stripePayoutsEnabled: boolean | null
    bookingPageSlug: string | null
    bookingPageEnabled: boolean | null
    bookingPagePrimaryColor: string | null
    bookingPageAccentColor: string | null
    bookingPageTagline: string | null
    bookingPageLogo: string | null
    bookingPageShowReviews: boolean | null
    bookingPageShowPrices: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractorCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    name: number
    email: number
    phone: number
    description: number
    yearsInBusiness: number
    location: number
    googleBusinessUrl: number
    verified: number
    licensed: number
    insured: number
    afterHoursAvailable: number
    speaksSpanish: number
    hourlyRate: number
    taxRate: number
    rating: number
    reviewCount: number
    profilePicture: number
    isActive: number
    isBanned: number
    suspendedUntil: number
    stripeAccountId: number
    stripeOnboardingComplete: number
    stripeChargesEnabled: number
    stripePayoutsEnabled: number
    bookingPageSlug: number
    bookingPageEnabled: number
    bookingPagePrimaryColor: number
    bookingPageAccentColor: number
    bookingPageTagline: number
    bookingPageLogo: number
    bookingPageShowReviews: number
    bookingPageShowPrices: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContractorAvgAggregateInputType = {
    id?: true
    userId?: true
    yearsInBusiness?: true
    hourlyRate?: true
    taxRate?: true
    rating?: true
    reviewCount?: true
  }

  export type ContractorSumAggregateInputType = {
    id?: true
    userId?: true
    yearsInBusiness?: true
    hourlyRate?: true
    taxRate?: true
    rating?: true
    reviewCount?: true
  }

  export type ContractorMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    name?: true
    email?: true
    phone?: true
    description?: true
    yearsInBusiness?: true
    location?: true
    googleBusinessUrl?: true
    verified?: true
    licensed?: true
    insured?: true
    afterHoursAvailable?: true
    speaksSpanish?: true
    hourlyRate?: true
    taxRate?: true
    rating?: true
    reviewCount?: true
    profilePicture?: true
    isActive?: true
    isBanned?: true
    suspendedUntil?: true
    stripeAccountId?: true
    stripeOnboardingComplete?: true
    stripeChargesEnabled?: true
    stripePayoutsEnabled?: true
    bookingPageSlug?: true
    bookingPageEnabled?: true
    bookingPagePrimaryColor?: true
    bookingPageAccentColor?: true
    bookingPageTagline?: true
    bookingPageLogo?: true
    bookingPageShowReviews?: true
    bookingPageShowPrices?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractorMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    name?: true
    email?: true
    phone?: true
    description?: true
    yearsInBusiness?: true
    location?: true
    googleBusinessUrl?: true
    verified?: true
    licensed?: true
    insured?: true
    afterHoursAvailable?: true
    speaksSpanish?: true
    hourlyRate?: true
    taxRate?: true
    rating?: true
    reviewCount?: true
    profilePicture?: true
    isActive?: true
    isBanned?: true
    suspendedUntil?: true
    stripeAccountId?: true
    stripeOnboardingComplete?: true
    stripeChargesEnabled?: true
    stripePayoutsEnabled?: true
    bookingPageSlug?: true
    bookingPageEnabled?: true
    bookingPagePrimaryColor?: true
    bookingPageAccentColor?: true
    bookingPageTagline?: true
    bookingPageLogo?: true
    bookingPageShowReviews?: true
    bookingPageShowPrices?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractorCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    name?: true
    email?: true
    phone?: true
    description?: true
    yearsInBusiness?: true
    location?: true
    googleBusinessUrl?: true
    verified?: true
    licensed?: true
    insured?: true
    afterHoursAvailable?: true
    speaksSpanish?: true
    hourlyRate?: true
    taxRate?: true
    rating?: true
    reviewCount?: true
    profilePicture?: true
    isActive?: true
    isBanned?: true
    suspendedUntil?: true
    stripeAccountId?: true
    stripeOnboardingComplete?: true
    stripeChargesEnabled?: true
    stripePayoutsEnabled?: true
    bookingPageSlug?: true
    bookingPageEnabled?: true
    bookingPagePrimaryColor?: true
    bookingPageAccentColor?: true
    bookingPageTagline?: true
    bookingPageLogo?: true
    bookingPageShowReviews?: true
    bookingPageShowPrices?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContractorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contractor to aggregate.
     */
    where?: ContractorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contractors to fetch.
     */
    orderBy?: ContractorOrderByWithRelationInput | ContractorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contractors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contractors
    **/
    _count?: true | ContractorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractorMaxAggregateInputType
  }

  export type GetContractorAggregateType<T extends ContractorAggregateArgs> = {
        [P in keyof T & keyof AggregateContractor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractor[P]>
      : GetScalarType<T[P], AggregateContractor[P]>
  }




  export type ContractorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractorWhereInput
    orderBy?: ContractorOrderByWithAggregationInput | ContractorOrderByWithAggregationInput[]
    by: ContractorScalarFieldEnum[] | ContractorScalarFieldEnum
    having?: ContractorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractorCountAggregateInputType | true
    _avg?: ContractorAvgAggregateInputType
    _sum?: ContractorSumAggregateInputType
    _min?: ContractorMinAggregateInputType
    _max?: ContractorMaxAggregateInputType
  }

  export type ContractorGroupByOutputType = {
    id: number
    userId: number
    firstName: string | null
    lastName: string | null
    name: string
    email: string | null
    phone: string | null
    description: string | null
    yearsInBusiness: number | null
    location: string | null
    googleBusinessUrl: string | null
    verified: boolean
    licensed: boolean
    insured: boolean
    afterHoursAvailable: boolean
    speaksSpanish: boolean
    hourlyRate: number | null
    taxRate: number | null
    rating: number
    reviewCount: number
    profilePicture: string | null
    isActive: boolean
    isBanned: boolean
    suspendedUntil: Date | null
    stripeAccountId: string | null
    stripeOnboardingComplete: boolean
    stripeChargesEnabled: boolean
    stripePayoutsEnabled: boolean
    bookingPageSlug: string | null
    bookingPageEnabled: boolean
    bookingPagePrimaryColor: string | null
    bookingPageAccentColor: string | null
    bookingPageTagline: string | null
    bookingPageLogo: string | null
    bookingPageShowReviews: boolean
    bookingPageShowPrices: boolean
    createdAt: Date
    updatedAt: Date
    _count: ContractorCountAggregateOutputType | null
    _avg: ContractorAvgAggregateOutputType | null
    _sum: ContractorSumAggregateOutputType | null
    _min: ContractorMinAggregateOutputType | null
    _max: ContractorMaxAggregateOutputType | null
  }

  type GetContractorGroupByPayload<T extends ContractorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractorGroupByOutputType[P]>
            : GetScalarType<T[P], ContractorGroupByOutputType[P]>
        }
      >
    >


  export type ContractorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    description?: boolean
    yearsInBusiness?: boolean
    location?: boolean
    googleBusinessUrl?: boolean
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: boolean
    taxRate?: boolean
    rating?: boolean
    reviewCount?: boolean
    profilePicture?: boolean
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: boolean
    stripeAccountId?: boolean
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: boolean
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: boolean
    bookingPageAccentColor?: boolean
    bookingPageTagline?: boolean
    bookingPageLogo?: boolean
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    services?: boolean | Contractor$servicesArgs<ExtArgs>
    bookings?: boolean | Contractor$bookingsArgs<ExtArgs>
    reviews?: boolean | Contractor$reviewsArgs<ExtArgs>
    messages?: boolean | Contractor$messagesArgs<ExtArgs>
    availability?: boolean | Contractor$availabilityArgs<ExtArgs>
    timeSlots?: boolean | Contractor$timeSlotsArgs<ExtArgs>
    serviceAreas?: boolean | Contractor$serviceAreasArgs<ExtArgs>
    flaggedMessages?: boolean | Contractor$flaggedMessagesArgs<ExtArgs>
    favoritedBy?: boolean | Contractor$favoritedByArgs<ExtArgs>
    materials?: boolean | Contractor$materialsArgs<ExtArgs>
    languages?: boolean | Contractor$languagesArgs<ExtArgs>
    subscription?: boolean | Contractor$subscriptionArgs<ExtArgs>
    _count?: boolean | ContractorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractor"]>

  export type ContractorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    description?: boolean
    yearsInBusiness?: boolean
    location?: boolean
    googleBusinessUrl?: boolean
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: boolean
    taxRate?: boolean
    rating?: boolean
    reviewCount?: boolean
    profilePicture?: boolean
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: boolean
    stripeAccountId?: boolean
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: boolean
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: boolean
    bookingPageAccentColor?: boolean
    bookingPageTagline?: boolean
    bookingPageLogo?: boolean
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractor"]>

  export type ContractorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    description?: boolean
    yearsInBusiness?: boolean
    location?: boolean
    googleBusinessUrl?: boolean
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: boolean
    taxRate?: boolean
    rating?: boolean
    reviewCount?: boolean
    profilePicture?: boolean
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: boolean
    stripeAccountId?: boolean
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: boolean
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: boolean
    bookingPageAccentColor?: boolean
    bookingPageTagline?: boolean
    bookingPageLogo?: boolean
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractor"]>

  export type ContractorSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    description?: boolean
    yearsInBusiness?: boolean
    location?: boolean
    googleBusinessUrl?: boolean
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: boolean
    taxRate?: boolean
    rating?: boolean
    reviewCount?: boolean
    profilePicture?: boolean
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: boolean
    stripeAccountId?: boolean
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: boolean
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: boolean
    bookingPageAccentColor?: boolean
    bookingPageTagline?: boolean
    bookingPageLogo?: boolean
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContractorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "name" | "email" | "phone" | "description" | "yearsInBusiness" | "location" | "googleBusinessUrl" | "verified" | "licensed" | "insured" | "afterHoursAvailable" | "speaksSpanish" | "hourlyRate" | "taxRate" | "rating" | "reviewCount" | "profilePicture" | "isActive" | "isBanned" | "suspendedUntil" | "stripeAccountId" | "stripeOnboardingComplete" | "stripeChargesEnabled" | "stripePayoutsEnabled" | "bookingPageSlug" | "bookingPageEnabled" | "bookingPagePrimaryColor" | "bookingPageAccentColor" | "bookingPageTagline" | "bookingPageLogo" | "bookingPageShowReviews" | "bookingPageShowPrices" | "createdAt" | "updatedAt", ExtArgs["result"]["contractor"]>
  export type ContractorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    services?: boolean | Contractor$servicesArgs<ExtArgs>
    bookings?: boolean | Contractor$bookingsArgs<ExtArgs>
    reviews?: boolean | Contractor$reviewsArgs<ExtArgs>
    messages?: boolean | Contractor$messagesArgs<ExtArgs>
    availability?: boolean | Contractor$availabilityArgs<ExtArgs>
    timeSlots?: boolean | Contractor$timeSlotsArgs<ExtArgs>
    serviceAreas?: boolean | Contractor$serviceAreasArgs<ExtArgs>
    flaggedMessages?: boolean | Contractor$flaggedMessagesArgs<ExtArgs>
    favoritedBy?: boolean | Contractor$favoritedByArgs<ExtArgs>
    materials?: boolean | Contractor$materialsArgs<ExtArgs>
    languages?: boolean | Contractor$languagesArgs<ExtArgs>
    subscription?: boolean | Contractor$subscriptionArgs<ExtArgs>
    _count?: boolean | ContractorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContractorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContractorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContractorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contractor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      services: Prisma.$ContractorServicePayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      availability: Prisma.$AvailabilityPayload<ExtArgs>[]
      timeSlots: Prisma.$TimeSlotPayload<ExtArgs>[]
      serviceAreas: Prisma.$ContractorServiceAreaPayload<ExtArgs>[]
      flaggedMessages: Prisma.$FlaggedMessagePayload<ExtArgs>[]
      favoritedBy: Prisma.$FavoriteContractorPayload<ExtArgs>[]
      materials: Prisma.$MaterialPayload<ExtArgs>[]
      languages: Prisma.$ContractorLanguagePayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      firstName: string | null
      lastName: string | null
      name: string
      email: string | null
      phone: string | null
      description: string | null
      yearsInBusiness: number | null
      location: string | null
      googleBusinessUrl: string | null
      verified: boolean
      licensed: boolean
      insured: boolean
      afterHoursAvailable: boolean
      speaksSpanish: boolean
      hourlyRate: number | null
      taxRate: number | null
      rating: number
      reviewCount: number
      profilePicture: string | null
      isActive: boolean
      isBanned: boolean
      suspendedUntil: Date | null
      stripeAccountId: string | null
      stripeOnboardingComplete: boolean
      stripeChargesEnabled: boolean
      stripePayoutsEnabled: boolean
      bookingPageSlug: string | null
      bookingPageEnabled: boolean
      bookingPagePrimaryColor: string | null
      bookingPageAccentColor: string | null
      bookingPageTagline: string | null
      bookingPageLogo: string | null
      bookingPageShowReviews: boolean
      bookingPageShowPrices: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contractor"]>
    composites: {}
  }

  type ContractorGetPayload<S extends boolean | null | undefined | ContractorDefaultArgs> = $Result.GetResult<Prisma.$ContractorPayload, S>

  type ContractorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractorCountAggregateInputType | true
    }

  export interface ContractorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contractor'], meta: { name: 'Contractor' } }
    /**
     * Find zero or one Contractor that matches the filter.
     * @param {ContractorFindUniqueArgs} args - Arguments to find a Contractor
     * @example
     * // Get one Contractor
     * const contractor = await prisma.contractor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractorFindUniqueArgs>(args: SelectSubset<T, ContractorFindUniqueArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contractor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractorFindUniqueOrThrowArgs} args - Arguments to find a Contractor
     * @example
     * // Get one Contractor
     * const contractor = await prisma.contractor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractorFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contractor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorFindFirstArgs} args - Arguments to find a Contractor
     * @example
     * // Get one Contractor
     * const contractor = await prisma.contractor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractorFindFirstArgs>(args?: SelectSubset<T, ContractorFindFirstArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contractor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorFindFirstOrThrowArgs} args - Arguments to find a Contractor
     * @example
     * // Get one Contractor
     * const contractor = await prisma.contractor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractorFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contractors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contractors
     * const contractors = await prisma.contractor.findMany()
     * 
     * // Get first 10 Contractors
     * const contractors = await prisma.contractor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractorWithIdOnly = await prisma.contractor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractorFindManyArgs>(args?: SelectSubset<T, ContractorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contractor.
     * @param {ContractorCreateArgs} args - Arguments to create a Contractor.
     * @example
     * // Create one Contractor
     * const Contractor = await prisma.contractor.create({
     *   data: {
     *     // ... data to create a Contractor
     *   }
     * })
     * 
     */
    create<T extends ContractorCreateArgs>(args: SelectSubset<T, ContractorCreateArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contractors.
     * @param {ContractorCreateManyArgs} args - Arguments to create many Contractors.
     * @example
     * // Create many Contractors
     * const contractor = await prisma.contractor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractorCreateManyArgs>(args?: SelectSubset<T, ContractorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contractors and returns the data saved in the database.
     * @param {ContractorCreateManyAndReturnArgs} args - Arguments to create many Contractors.
     * @example
     * // Create many Contractors
     * const contractor = await prisma.contractor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contractors and only return the `id`
     * const contractorWithIdOnly = await prisma.contractor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractorCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contractor.
     * @param {ContractorDeleteArgs} args - Arguments to delete one Contractor.
     * @example
     * // Delete one Contractor
     * const Contractor = await prisma.contractor.delete({
     *   where: {
     *     // ... filter to delete one Contractor
     *   }
     * })
     * 
     */
    delete<T extends ContractorDeleteArgs>(args: SelectSubset<T, ContractorDeleteArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contractor.
     * @param {ContractorUpdateArgs} args - Arguments to update one Contractor.
     * @example
     * // Update one Contractor
     * const contractor = await prisma.contractor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractorUpdateArgs>(args: SelectSubset<T, ContractorUpdateArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contractors.
     * @param {ContractorDeleteManyArgs} args - Arguments to filter Contractors to delete.
     * @example
     * // Delete a few Contractors
     * const { count } = await prisma.contractor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractorDeleteManyArgs>(args?: SelectSubset<T, ContractorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contractors
     * const contractor = await prisma.contractor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractorUpdateManyArgs>(args: SelectSubset<T, ContractorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contractors and returns the data updated in the database.
     * @param {ContractorUpdateManyAndReturnArgs} args - Arguments to update many Contractors.
     * @example
     * // Update many Contractors
     * const contractor = await prisma.contractor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contractors and only return the `id`
     * const contractorWithIdOnly = await prisma.contractor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractorUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contractor.
     * @param {ContractorUpsertArgs} args - Arguments to update or create a Contractor.
     * @example
     * // Update or create a Contractor
     * const contractor = await prisma.contractor.upsert({
     *   create: {
     *     // ... data to create a Contractor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contractor we want to update
     *   }
     * })
     */
    upsert<T extends ContractorUpsertArgs>(args: SelectSubset<T, ContractorUpsertArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorCountArgs} args - Arguments to filter Contractors to count.
     * @example
     * // Count the number of Contractors
     * const count = await prisma.contractor.count({
     *   where: {
     *     // ... the filter for the Contractors we want to count
     *   }
     * })
    **/
    count<T extends ContractorCountArgs>(
      args?: Subset<T, ContractorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contractor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractorAggregateArgs>(args: Subset<T, ContractorAggregateArgs>): Prisma.PrismaPromise<GetContractorAggregateType<T>>

    /**
     * Group by Contractor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractorGroupByArgs['orderBy'] }
        : { orderBy?: ContractorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contractor model
   */
  readonly fields: ContractorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contractor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    services<T extends Contractor$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Contractor$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends Contractor$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Contractor$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Contractor$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Contractor$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Contractor$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Contractor$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    availability<T extends Contractor$availabilityArgs<ExtArgs> = {}>(args?: Subset<T, Contractor$availabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeSlots<T extends Contractor$timeSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Contractor$timeSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceAreas<T extends Contractor$serviceAreasArgs<ExtArgs> = {}>(args?: Subset<T, Contractor$serviceAreasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorServiceAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flaggedMessages<T extends Contractor$flaggedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Contractor$flaggedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlaggedMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favoritedBy<T extends Contractor$favoritedByArgs<ExtArgs> = {}>(args?: Subset<T, Contractor$favoritedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteContractorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    materials<T extends Contractor$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Contractor$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    languages<T extends Contractor$languagesArgs<ExtArgs> = {}>(args?: Subset<T, Contractor$languagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends Contractor$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Contractor$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contractor model
   */
  interface ContractorFieldRefs {
    readonly id: FieldRef<"Contractor", 'Int'>
    readonly userId: FieldRef<"Contractor", 'Int'>
    readonly firstName: FieldRef<"Contractor", 'String'>
    readonly lastName: FieldRef<"Contractor", 'String'>
    readonly name: FieldRef<"Contractor", 'String'>
    readonly email: FieldRef<"Contractor", 'String'>
    readonly phone: FieldRef<"Contractor", 'String'>
    readonly description: FieldRef<"Contractor", 'String'>
    readonly yearsInBusiness: FieldRef<"Contractor", 'Int'>
    readonly location: FieldRef<"Contractor", 'String'>
    readonly googleBusinessUrl: FieldRef<"Contractor", 'String'>
    readonly verified: FieldRef<"Contractor", 'Boolean'>
    readonly licensed: FieldRef<"Contractor", 'Boolean'>
    readonly insured: FieldRef<"Contractor", 'Boolean'>
    readonly afterHoursAvailable: FieldRef<"Contractor", 'Boolean'>
    readonly speaksSpanish: FieldRef<"Contractor", 'Boolean'>
    readonly hourlyRate: FieldRef<"Contractor", 'Float'>
    readonly taxRate: FieldRef<"Contractor", 'Float'>
    readonly rating: FieldRef<"Contractor", 'Float'>
    readonly reviewCount: FieldRef<"Contractor", 'Int'>
    readonly profilePicture: FieldRef<"Contractor", 'String'>
    readonly isActive: FieldRef<"Contractor", 'Boolean'>
    readonly isBanned: FieldRef<"Contractor", 'Boolean'>
    readonly suspendedUntil: FieldRef<"Contractor", 'DateTime'>
    readonly stripeAccountId: FieldRef<"Contractor", 'String'>
    readonly stripeOnboardingComplete: FieldRef<"Contractor", 'Boolean'>
    readonly stripeChargesEnabled: FieldRef<"Contractor", 'Boolean'>
    readonly stripePayoutsEnabled: FieldRef<"Contractor", 'Boolean'>
    readonly bookingPageSlug: FieldRef<"Contractor", 'String'>
    readonly bookingPageEnabled: FieldRef<"Contractor", 'Boolean'>
    readonly bookingPagePrimaryColor: FieldRef<"Contractor", 'String'>
    readonly bookingPageAccentColor: FieldRef<"Contractor", 'String'>
    readonly bookingPageTagline: FieldRef<"Contractor", 'String'>
    readonly bookingPageLogo: FieldRef<"Contractor", 'String'>
    readonly bookingPageShowReviews: FieldRef<"Contractor", 'Boolean'>
    readonly bookingPageShowPrices: FieldRef<"Contractor", 'Boolean'>
    readonly createdAt: FieldRef<"Contractor", 'DateTime'>
    readonly updatedAt: FieldRef<"Contractor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contractor findUnique
   */
  export type ContractorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contractor
     */
    select?: ContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contractor
     */
    omit?: ContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorInclude<ExtArgs> | null
    /**
     * Filter, which Contractor to fetch.
     */
    where: ContractorWhereUniqueInput
  }

  /**
   * Contractor findUniqueOrThrow
   */
  export type ContractorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contractor
     */
    select?: ContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contractor
     */
    omit?: ContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorInclude<ExtArgs> | null
    /**
     * Filter, which Contractor to fetch.
     */
    where: ContractorWhereUniqueInput
  }

  /**
   * Contractor findFirst
   */
  export type ContractorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contractor
     */
    select?: ContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contractor
     */
    omit?: ContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorInclude<ExtArgs> | null
    /**
     * Filter, which Contractor to fetch.
     */
    where?: ContractorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contractors to fetch.
     */
    orderBy?: ContractorOrderByWithRelationInput | ContractorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contractors.
     */
    cursor?: ContractorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contractors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contractors.
     */
    distinct?: ContractorScalarFieldEnum | ContractorScalarFieldEnum[]
  }

  /**
   * Contractor findFirstOrThrow
   */
  export type ContractorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contractor
     */
    select?: ContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contractor
     */
    omit?: ContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorInclude<ExtArgs> | null
    /**
     * Filter, which Contractor to fetch.
     */
    where?: ContractorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contractors to fetch.
     */
    orderBy?: ContractorOrderByWithRelationInput | ContractorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contractors.
     */
    cursor?: ContractorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contractors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contractors.
     */
    distinct?: ContractorScalarFieldEnum | ContractorScalarFieldEnum[]
  }

  /**
   * Contractor findMany
   */
  export type ContractorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contractor
     */
    select?: ContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contractor
     */
    omit?: ContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorInclude<ExtArgs> | null
    /**
     * Filter, which Contractors to fetch.
     */
    where?: ContractorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contractors to fetch.
     */
    orderBy?: ContractorOrderByWithRelationInput | ContractorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contractors.
     */
    cursor?: ContractorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contractors.
     */
    skip?: number
    distinct?: ContractorScalarFieldEnum | ContractorScalarFieldEnum[]
  }

  /**
   * Contractor create
   */
  export type ContractorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contractor
     */
    select?: ContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contractor
     */
    omit?: ContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorInclude<ExtArgs> | null
    /**
     * The data needed to create a Contractor.
     */
    data: XOR<ContractorCreateInput, ContractorUncheckedCreateInput>
  }

  /**
   * Contractor createMany
   */
  export type ContractorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contractors.
     */
    data: ContractorCreateManyInput | ContractorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contractor createManyAndReturn
   */
  export type ContractorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contractor
     */
    select?: ContractorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contractor
     */
    omit?: ContractorOmit<ExtArgs> | null
    /**
     * The data used to create many Contractors.
     */
    data: ContractorCreateManyInput | ContractorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contractor update
   */
  export type ContractorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contractor
     */
    select?: ContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contractor
     */
    omit?: ContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorInclude<ExtArgs> | null
    /**
     * The data needed to update a Contractor.
     */
    data: XOR<ContractorUpdateInput, ContractorUncheckedUpdateInput>
    /**
     * Choose, which Contractor to update.
     */
    where: ContractorWhereUniqueInput
  }

  /**
   * Contractor updateMany
   */
  export type ContractorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contractors.
     */
    data: XOR<ContractorUpdateManyMutationInput, ContractorUncheckedUpdateManyInput>
    /**
     * Filter which Contractors to update
     */
    where?: ContractorWhereInput
    /**
     * Limit how many Contractors to update.
     */
    limit?: number
  }

  /**
   * Contractor updateManyAndReturn
   */
  export type ContractorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contractor
     */
    select?: ContractorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contractor
     */
    omit?: ContractorOmit<ExtArgs> | null
    /**
     * The data used to update Contractors.
     */
    data: XOR<ContractorUpdateManyMutationInput, ContractorUncheckedUpdateManyInput>
    /**
     * Filter which Contractors to update
     */
    where?: ContractorWhereInput
    /**
     * Limit how many Contractors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contractor upsert
   */
  export type ContractorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contractor
     */
    select?: ContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contractor
     */
    omit?: ContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorInclude<ExtArgs> | null
    /**
     * The filter to search for the Contractor to update in case it exists.
     */
    where: ContractorWhereUniqueInput
    /**
     * In case the Contractor found by the `where` argument doesn't exist, create a new Contractor with this data.
     */
    create: XOR<ContractorCreateInput, ContractorUncheckedCreateInput>
    /**
     * In case the Contractor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractorUpdateInput, ContractorUncheckedUpdateInput>
  }

  /**
   * Contractor delete
   */
  export type ContractorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contractor
     */
    select?: ContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contractor
     */
    omit?: ContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorInclude<ExtArgs> | null
    /**
     * Filter which Contractor to delete.
     */
    where: ContractorWhereUniqueInput
  }

  /**
   * Contractor deleteMany
   */
  export type ContractorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contractors to delete
     */
    where?: ContractorWhereInput
    /**
     * Limit how many Contractors to delete.
     */
    limit?: number
  }

  /**
   * Contractor.services
   */
  export type Contractor$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorService
     */
    select?: ContractorServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorService
     */
    omit?: ContractorServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceInclude<ExtArgs> | null
    where?: ContractorServiceWhereInput
    orderBy?: ContractorServiceOrderByWithRelationInput | ContractorServiceOrderByWithRelationInput[]
    cursor?: ContractorServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractorServiceScalarFieldEnum | ContractorServiceScalarFieldEnum[]
  }

  /**
   * Contractor.bookings
   */
  export type Contractor$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Contractor.reviews
   */
  export type Contractor$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Contractor.messages
   */
  export type Contractor$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Contractor.availability
   */
  export type Contractor$availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    cursor?: AvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Contractor.timeSlots
   */
  export type Contractor$timeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    where?: TimeSlotWhereInput
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    cursor?: TimeSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * Contractor.serviceAreas
   */
  export type Contractor$serviceAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorServiceArea
     */
    select?: ContractorServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorServiceArea
     */
    omit?: ContractorServiceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceAreaInclude<ExtArgs> | null
    where?: ContractorServiceAreaWhereInput
    orderBy?: ContractorServiceAreaOrderByWithRelationInput | ContractorServiceAreaOrderByWithRelationInput[]
    cursor?: ContractorServiceAreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractorServiceAreaScalarFieldEnum | ContractorServiceAreaScalarFieldEnum[]
  }

  /**
   * Contractor.flaggedMessages
   */
  export type Contractor$flaggedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlaggedMessage
     */
    select?: FlaggedMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlaggedMessage
     */
    omit?: FlaggedMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlaggedMessageInclude<ExtArgs> | null
    where?: FlaggedMessageWhereInput
    orderBy?: FlaggedMessageOrderByWithRelationInput | FlaggedMessageOrderByWithRelationInput[]
    cursor?: FlaggedMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlaggedMessageScalarFieldEnum | FlaggedMessageScalarFieldEnum[]
  }

  /**
   * Contractor.favoritedBy
   */
  export type Contractor$favoritedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteContractor
     */
    select?: FavoriteContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteContractor
     */
    omit?: FavoriteContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteContractorInclude<ExtArgs> | null
    where?: FavoriteContractorWhereInput
    orderBy?: FavoriteContractorOrderByWithRelationInput | FavoriteContractorOrderByWithRelationInput[]
    cursor?: FavoriteContractorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteContractorScalarFieldEnum | FavoriteContractorScalarFieldEnum[]
  }

  /**
   * Contractor.materials
   */
  export type Contractor$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Contractor.languages
   */
  export type Contractor$languagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorLanguage
     */
    select?: ContractorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorLanguage
     */
    omit?: ContractorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorLanguageInclude<ExtArgs> | null
    where?: ContractorLanguageWhereInput
    orderBy?: ContractorLanguageOrderByWithRelationInput | ContractorLanguageOrderByWithRelationInput[]
    cursor?: ContractorLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractorLanguageScalarFieldEnum | ContractorLanguageScalarFieldEnum[]
  }

  /**
   * Contractor.subscription
   */
  export type Contractor$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Contractor without action
   */
  export type ContractorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contractor
     */
    select?: ContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contractor
     */
    omit?: ContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    id: number | null
    contractorId: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    id: number | null
    contractorId: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: number | null
    contractorId: number | null
    tier: $Enums.SubscriptionTier | null
    status: $Enums.SubscriptionStatus | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: number | null
    contractorId: number | null
    tier: $Enums.SubscriptionTier | null
    status: $Enums.SubscriptionStatus | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    contractorId: number
    tier: number
    status: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    stripePriceId: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    canceledAt: number
    trialStart: number
    trialEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    id?: true
    contractorId?: true
  }

  export type SubscriptionSumAggregateInputType = {
    id?: true
    contractorId?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    contractorId?: true
    tier?: true
    status?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    contractorId?: true
    tier?: true
    status?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    contractorId?: true
    tier?: true
    status?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: number
    contractorId: number
    tier: $Enums.SubscriptionTier
    status: $Enums.SubscriptionStatus
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    tier?: boolean
    status?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    tier?: boolean
    status?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    tier?: boolean
    status?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    contractorId?: boolean
    tier?: boolean
    status?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractorId" | "tier" | "status" | "stripeCustomerId" | "stripeSubscriptionId" | "stripePriceId" | "currentPeriodStart" | "currentPeriodEnd" | "cancelAtPeriodEnd" | "canceledAt" | "trialStart" | "trialEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      contractor: Prisma.$ContractorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contractorId: number
      tier: $Enums.SubscriptionTier
      status: $Enums.SubscriptionStatus
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      stripePriceId: string | null
      currentPeriodStart: Date | null
      currentPeriodEnd: Date | null
      cancelAtPeriodEnd: boolean
      canceledAt: Date | null
      trialStart: Date | null
      trialEnd: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contractor<T extends ContractorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractorDefaultArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'Int'>
    readonly contractorId: FieldRef<"Subscription", 'Int'>
    readonly tier: FieldRef<"Subscription", 'SubscriptionTier'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly stripePriceId: FieldRef<"Subscription", 'String'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly canceledAt: FieldRef<"Subscription", 'DateTime'>
    readonly trialStart: FieldRef<"Subscription", 'DateTime'>
    readonly trialEnd: FieldRef<"Subscription", 'DateTime'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageAvgAggregateOutputType = {
    id: number | null
  }

  export type LanguageSumAggregateOutputType = {
    id: number | null
  }

  export type LanguageMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    flag: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    flag: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    name: number
    code: number
    flag: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type LanguageAvgAggregateInputType = {
    id?: true
  }

  export type LanguageSumAggregateInputType = {
    id?: true
  }

  export type LanguageMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    flag?: true
    isActive?: true
    createdAt?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    flag?: true
    isActive?: true
    createdAt?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    flag?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _avg?: LanguageAvgAggregateInputType
    _sum?: LanguageSumAggregateInputType
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    id: number
    name: string
    code: string
    flag: string
    isActive: boolean
    createdAt: Date
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    flag?: boolean
    isActive?: boolean
    createdAt?: boolean
    contractors?: boolean | Language$contractorsArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    flag?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    flag?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    flag?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type LanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "flag" | "isActive" | "createdAt", ExtArgs["result"]["language"]>
  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractors?: boolean | Language$contractorsArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      contractors: Prisma.$ContractorLanguagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      flag: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages and returns the data updated in the database.
     * @param {LanguageUpdateManyAndReturnArgs} args - Arguments to update many Languages.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, LanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contractors<T extends Language$contractorsArgs<ExtArgs> = {}>(args?: Subset<T, Language$contractorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */
  interface LanguageFieldRefs {
    readonly id: FieldRef<"Language", 'Int'>
    readonly name: FieldRef<"Language", 'String'>
    readonly code: FieldRef<"Language", 'String'>
    readonly flag: FieldRef<"Language", 'String'>
    readonly isActive: FieldRef<"Language", 'Boolean'>
    readonly createdAt: FieldRef<"Language", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language updateManyAndReturn
   */
  export type LanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to delete.
     */
    limit?: number
  }

  /**
   * Language.contractors
   */
  export type Language$contractorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorLanguage
     */
    select?: ContractorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorLanguage
     */
    omit?: ContractorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorLanguageInclude<ExtArgs> | null
    where?: ContractorLanguageWhereInput
    orderBy?: ContractorLanguageOrderByWithRelationInput | ContractorLanguageOrderByWithRelationInput[]
    cursor?: ContractorLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractorLanguageScalarFieldEnum | ContractorLanguageScalarFieldEnum[]
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
  }


  /**
   * Model ContractorLanguage
   */

  export type AggregateContractorLanguage = {
    _count: ContractorLanguageCountAggregateOutputType | null
    _avg: ContractorLanguageAvgAggregateOutputType | null
    _sum: ContractorLanguageSumAggregateOutputType | null
    _min: ContractorLanguageMinAggregateOutputType | null
    _max: ContractorLanguageMaxAggregateOutputType | null
  }

  export type ContractorLanguageAvgAggregateOutputType = {
    id: number | null
    contractorId: number | null
    languageId: number | null
  }

  export type ContractorLanguageSumAggregateOutputType = {
    id: number | null
    contractorId: number | null
    languageId: number | null
  }

  export type ContractorLanguageMinAggregateOutputType = {
    id: number | null
    contractorId: number | null
    languageId: number | null
    createdAt: Date | null
  }

  export type ContractorLanguageMaxAggregateOutputType = {
    id: number | null
    contractorId: number | null
    languageId: number | null
    createdAt: Date | null
  }

  export type ContractorLanguageCountAggregateOutputType = {
    id: number
    contractorId: number
    languageId: number
    createdAt: number
    _all: number
  }


  export type ContractorLanguageAvgAggregateInputType = {
    id?: true
    contractorId?: true
    languageId?: true
  }

  export type ContractorLanguageSumAggregateInputType = {
    id?: true
    contractorId?: true
    languageId?: true
  }

  export type ContractorLanguageMinAggregateInputType = {
    id?: true
    contractorId?: true
    languageId?: true
    createdAt?: true
  }

  export type ContractorLanguageMaxAggregateInputType = {
    id?: true
    contractorId?: true
    languageId?: true
    createdAt?: true
  }

  export type ContractorLanguageCountAggregateInputType = {
    id?: true
    contractorId?: true
    languageId?: true
    createdAt?: true
    _all?: true
  }

  export type ContractorLanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractorLanguage to aggregate.
     */
    where?: ContractorLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorLanguages to fetch.
     */
    orderBy?: ContractorLanguageOrderByWithRelationInput | ContractorLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractorLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractorLanguages
    **/
    _count?: true | ContractorLanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractorLanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractorLanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractorLanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractorLanguageMaxAggregateInputType
  }

  export type GetContractorLanguageAggregateType<T extends ContractorLanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateContractorLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractorLanguage[P]>
      : GetScalarType<T[P], AggregateContractorLanguage[P]>
  }




  export type ContractorLanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractorLanguageWhereInput
    orderBy?: ContractorLanguageOrderByWithAggregationInput | ContractorLanguageOrderByWithAggregationInput[]
    by: ContractorLanguageScalarFieldEnum[] | ContractorLanguageScalarFieldEnum
    having?: ContractorLanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractorLanguageCountAggregateInputType | true
    _avg?: ContractorLanguageAvgAggregateInputType
    _sum?: ContractorLanguageSumAggregateInputType
    _min?: ContractorLanguageMinAggregateInputType
    _max?: ContractorLanguageMaxAggregateInputType
  }

  export type ContractorLanguageGroupByOutputType = {
    id: number
    contractorId: number
    languageId: number
    createdAt: Date
    _count: ContractorLanguageCountAggregateOutputType | null
    _avg: ContractorLanguageAvgAggregateOutputType | null
    _sum: ContractorLanguageSumAggregateOutputType | null
    _min: ContractorLanguageMinAggregateOutputType | null
    _max: ContractorLanguageMaxAggregateOutputType | null
  }

  type GetContractorLanguageGroupByPayload<T extends ContractorLanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractorLanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractorLanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractorLanguageGroupByOutputType[P]>
            : GetScalarType<T[P], ContractorLanguageGroupByOutputType[P]>
        }
      >
    >


  export type ContractorLanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    languageId?: boolean
    createdAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractorLanguage"]>

  export type ContractorLanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    languageId?: boolean
    createdAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractorLanguage"]>

  export type ContractorLanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    languageId?: boolean
    createdAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractorLanguage"]>

  export type ContractorLanguageSelectScalar = {
    id?: boolean
    contractorId?: boolean
    languageId?: boolean
    createdAt?: boolean
  }

  export type ContractorLanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractorId" | "languageId" | "createdAt", ExtArgs["result"]["contractorLanguage"]>
  export type ContractorLanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }
  export type ContractorLanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }
  export type ContractorLanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }

  export type $ContractorLanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractorLanguage"
    objects: {
      contractor: Prisma.$ContractorPayload<ExtArgs>
      language: Prisma.$LanguagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contractorId: number
      languageId: number
      createdAt: Date
    }, ExtArgs["result"]["contractorLanguage"]>
    composites: {}
  }

  type ContractorLanguageGetPayload<S extends boolean | null | undefined | ContractorLanguageDefaultArgs> = $Result.GetResult<Prisma.$ContractorLanguagePayload, S>

  type ContractorLanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractorLanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractorLanguageCountAggregateInputType | true
    }

  export interface ContractorLanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractorLanguage'], meta: { name: 'ContractorLanguage' } }
    /**
     * Find zero or one ContractorLanguage that matches the filter.
     * @param {ContractorLanguageFindUniqueArgs} args - Arguments to find a ContractorLanguage
     * @example
     * // Get one ContractorLanguage
     * const contractorLanguage = await prisma.contractorLanguage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractorLanguageFindUniqueArgs>(args: SelectSubset<T, ContractorLanguageFindUniqueArgs<ExtArgs>>): Prisma__ContractorLanguageClient<$Result.GetResult<Prisma.$ContractorLanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContractorLanguage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractorLanguageFindUniqueOrThrowArgs} args - Arguments to find a ContractorLanguage
     * @example
     * // Get one ContractorLanguage
     * const contractorLanguage = await prisma.contractorLanguage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractorLanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractorLanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractorLanguageClient<$Result.GetResult<Prisma.$ContractorLanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractorLanguage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorLanguageFindFirstArgs} args - Arguments to find a ContractorLanguage
     * @example
     * // Get one ContractorLanguage
     * const contractorLanguage = await prisma.contractorLanguage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractorLanguageFindFirstArgs>(args?: SelectSubset<T, ContractorLanguageFindFirstArgs<ExtArgs>>): Prisma__ContractorLanguageClient<$Result.GetResult<Prisma.$ContractorLanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractorLanguage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorLanguageFindFirstOrThrowArgs} args - Arguments to find a ContractorLanguage
     * @example
     * // Get one ContractorLanguage
     * const contractorLanguage = await prisma.contractorLanguage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractorLanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractorLanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractorLanguageClient<$Result.GetResult<Prisma.$ContractorLanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContractorLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorLanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractorLanguages
     * const contractorLanguages = await prisma.contractorLanguage.findMany()
     * 
     * // Get first 10 ContractorLanguages
     * const contractorLanguages = await prisma.contractorLanguage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractorLanguageWithIdOnly = await prisma.contractorLanguage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractorLanguageFindManyArgs>(args?: SelectSubset<T, ContractorLanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContractorLanguage.
     * @param {ContractorLanguageCreateArgs} args - Arguments to create a ContractorLanguage.
     * @example
     * // Create one ContractorLanguage
     * const ContractorLanguage = await prisma.contractorLanguage.create({
     *   data: {
     *     // ... data to create a ContractorLanguage
     *   }
     * })
     * 
     */
    create<T extends ContractorLanguageCreateArgs>(args: SelectSubset<T, ContractorLanguageCreateArgs<ExtArgs>>): Prisma__ContractorLanguageClient<$Result.GetResult<Prisma.$ContractorLanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContractorLanguages.
     * @param {ContractorLanguageCreateManyArgs} args - Arguments to create many ContractorLanguages.
     * @example
     * // Create many ContractorLanguages
     * const contractorLanguage = await prisma.contractorLanguage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractorLanguageCreateManyArgs>(args?: SelectSubset<T, ContractorLanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContractorLanguages and returns the data saved in the database.
     * @param {ContractorLanguageCreateManyAndReturnArgs} args - Arguments to create many ContractorLanguages.
     * @example
     * // Create many ContractorLanguages
     * const contractorLanguage = await prisma.contractorLanguage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContractorLanguages and only return the `id`
     * const contractorLanguageWithIdOnly = await prisma.contractorLanguage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractorLanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractorLanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorLanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContractorLanguage.
     * @param {ContractorLanguageDeleteArgs} args - Arguments to delete one ContractorLanguage.
     * @example
     * // Delete one ContractorLanguage
     * const ContractorLanguage = await prisma.contractorLanguage.delete({
     *   where: {
     *     // ... filter to delete one ContractorLanguage
     *   }
     * })
     * 
     */
    delete<T extends ContractorLanguageDeleteArgs>(args: SelectSubset<T, ContractorLanguageDeleteArgs<ExtArgs>>): Prisma__ContractorLanguageClient<$Result.GetResult<Prisma.$ContractorLanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContractorLanguage.
     * @param {ContractorLanguageUpdateArgs} args - Arguments to update one ContractorLanguage.
     * @example
     * // Update one ContractorLanguage
     * const contractorLanguage = await prisma.contractorLanguage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractorLanguageUpdateArgs>(args: SelectSubset<T, ContractorLanguageUpdateArgs<ExtArgs>>): Prisma__ContractorLanguageClient<$Result.GetResult<Prisma.$ContractorLanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContractorLanguages.
     * @param {ContractorLanguageDeleteManyArgs} args - Arguments to filter ContractorLanguages to delete.
     * @example
     * // Delete a few ContractorLanguages
     * const { count } = await prisma.contractorLanguage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractorLanguageDeleteManyArgs>(args?: SelectSubset<T, ContractorLanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractorLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorLanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractorLanguages
     * const contractorLanguage = await prisma.contractorLanguage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractorLanguageUpdateManyArgs>(args: SelectSubset<T, ContractorLanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractorLanguages and returns the data updated in the database.
     * @param {ContractorLanguageUpdateManyAndReturnArgs} args - Arguments to update many ContractorLanguages.
     * @example
     * // Update many ContractorLanguages
     * const contractorLanguage = await prisma.contractorLanguage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContractorLanguages and only return the `id`
     * const contractorLanguageWithIdOnly = await prisma.contractorLanguage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractorLanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractorLanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorLanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContractorLanguage.
     * @param {ContractorLanguageUpsertArgs} args - Arguments to update or create a ContractorLanguage.
     * @example
     * // Update or create a ContractorLanguage
     * const contractorLanguage = await prisma.contractorLanguage.upsert({
     *   create: {
     *     // ... data to create a ContractorLanguage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractorLanguage we want to update
     *   }
     * })
     */
    upsert<T extends ContractorLanguageUpsertArgs>(args: SelectSubset<T, ContractorLanguageUpsertArgs<ExtArgs>>): Prisma__ContractorLanguageClient<$Result.GetResult<Prisma.$ContractorLanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContractorLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorLanguageCountArgs} args - Arguments to filter ContractorLanguages to count.
     * @example
     * // Count the number of ContractorLanguages
     * const count = await prisma.contractorLanguage.count({
     *   where: {
     *     // ... the filter for the ContractorLanguages we want to count
     *   }
     * })
    **/
    count<T extends ContractorLanguageCountArgs>(
      args?: Subset<T, ContractorLanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractorLanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractorLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorLanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractorLanguageAggregateArgs>(args: Subset<T, ContractorLanguageAggregateArgs>): Prisma.PrismaPromise<GetContractorLanguageAggregateType<T>>

    /**
     * Group by ContractorLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorLanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractorLanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractorLanguageGroupByArgs['orderBy'] }
        : { orderBy?: ContractorLanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractorLanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractorLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractorLanguage model
   */
  readonly fields: ContractorLanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractorLanguage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractorLanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contractor<T extends ContractorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractorDefaultArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContractorLanguage model
   */
  interface ContractorLanguageFieldRefs {
    readonly id: FieldRef<"ContractorLanguage", 'Int'>
    readonly contractorId: FieldRef<"ContractorLanguage", 'Int'>
    readonly languageId: FieldRef<"ContractorLanguage", 'Int'>
    readonly createdAt: FieldRef<"ContractorLanguage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContractorLanguage findUnique
   */
  export type ContractorLanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorLanguage
     */
    select?: ContractorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorLanguage
     */
    omit?: ContractorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ContractorLanguage to fetch.
     */
    where: ContractorLanguageWhereUniqueInput
  }

  /**
   * ContractorLanguage findUniqueOrThrow
   */
  export type ContractorLanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorLanguage
     */
    select?: ContractorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorLanguage
     */
    omit?: ContractorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ContractorLanguage to fetch.
     */
    where: ContractorLanguageWhereUniqueInput
  }

  /**
   * ContractorLanguage findFirst
   */
  export type ContractorLanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorLanguage
     */
    select?: ContractorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorLanguage
     */
    omit?: ContractorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ContractorLanguage to fetch.
     */
    where?: ContractorLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorLanguages to fetch.
     */
    orderBy?: ContractorLanguageOrderByWithRelationInput | ContractorLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractorLanguages.
     */
    cursor?: ContractorLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractorLanguages.
     */
    distinct?: ContractorLanguageScalarFieldEnum | ContractorLanguageScalarFieldEnum[]
  }

  /**
   * ContractorLanguage findFirstOrThrow
   */
  export type ContractorLanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorLanguage
     */
    select?: ContractorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorLanguage
     */
    omit?: ContractorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ContractorLanguage to fetch.
     */
    where?: ContractorLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorLanguages to fetch.
     */
    orderBy?: ContractorLanguageOrderByWithRelationInput | ContractorLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractorLanguages.
     */
    cursor?: ContractorLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractorLanguages.
     */
    distinct?: ContractorLanguageScalarFieldEnum | ContractorLanguageScalarFieldEnum[]
  }

  /**
   * ContractorLanguage findMany
   */
  export type ContractorLanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorLanguage
     */
    select?: ContractorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorLanguage
     */
    omit?: ContractorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ContractorLanguages to fetch.
     */
    where?: ContractorLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorLanguages to fetch.
     */
    orderBy?: ContractorLanguageOrderByWithRelationInput | ContractorLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractorLanguages.
     */
    cursor?: ContractorLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorLanguages.
     */
    skip?: number
    distinct?: ContractorLanguageScalarFieldEnum | ContractorLanguageScalarFieldEnum[]
  }

  /**
   * ContractorLanguage create
   */
  export type ContractorLanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorLanguage
     */
    select?: ContractorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorLanguage
     */
    omit?: ContractorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorLanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractorLanguage.
     */
    data: XOR<ContractorLanguageCreateInput, ContractorLanguageUncheckedCreateInput>
  }

  /**
   * ContractorLanguage createMany
   */
  export type ContractorLanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractorLanguages.
     */
    data: ContractorLanguageCreateManyInput | ContractorLanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractorLanguage createManyAndReturn
   */
  export type ContractorLanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorLanguage
     */
    select?: ContractorLanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorLanguage
     */
    omit?: ContractorLanguageOmit<ExtArgs> | null
    /**
     * The data used to create many ContractorLanguages.
     */
    data: ContractorLanguageCreateManyInput | ContractorLanguageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorLanguageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractorLanguage update
   */
  export type ContractorLanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorLanguage
     */
    select?: ContractorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorLanguage
     */
    omit?: ContractorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorLanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractorLanguage.
     */
    data: XOR<ContractorLanguageUpdateInput, ContractorLanguageUncheckedUpdateInput>
    /**
     * Choose, which ContractorLanguage to update.
     */
    where: ContractorLanguageWhereUniqueInput
  }

  /**
   * ContractorLanguage updateMany
   */
  export type ContractorLanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractorLanguages.
     */
    data: XOR<ContractorLanguageUpdateManyMutationInput, ContractorLanguageUncheckedUpdateManyInput>
    /**
     * Filter which ContractorLanguages to update
     */
    where?: ContractorLanguageWhereInput
    /**
     * Limit how many ContractorLanguages to update.
     */
    limit?: number
  }

  /**
   * ContractorLanguage updateManyAndReturn
   */
  export type ContractorLanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorLanguage
     */
    select?: ContractorLanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorLanguage
     */
    omit?: ContractorLanguageOmit<ExtArgs> | null
    /**
     * The data used to update ContractorLanguages.
     */
    data: XOR<ContractorLanguageUpdateManyMutationInput, ContractorLanguageUncheckedUpdateManyInput>
    /**
     * Filter which ContractorLanguages to update
     */
    where?: ContractorLanguageWhereInput
    /**
     * Limit how many ContractorLanguages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorLanguageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractorLanguage upsert
   */
  export type ContractorLanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorLanguage
     */
    select?: ContractorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorLanguage
     */
    omit?: ContractorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorLanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractorLanguage to update in case it exists.
     */
    where: ContractorLanguageWhereUniqueInput
    /**
     * In case the ContractorLanguage found by the `where` argument doesn't exist, create a new ContractorLanguage with this data.
     */
    create: XOR<ContractorLanguageCreateInput, ContractorLanguageUncheckedCreateInput>
    /**
     * In case the ContractorLanguage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractorLanguageUpdateInput, ContractorLanguageUncheckedUpdateInput>
  }

  /**
   * ContractorLanguage delete
   */
  export type ContractorLanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorLanguage
     */
    select?: ContractorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorLanguage
     */
    omit?: ContractorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorLanguageInclude<ExtArgs> | null
    /**
     * Filter which ContractorLanguage to delete.
     */
    where: ContractorLanguageWhereUniqueInput
  }

  /**
   * ContractorLanguage deleteMany
   */
  export type ContractorLanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractorLanguages to delete
     */
    where?: ContractorLanguageWhereInput
    /**
     * Limit how many ContractorLanguages to delete.
     */
    limit?: number
  }

  /**
   * ContractorLanguage without action
   */
  export type ContractorLanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorLanguage
     */
    select?: ContractorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorLanguage
     */
    omit?: ContractorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorLanguageInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    id: number | null
  }

  export type ServiceSumAggregateOutputType = {
    id: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: number | null
    name: string | null
    icon: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    icon: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    description: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    id?: true
  }

  export type ServiceSumAggregateInputType = {
    id?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    description?: true
    isActive?: true
    createdAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    description?: true
    isActive?: true
    createdAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    description?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: number
    name: string
    icon: string
    description: string | null
    isActive: boolean
    createdAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    contractors?: boolean | Service$contractorsArgs<ExtArgs>
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "icon" | "description" | "isActive" | "createdAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractors?: boolean | Service$contractorsArgs<ExtArgs>
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      contractors: Prisma.$ContractorServicePayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      icon: string
      description: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contractors<T extends Service$contractorsArgs<ExtArgs> = {}>(args?: Subset<T, Service$contractorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends Service$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Service$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'Int'>
    readonly name: FieldRef<"Service", 'String'>
    readonly icon: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.contractors
   */
  export type Service$contractorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorService
     */
    select?: ContractorServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorService
     */
    omit?: ContractorServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceInclude<ExtArgs> | null
    where?: ContractorServiceWhereInput
    orderBy?: ContractorServiceOrderByWithRelationInput | ContractorServiceOrderByWithRelationInput[]
    cursor?: ContractorServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractorServiceScalarFieldEnum | ContractorServiceScalarFieldEnum[]
  }

  /**
   * Service.bookings
   */
  export type Service$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model ContractorService
   */

  export type AggregateContractorService = {
    _count: ContractorServiceCountAggregateOutputType | null
    _avg: ContractorServiceAvgAggregateOutputType | null
    _sum: ContractorServiceSumAggregateOutputType | null
    _min: ContractorServiceMinAggregateOutputType | null
    _max: ContractorServiceMaxAggregateOutputType | null
  }

  export type ContractorServiceAvgAggregateOutputType = {
    id: number | null
    contractorId: number | null
    serviceId: number | null
    basePrice: number | null
  }

  export type ContractorServiceSumAggregateOutputType = {
    id: number | null
    contractorId: number | null
    serviceId: number | null
    basePrice: number | null
  }

  export type ContractorServiceMinAggregateOutputType = {
    id: number | null
    contractorId: number | null
    serviceId: number | null
    basePrice: number | null
    createdAt: Date | null
  }

  export type ContractorServiceMaxAggregateOutputType = {
    id: number | null
    contractorId: number | null
    serviceId: number | null
    basePrice: number | null
    createdAt: Date | null
  }

  export type ContractorServiceCountAggregateOutputType = {
    id: number
    contractorId: number
    serviceId: number
    basePrice: number
    createdAt: number
    _all: number
  }


  export type ContractorServiceAvgAggregateInputType = {
    id?: true
    contractorId?: true
    serviceId?: true
    basePrice?: true
  }

  export type ContractorServiceSumAggregateInputType = {
    id?: true
    contractorId?: true
    serviceId?: true
    basePrice?: true
  }

  export type ContractorServiceMinAggregateInputType = {
    id?: true
    contractorId?: true
    serviceId?: true
    basePrice?: true
    createdAt?: true
  }

  export type ContractorServiceMaxAggregateInputType = {
    id?: true
    contractorId?: true
    serviceId?: true
    basePrice?: true
    createdAt?: true
  }

  export type ContractorServiceCountAggregateInputType = {
    id?: true
    contractorId?: true
    serviceId?: true
    basePrice?: true
    createdAt?: true
    _all?: true
  }

  export type ContractorServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractorService to aggregate.
     */
    where?: ContractorServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorServices to fetch.
     */
    orderBy?: ContractorServiceOrderByWithRelationInput | ContractorServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractorServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractorServices
    **/
    _count?: true | ContractorServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractorServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractorServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractorServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractorServiceMaxAggregateInputType
  }

  export type GetContractorServiceAggregateType<T extends ContractorServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateContractorService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractorService[P]>
      : GetScalarType<T[P], AggregateContractorService[P]>
  }




  export type ContractorServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractorServiceWhereInput
    orderBy?: ContractorServiceOrderByWithAggregationInput | ContractorServiceOrderByWithAggregationInput[]
    by: ContractorServiceScalarFieldEnum[] | ContractorServiceScalarFieldEnum
    having?: ContractorServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractorServiceCountAggregateInputType | true
    _avg?: ContractorServiceAvgAggregateInputType
    _sum?: ContractorServiceSumAggregateInputType
    _min?: ContractorServiceMinAggregateInputType
    _max?: ContractorServiceMaxAggregateInputType
  }

  export type ContractorServiceGroupByOutputType = {
    id: number
    contractorId: number
    serviceId: number
    basePrice: number | null
    createdAt: Date
    _count: ContractorServiceCountAggregateOutputType | null
    _avg: ContractorServiceAvgAggregateOutputType | null
    _sum: ContractorServiceSumAggregateOutputType | null
    _min: ContractorServiceMinAggregateOutputType | null
    _max: ContractorServiceMaxAggregateOutputType | null
  }

  type GetContractorServiceGroupByPayload<T extends ContractorServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractorServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractorServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractorServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ContractorServiceGroupByOutputType[P]>
        }
      >
    >


  export type ContractorServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    serviceId?: boolean
    basePrice?: boolean
    createdAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractorService"]>

  export type ContractorServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    serviceId?: boolean
    basePrice?: boolean
    createdAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractorService"]>

  export type ContractorServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    serviceId?: boolean
    basePrice?: boolean
    createdAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractorService"]>

  export type ContractorServiceSelectScalar = {
    id?: boolean
    contractorId?: boolean
    serviceId?: boolean
    basePrice?: boolean
    createdAt?: boolean
  }

  export type ContractorServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractorId" | "serviceId" | "basePrice" | "createdAt", ExtArgs["result"]["contractorService"]>
  export type ContractorServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ContractorServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ContractorServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ContractorServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractorService"
    objects: {
      contractor: Prisma.$ContractorPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contractorId: number
      serviceId: number
      basePrice: number | null
      createdAt: Date
    }, ExtArgs["result"]["contractorService"]>
    composites: {}
  }

  type ContractorServiceGetPayload<S extends boolean | null | undefined | ContractorServiceDefaultArgs> = $Result.GetResult<Prisma.$ContractorServicePayload, S>

  type ContractorServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractorServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractorServiceCountAggregateInputType | true
    }

  export interface ContractorServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractorService'], meta: { name: 'ContractorService' } }
    /**
     * Find zero or one ContractorService that matches the filter.
     * @param {ContractorServiceFindUniqueArgs} args - Arguments to find a ContractorService
     * @example
     * // Get one ContractorService
     * const contractorService = await prisma.contractorService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractorServiceFindUniqueArgs>(args: SelectSubset<T, ContractorServiceFindUniqueArgs<ExtArgs>>): Prisma__ContractorServiceClient<$Result.GetResult<Prisma.$ContractorServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContractorService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractorServiceFindUniqueOrThrowArgs} args - Arguments to find a ContractorService
     * @example
     * // Get one ContractorService
     * const contractorService = await prisma.contractorService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractorServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractorServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractorServiceClient<$Result.GetResult<Prisma.$ContractorServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractorService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorServiceFindFirstArgs} args - Arguments to find a ContractorService
     * @example
     * // Get one ContractorService
     * const contractorService = await prisma.contractorService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractorServiceFindFirstArgs>(args?: SelectSubset<T, ContractorServiceFindFirstArgs<ExtArgs>>): Prisma__ContractorServiceClient<$Result.GetResult<Prisma.$ContractorServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractorService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorServiceFindFirstOrThrowArgs} args - Arguments to find a ContractorService
     * @example
     * // Get one ContractorService
     * const contractorService = await prisma.contractorService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractorServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractorServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractorServiceClient<$Result.GetResult<Prisma.$ContractorServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContractorServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractorServices
     * const contractorServices = await prisma.contractorService.findMany()
     * 
     * // Get first 10 ContractorServices
     * const contractorServices = await prisma.contractorService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractorServiceWithIdOnly = await prisma.contractorService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractorServiceFindManyArgs>(args?: SelectSubset<T, ContractorServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContractorService.
     * @param {ContractorServiceCreateArgs} args - Arguments to create a ContractorService.
     * @example
     * // Create one ContractorService
     * const ContractorService = await prisma.contractorService.create({
     *   data: {
     *     // ... data to create a ContractorService
     *   }
     * })
     * 
     */
    create<T extends ContractorServiceCreateArgs>(args: SelectSubset<T, ContractorServiceCreateArgs<ExtArgs>>): Prisma__ContractorServiceClient<$Result.GetResult<Prisma.$ContractorServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContractorServices.
     * @param {ContractorServiceCreateManyArgs} args - Arguments to create many ContractorServices.
     * @example
     * // Create many ContractorServices
     * const contractorService = await prisma.contractorService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractorServiceCreateManyArgs>(args?: SelectSubset<T, ContractorServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContractorServices and returns the data saved in the database.
     * @param {ContractorServiceCreateManyAndReturnArgs} args - Arguments to create many ContractorServices.
     * @example
     * // Create many ContractorServices
     * const contractorService = await prisma.contractorService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContractorServices and only return the `id`
     * const contractorServiceWithIdOnly = await prisma.contractorService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractorServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractorServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContractorService.
     * @param {ContractorServiceDeleteArgs} args - Arguments to delete one ContractorService.
     * @example
     * // Delete one ContractorService
     * const ContractorService = await prisma.contractorService.delete({
     *   where: {
     *     // ... filter to delete one ContractorService
     *   }
     * })
     * 
     */
    delete<T extends ContractorServiceDeleteArgs>(args: SelectSubset<T, ContractorServiceDeleteArgs<ExtArgs>>): Prisma__ContractorServiceClient<$Result.GetResult<Prisma.$ContractorServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContractorService.
     * @param {ContractorServiceUpdateArgs} args - Arguments to update one ContractorService.
     * @example
     * // Update one ContractorService
     * const contractorService = await prisma.contractorService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractorServiceUpdateArgs>(args: SelectSubset<T, ContractorServiceUpdateArgs<ExtArgs>>): Prisma__ContractorServiceClient<$Result.GetResult<Prisma.$ContractorServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContractorServices.
     * @param {ContractorServiceDeleteManyArgs} args - Arguments to filter ContractorServices to delete.
     * @example
     * // Delete a few ContractorServices
     * const { count } = await prisma.contractorService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractorServiceDeleteManyArgs>(args?: SelectSubset<T, ContractorServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractorServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractorServices
     * const contractorService = await prisma.contractorService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractorServiceUpdateManyArgs>(args: SelectSubset<T, ContractorServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractorServices and returns the data updated in the database.
     * @param {ContractorServiceUpdateManyAndReturnArgs} args - Arguments to update many ContractorServices.
     * @example
     * // Update many ContractorServices
     * const contractorService = await prisma.contractorService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContractorServices and only return the `id`
     * const contractorServiceWithIdOnly = await prisma.contractorService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractorServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractorServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContractorService.
     * @param {ContractorServiceUpsertArgs} args - Arguments to update or create a ContractorService.
     * @example
     * // Update or create a ContractorService
     * const contractorService = await prisma.contractorService.upsert({
     *   create: {
     *     // ... data to create a ContractorService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractorService we want to update
     *   }
     * })
     */
    upsert<T extends ContractorServiceUpsertArgs>(args: SelectSubset<T, ContractorServiceUpsertArgs<ExtArgs>>): Prisma__ContractorServiceClient<$Result.GetResult<Prisma.$ContractorServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContractorServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorServiceCountArgs} args - Arguments to filter ContractorServices to count.
     * @example
     * // Count the number of ContractorServices
     * const count = await prisma.contractorService.count({
     *   where: {
     *     // ... the filter for the ContractorServices we want to count
     *   }
     * })
    **/
    count<T extends ContractorServiceCountArgs>(
      args?: Subset<T, ContractorServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractorServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractorService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractorServiceAggregateArgs>(args: Subset<T, ContractorServiceAggregateArgs>): Prisma.PrismaPromise<GetContractorServiceAggregateType<T>>

    /**
     * Group by ContractorService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractorServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractorServiceGroupByArgs['orderBy'] }
        : { orderBy?: ContractorServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractorServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractorServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractorService model
   */
  readonly fields: ContractorServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractorService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractorServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contractor<T extends ContractorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractorDefaultArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContractorService model
   */
  interface ContractorServiceFieldRefs {
    readonly id: FieldRef<"ContractorService", 'Int'>
    readonly contractorId: FieldRef<"ContractorService", 'Int'>
    readonly serviceId: FieldRef<"ContractorService", 'Int'>
    readonly basePrice: FieldRef<"ContractorService", 'Float'>
    readonly createdAt: FieldRef<"ContractorService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContractorService findUnique
   */
  export type ContractorServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorService
     */
    select?: ContractorServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorService
     */
    omit?: ContractorServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceInclude<ExtArgs> | null
    /**
     * Filter, which ContractorService to fetch.
     */
    where: ContractorServiceWhereUniqueInput
  }

  /**
   * ContractorService findUniqueOrThrow
   */
  export type ContractorServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorService
     */
    select?: ContractorServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorService
     */
    omit?: ContractorServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceInclude<ExtArgs> | null
    /**
     * Filter, which ContractorService to fetch.
     */
    where: ContractorServiceWhereUniqueInput
  }

  /**
   * ContractorService findFirst
   */
  export type ContractorServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorService
     */
    select?: ContractorServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorService
     */
    omit?: ContractorServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceInclude<ExtArgs> | null
    /**
     * Filter, which ContractorService to fetch.
     */
    where?: ContractorServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorServices to fetch.
     */
    orderBy?: ContractorServiceOrderByWithRelationInput | ContractorServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractorServices.
     */
    cursor?: ContractorServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractorServices.
     */
    distinct?: ContractorServiceScalarFieldEnum | ContractorServiceScalarFieldEnum[]
  }

  /**
   * ContractorService findFirstOrThrow
   */
  export type ContractorServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorService
     */
    select?: ContractorServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorService
     */
    omit?: ContractorServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceInclude<ExtArgs> | null
    /**
     * Filter, which ContractorService to fetch.
     */
    where?: ContractorServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorServices to fetch.
     */
    orderBy?: ContractorServiceOrderByWithRelationInput | ContractorServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractorServices.
     */
    cursor?: ContractorServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractorServices.
     */
    distinct?: ContractorServiceScalarFieldEnum | ContractorServiceScalarFieldEnum[]
  }

  /**
   * ContractorService findMany
   */
  export type ContractorServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorService
     */
    select?: ContractorServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorService
     */
    omit?: ContractorServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceInclude<ExtArgs> | null
    /**
     * Filter, which ContractorServices to fetch.
     */
    where?: ContractorServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorServices to fetch.
     */
    orderBy?: ContractorServiceOrderByWithRelationInput | ContractorServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractorServices.
     */
    cursor?: ContractorServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorServices.
     */
    skip?: number
    distinct?: ContractorServiceScalarFieldEnum | ContractorServiceScalarFieldEnum[]
  }

  /**
   * ContractorService create
   */
  export type ContractorServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorService
     */
    select?: ContractorServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorService
     */
    omit?: ContractorServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractorService.
     */
    data: XOR<ContractorServiceCreateInput, ContractorServiceUncheckedCreateInput>
  }

  /**
   * ContractorService createMany
   */
  export type ContractorServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractorServices.
     */
    data: ContractorServiceCreateManyInput | ContractorServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractorService createManyAndReturn
   */
  export type ContractorServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorService
     */
    select?: ContractorServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorService
     */
    omit?: ContractorServiceOmit<ExtArgs> | null
    /**
     * The data used to create many ContractorServices.
     */
    data: ContractorServiceCreateManyInput | ContractorServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractorService update
   */
  export type ContractorServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorService
     */
    select?: ContractorServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorService
     */
    omit?: ContractorServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractorService.
     */
    data: XOR<ContractorServiceUpdateInput, ContractorServiceUncheckedUpdateInput>
    /**
     * Choose, which ContractorService to update.
     */
    where: ContractorServiceWhereUniqueInput
  }

  /**
   * ContractorService updateMany
   */
  export type ContractorServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractorServices.
     */
    data: XOR<ContractorServiceUpdateManyMutationInput, ContractorServiceUncheckedUpdateManyInput>
    /**
     * Filter which ContractorServices to update
     */
    where?: ContractorServiceWhereInput
    /**
     * Limit how many ContractorServices to update.
     */
    limit?: number
  }

  /**
   * ContractorService updateManyAndReturn
   */
  export type ContractorServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorService
     */
    select?: ContractorServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorService
     */
    omit?: ContractorServiceOmit<ExtArgs> | null
    /**
     * The data used to update ContractorServices.
     */
    data: XOR<ContractorServiceUpdateManyMutationInput, ContractorServiceUncheckedUpdateManyInput>
    /**
     * Filter which ContractorServices to update
     */
    where?: ContractorServiceWhereInput
    /**
     * Limit how many ContractorServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractorService upsert
   */
  export type ContractorServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorService
     */
    select?: ContractorServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorService
     */
    omit?: ContractorServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractorService to update in case it exists.
     */
    where: ContractorServiceWhereUniqueInput
    /**
     * In case the ContractorService found by the `where` argument doesn't exist, create a new ContractorService with this data.
     */
    create: XOR<ContractorServiceCreateInput, ContractorServiceUncheckedCreateInput>
    /**
     * In case the ContractorService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractorServiceUpdateInput, ContractorServiceUncheckedUpdateInput>
  }

  /**
   * ContractorService delete
   */
  export type ContractorServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorService
     */
    select?: ContractorServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorService
     */
    omit?: ContractorServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceInclude<ExtArgs> | null
    /**
     * Filter which ContractorService to delete.
     */
    where: ContractorServiceWhereUniqueInput
  }

  /**
   * ContractorService deleteMany
   */
  export type ContractorServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractorServices to delete
     */
    where?: ContractorServiceWhereInput
    /**
     * Limit how many ContractorServices to delete.
     */
    limit?: number
  }

  /**
   * ContractorService without action
   */
  export type ContractorServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorService
     */
    select?: ContractorServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorService
     */
    omit?: ContractorServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    contractorId: number | null
    clientId: number | null
    serviceId: number | null
    estimatedDuration: number | null
    price: number | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    contractorId: number | null
    clientId: number | null
    serviceId: number | null
    estimatedDuration: number | null
    price: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    contractorId: number | null
    clientId: number | null
    serviceId: number | null
    serviceAddress: string | null
    scheduledDate: Date | null
    scheduledTime: string | null
    estimatedDuration: number | null
    status: $Enums.BookingStatus | null
    price: number | null
    paymentReceived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    contractorId: number | null
    clientId: number | null
    serviceId: number | null
    serviceAddress: string | null
    scheduledDate: Date | null
    scheduledTime: string | null
    estimatedDuration: number | null
    status: $Enums.BookingStatus | null
    price: number | null
    paymentReceived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    contractorId: number
    clientId: number
    serviceId: number
    serviceAddress: number
    scheduledDate: number
    scheduledTime: number
    estimatedDuration: number
    status: number
    price: number
    paymentReceived: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
    serviceId?: true
    estimatedDuration?: true
    price?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
    serviceId?: true
    estimatedDuration?: true
    price?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
    serviceId?: true
    serviceAddress?: true
    scheduledDate?: true
    scheduledTime?: true
    estimatedDuration?: true
    status?: true
    price?: true
    paymentReceived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
    serviceId?: true
    serviceAddress?: true
    scheduledDate?: true
    scheduledTime?: true
    estimatedDuration?: true
    status?: true
    price?: true
    paymentReceived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
    serviceId?: true
    serviceAddress?: true
    scheduledDate?: true
    scheduledTime?: true
    estimatedDuration?: true
    status?: true
    price?: true
    paymentReceived?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    contractorId: number
    clientId: number
    serviceId: number
    serviceAddress: string
    scheduledDate: Date
    scheduledTime: string
    estimatedDuration: number | null
    status: $Enums.BookingStatus
    price: number | null
    paymentReceived: boolean
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    clientId?: boolean
    serviceId?: boolean
    serviceAddress?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    estimatedDuration?: boolean
    status?: boolean
    price?: boolean
    paymentReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    completion?: boolean | Booking$completionArgs<ExtArgs>
    photos?: boolean | Booking$photosArgs<ExtArgs>
    invoice?: boolean | Booking$invoiceArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    reports?: boolean | Booking$reportsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    clientId?: boolean
    serviceId?: boolean
    serviceAddress?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    estimatedDuration?: boolean
    status?: boolean
    price?: boolean
    paymentReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    clientId?: boolean
    serviceId?: boolean
    serviceAddress?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    estimatedDuration?: boolean
    status?: boolean
    price?: boolean
    paymentReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    contractorId?: boolean
    clientId?: boolean
    serviceId?: boolean
    serviceAddress?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    estimatedDuration?: boolean
    status?: boolean
    price?: boolean
    paymentReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractorId" | "clientId" | "serviceId" | "serviceAddress" | "scheduledDate" | "scheduledTime" | "estimatedDuration" | "status" | "price" | "paymentReceived" | "createdAt" | "updatedAt", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    completion?: boolean | Booking$completionArgs<ExtArgs>
    photos?: boolean | Booking$photosArgs<ExtArgs>
    invoice?: boolean | Booking$invoiceArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    reports?: boolean | Booking$reportsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      contractor: Prisma.$ContractorPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      completion: Prisma.$JobCompletionPayload<ExtArgs> | null
      photos: Prisma.$JobPhotoPayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contractorId: number
      clientId: number
      serviceId: number
      serviceAddress: string
      scheduledDate: Date
      scheduledTime: string
      estimatedDuration: number | null
      status: $Enums.BookingStatus
      price: number | null
      paymentReceived: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contractor<T extends ContractorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractorDefaultArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    completion<T extends Booking$completionArgs<ExtArgs> = {}>(args?: Subset<T, Booking$completionArgs<ExtArgs>>): Prisma__JobCompletionClient<$Result.GetResult<Prisma.$JobCompletionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    photos<T extends Booking$photosArgs<ExtArgs> = {}>(args?: Subset<T, Booking$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice<T extends Booking$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Booking$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends Booking$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends Booking$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly contractorId: FieldRef<"Booking", 'Int'>
    readonly clientId: FieldRef<"Booking", 'Int'>
    readonly serviceId: FieldRef<"Booking", 'Int'>
    readonly serviceAddress: FieldRef<"Booking", 'String'>
    readonly scheduledDate: FieldRef<"Booking", 'DateTime'>
    readonly scheduledTime: FieldRef<"Booking", 'String'>
    readonly estimatedDuration: FieldRef<"Booking", 'Int'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly price: FieldRef<"Booking", 'Float'>
    readonly paymentReceived: FieldRef<"Booking", 'Boolean'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.completion
   */
  export type Booking$completionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCompletion
     */
    select?: JobCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobCompletion
     */
    omit?: JobCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobCompletionInclude<ExtArgs> | null
    where?: JobCompletionWhereInput
  }

  /**
   * Booking.photos
   */
  export type Booking$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPhoto
     */
    select?: JobPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPhoto
     */
    omit?: JobPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPhotoInclude<ExtArgs> | null
    where?: JobPhotoWhereInput
    orderBy?: JobPhotoOrderByWithRelationInput | JobPhotoOrderByWithRelationInput[]
    cursor?: JobPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobPhotoScalarFieldEnum | JobPhotoScalarFieldEnum[]
  }

  /**
   * Booking.invoice
   */
  export type Booking$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Booking.payments
   */
  export type Booking$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Booking.reports
   */
  export type Booking$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model JobCompletion
   */

  export type AggregateJobCompletion = {
    _count: JobCompletionCountAggregateOutputType | null
    _avg: JobCompletionAvgAggregateOutputType | null
    _sum: JobCompletionSumAggregateOutputType | null
    _min: JobCompletionMinAggregateOutputType | null
    _max: JobCompletionMaxAggregateOutputType | null
  }

  export type JobCompletionAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
  }

  export type JobCompletionSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
  }

  export type JobCompletionMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    startTime: Date | null
    endTime: Date | null
    materials: string | null
    notes: string | null
    audioNoteUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobCompletionMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    startTime: Date | null
    endTime: Date | null
    materials: string | null
    notes: string | null
    audioNoteUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobCompletionCountAggregateOutputType = {
    id: number
    bookingId: number
    startTime: number
    endTime: number
    materials: number
    notes: number
    audioNoteUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobCompletionAvgAggregateInputType = {
    id?: true
    bookingId?: true
  }

  export type JobCompletionSumAggregateInputType = {
    id?: true
    bookingId?: true
  }

  export type JobCompletionMinAggregateInputType = {
    id?: true
    bookingId?: true
    startTime?: true
    endTime?: true
    materials?: true
    notes?: true
    audioNoteUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobCompletionMaxAggregateInputType = {
    id?: true
    bookingId?: true
    startTime?: true
    endTime?: true
    materials?: true
    notes?: true
    audioNoteUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobCompletionCountAggregateInputType = {
    id?: true
    bookingId?: true
    startTime?: true
    endTime?: true
    materials?: true
    notes?: true
    audioNoteUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobCompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobCompletion to aggregate.
     */
    where?: JobCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobCompletions to fetch.
     */
    orderBy?: JobCompletionOrderByWithRelationInput | JobCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobCompletions
    **/
    _count?: true | JobCompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobCompletionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobCompletionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobCompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobCompletionMaxAggregateInputType
  }

  export type GetJobCompletionAggregateType<T extends JobCompletionAggregateArgs> = {
        [P in keyof T & keyof AggregateJobCompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobCompletion[P]>
      : GetScalarType<T[P], AggregateJobCompletion[P]>
  }




  export type JobCompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobCompletionWhereInput
    orderBy?: JobCompletionOrderByWithAggregationInput | JobCompletionOrderByWithAggregationInput[]
    by: JobCompletionScalarFieldEnum[] | JobCompletionScalarFieldEnum
    having?: JobCompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCompletionCountAggregateInputType | true
    _avg?: JobCompletionAvgAggregateInputType
    _sum?: JobCompletionSumAggregateInputType
    _min?: JobCompletionMinAggregateInputType
    _max?: JobCompletionMaxAggregateInputType
  }

  export type JobCompletionGroupByOutputType = {
    id: number
    bookingId: number
    startTime: Date | null
    endTime: Date | null
    materials: string | null
    notes: string | null
    audioNoteUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: JobCompletionCountAggregateOutputType | null
    _avg: JobCompletionAvgAggregateOutputType | null
    _sum: JobCompletionSumAggregateOutputType | null
    _min: JobCompletionMinAggregateOutputType | null
    _max: JobCompletionMaxAggregateOutputType | null
  }

  type GetJobCompletionGroupByPayload<T extends JobCompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobCompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobCompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobCompletionGroupByOutputType[P]>
            : GetScalarType<T[P], JobCompletionGroupByOutputType[P]>
        }
      >
    >


  export type JobCompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    startTime?: boolean
    endTime?: boolean
    materials?: boolean
    notes?: boolean
    audioNoteUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobCompletion"]>

  export type JobCompletionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    startTime?: boolean
    endTime?: boolean
    materials?: boolean
    notes?: boolean
    audioNoteUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobCompletion"]>

  export type JobCompletionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    startTime?: boolean
    endTime?: boolean
    materials?: boolean
    notes?: boolean
    audioNoteUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobCompletion"]>

  export type JobCompletionSelectScalar = {
    id?: boolean
    bookingId?: boolean
    startTime?: boolean
    endTime?: boolean
    materials?: boolean
    notes?: boolean
    audioNoteUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobCompletionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "startTime" | "endTime" | "materials" | "notes" | "audioNoteUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["jobCompletion"]>
  export type JobCompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type JobCompletionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type JobCompletionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $JobCompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobCompletion"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      startTime: Date | null
      endTime: Date | null
      materials: string | null
      notes: string | null
      audioNoteUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobCompletion"]>
    composites: {}
  }

  type JobCompletionGetPayload<S extends boolean | null | undefined | JobCompletionDefaultArgs> = $Result.GetResult<Prisma.$JobCompletionPayload, S>

  type JobCompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobCompletionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobCompletionCountAggregateInputType | true
    }

  export interface JobCompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobCompletion'], meta: { name: 'JobCompletion' } }
    /**
     * Find zero or one JobCompletion that matches the filter.
     * @param {JobCompletionFindUniqueArgs} args - Arguments to find a JobCompletion
     * @example
     * // Get one JobCompletion
     * const jobCompletion = await prisma.jobCompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobCompletionFindUniqueArgs>(args: SelectSubset<T, JobCompletionFindUniqueArgs<ExtArgs>>): Prisma__JobCompletionClient<$Result.GetResult<Prisma.$JobCompletionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobCompletion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobCompletionFindUniqueOrThrowArgs} args - Arguments to find a JobCompletion
     * @example
     * // Get one JobCompletion
     * const jobCompletion = await prisma.jobCompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobCompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, JobCompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobCompletionClient<$Result.GetResult<Prisma.$JobCompletionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobCompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCompletionFindFirstArgs} args - Arguments to find a JobCompletion
     * @example
     * // Get one JobCompletion
     * const jobCompletion = await prisma.jobCompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobCompletionFindFirstArgs>(args?: SelectSubset<T, JobCompletionFindFirstArgs<ExtArgs>>): Prisma__JobCompletionClient<$Result.GetResult<Prisma.$JobCompletionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobCompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCompletionFindFirstOrThrowArgs} args - Arguments to find a JobCompletion
     * @example
     * // Get one JobCompletion
     * const jobCompletion = await prisma.jobCompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobCompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, JobCompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobCompletionClient<$Result.GetResult<Prisma.$JobCompletionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobCompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobCompletions
     * const jobCompletions = await prisma.jobCompletion.findMany()
     * 
     * // Get first 10 JobCompletions
     * const jobCompletions = await prisma.jobCompletion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobCompletionWithIdOnly = await prisma.jobCompletion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobCompletionFindManyArgs>(args?: SelectSubset<T, JobCompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobCompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobCompletion.
     * @param {JobCompletionCreateArgs} args - Arguments to create a JobCompletion.
     * @example
     * // Create one JobCompletion
     * const JobCompletion = await prisma.jobCompletion.create({
     *   data: {
     *     // ... data to create a JobCompletion
     *   }
     * })
     * 
     */
    create<T extends JobCompletionCreateArgs>(args: SelectSubset<T, JobCompletionCreateArgs<ExtArgs>>): Prisma__JobCompletionClient<$Result.GetResult<Prisma.$JobCompletionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobCompletions.
     * @param {JobCompletionCreateManyArgs} args - Arguments to create many JobCompletions.
     * @example
     * // Create many JobCompletions
     * const jobCompletion = await prisma.jobCompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobCompletionCreateManyArgs>(args?: SelectSubset<T, JobCompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobCompletions and returns the data saved in the database.
     * @param {JobCompletionCreateManyAndReturnArgs} args - Arguments to create many JobCompletions.
     * @example
     * // Create many JobCompletions
     * const jobCompletion = await prisma.jobCompletion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobCompletions and only return the `id`
     * const jobCompletionWithIdOnly = await prisma.jobCompletion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobCompletionCreateManyAndReturnArgs>(args?: SelectSubset<T, JobCompletionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobCompletionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobCompletion.
     * @param {JobCompletionDeleteArgs} args - Arguments to delete one JobCompletion.
     * @example
     * // Delete one JobCompletion
     * const JobCompletion = await prisma.jobCompletion.delete({
     *   where: {
     *     // ... filter to delete one JobCompletion
     *   }
     * })
     * 
     */
    delete<T extends JobCompletionDeleteArgs>(args: SelectSubset<T, JobCompletionDeleteArgs<ExtArgs>>): Prisma__JobCompletionClient<$Result.GetResult<Prisma.$JobCompletionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobCompletion.
     * @param {JobCompletionUpdateArgs} args - Arguments to update one JobCompletion.
     * @example
     * // Update one JobCompletion
     * const jobCompletion = await prisma.jobCompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobCompletionUpdateArgs>(args: SelectSubset<T, JobCompletionUpdateArgs<ExtArgs>>): Prisma__JobCompletionClient<$Result.GetResult<Prisma.$JobCompletionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobCompletions.
     * @param {JobCompletionDeleteManyArgs} args - Arguments to filter JobCompletions to delete.
     * @example
     * // Delete a few JobCompletions
     * const { count } = await prisma.jobCompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobCompletionDeleteManyArgs>(args?: SelectSubset<T, JobCompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobCompletions
     * const jobCompletion = await prisma.jobCompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobCompletionUpdateManyArgs>(args: SelectSubset<T, JobCompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobCompletions and returns the data updated in the database.
     * @param {JobCompletionUpdateManyAndReturnArgs} args - Arguments to update many JobCompletions.
     * @example
     * // Update many JobCompletions
     * const jobCompletion = await prisma.jobCompletion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobCompletions and only return the `id`
     * const jobCompletionWithIdOnly = await prisma.jobCompletion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobCompletionUpdateManyAndReturnArgs>(args: SelectSubset<T, JobCompletionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobCompletionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobCompletion.
     * @param {JobCompletionUpsertArgs} args - Arguments to update or create a JobCompletion.
     * @example
     * // Update or create a JobCompletion
     * const jobCompletion = await prisma.jobCompletion.upsert({
     *   create: {
     *     // ... data to create a JobCompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobCompletion we want to update
     *   }
     * })
     */
    upsert<T extends JobCompletionUpsertArgs>(args: SelectSubset<T, JobCompletionUpsertArgs<ExtArgs>>): Prisma__JobCompletionClient<$Result.GetResult<Prisma.$JobCompletionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCompletionCountArgs} args - Arguments to filter JobCompletions to count.
     * @example
     * // Count the number of JobCompletions
     * const count = await prisma.jobCompletion.count({
     *   where: {
     *     // ... the filter for the JobCompletions we want to count
     *   }
     * })
    **/
    count<T extends JobCompletionCountArgs>(
      args?: Subset<T, JobCompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobCompletionAggregateArgs>(args: Subset<T, JobCompletionAggregateArgs>): Prisma.PrismaPromise<GetJobCompletionAggregateType<T>>

    /**
     * Group by JobCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobCompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobCompletionGroupByArgs['orderBy'] }
        : { orderBy?: JobCompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobCompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobCompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobCompletion model
   */
  readonly fields: JobCompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobCompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobCompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobCompletion model
   */
  interface JobCompletionFieldRefs {
    readonly id: FieldRef<"JobCompletion", 'Int'>
    readonly bookingId: FieldRef<"JobCompletion", 'Int'>
    readonly startTime: FieldRef<"JobCompletion", 'DateTime'>
    readonly endTime: FieldRef<"JobCompletion", 'DateTime'>
    readonly materials: FieldRef<"JobCompletion", 'String'>
    readonly notes: FieldRef<"JobCompletion", 'String'>
    readonly audioNoteUrl: FieldRef<"JobCompletion", 'String'>
    readonly createdAt: FieldRef<"JobCompletion", 'DateTime'>
    readonly updatedAt: FieldRef<"JobCompletion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobCompletion findUnique
   */
  export type JobCompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCompletion
     */
    select?: JobCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobCompletion
     */
    omit?: JobCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobCompletionInclude<ExtArgs> | null
    /**
     * Filter, which JobCompletion to fetch.
     */
    where: JobCompletionWhereUniqueInput
  }

  /**
   * JobCompletion findUniqueOrThrow
   */
  export type JobCompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCompletion
     */
    select?: JobCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobCompletion
     */
    omit?: JobCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobCompletionInclude<ExtArgs> | null
    /**
     * Filter, which JobCompletion to fetch.
     */
    where: JobCompletionWhereUniqueInput
  }

  /**
   * JobCompletion findFirst
   */
  export type JobCompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCompletion
     */
    select?: JobCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobCompletion
     */
    omit?: JobCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobCompletionInclude<ExtArgs> | null
    /**
     * Filter, which JobCompletion to fetch.
     */
    where?: JobCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobCompletions to fetch.
     */
    orderBy?: JobCompletionOrderByWithRelationInput | JobCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobCompletions.
     */
    cursor?: JobCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobCompletions.
     */
    distinct?: JobCompletionScalarFieldEnum | JobCompletionScalarFieldEnum[]
  }

  /**
   * JobCompletion findFirstOrThrow
   */
  export type JobCompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCompletion
     */
    select?: JobCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobCompletion
     */
    omit?: JobCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobCompletionInclude<ExtArgs> | null
    /**
     * Filter, which JobCompletion to fetch.
     */
    where?: JobCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobCompletions to fetch.
     */
    orderBy?: JobCompletionOrderByWithRelationInput | JobCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobCompletions.
     */
    cursor?: JobCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobCompletions.
     */
    distinct?: JobCompletionScalarFieldEnum | JobCompletionScalarFieldEnum[]
  }

  /**
   * JobCompletion findMany
   */
  export type JobCompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCompletion
     */
    select?: JobCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobCompletion
     */
    omit?: JobCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobCompletionInclude<ExtArgs> | null
    /**
     * Filter, which JobCompletions to fetch.
     */
    where?: JobCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobCompletions to fetch.
     */
    orderBy?: JobCompletionOrderByWithRelationInput | JobCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobCompletions.
     */
    cursor?: JobCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobCompletions.
     */
    skip?: number
    distinct?: JobCompletionScalarFieldEnum | JobCompletionScalarFieldEnum[]
  }

  /**
   * JobCompletion create
   */
  export type JobCompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCompletion
     */
    select?: JobCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobCompletion
     */
    omit?: JobCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobCompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a JobCompletion.
     */
    data: XOR<JobCompletionCreateInput, JobCompletionUncheckedCreateInput>
  }

  /**
   * JobCompletion createMany
   */
  export type JobCompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobCompletions.
     */
    data: JobCompletionCreateManyInput | JobCompletionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobCompletion createManyAndReturn
   */
  export type JobCompletionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCompletion
     */
    select?: JobCompletionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobCompletion
     */
    omit?: JobCompletionOmit<ExtArgs> | null
    /**
     * The data used to create many JobCompletions.
     */
    data: JobCompletionCreateManyInput | JobCompletionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobCompletionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobCompletion update
   */
  export type JobCompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCompletion
     */
    select?: JobCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobCompletion
     */
    omit?: JobCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobCompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a JobCompletion.
     */
    data: XOR<JobCompletionUpdateInput, JobCompletionUncheckedUpdateInput>
    /**
     * Choose, which JobCompletion to update.
     */
    where: JobCompletionWhereUniqueInput
  }

  /**
   * JobCompletion updateMany
   */
  export type JobCompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobCompletions.
     */
    data: XOR<JobCompletionUpdateManyMutationInput, JobCompletionUncheckedUpdateManyInput>
    /**
     * Filter which JobCompletions to update
     */
    where?: JobCompletionWhereInput
    /**
     * Limit how many JobCompletions to update.
     */
    limit?: number
  }

  /**
   * JobCompletion updateManyAndReturn
   */
  export type JobCompletionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCompletion
     */
    select?: JobCompletionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobCompletion
     */
    omit?: JobCompletionOmit<ExtArgs> | null
    /**
     * The data used to update JobCompletions.
     */
    data: XOR<JobCompletionUpdateManyMutationInput, JobCompletionUncheckedUpdateManyInput>
    /**
     * Filter which JobCompletions to update
     */
    where?: JobCompletionWhereInput
    /**
     * Limit how many JobCompletions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobCompletionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobCompletion upsert
   */
  export type JobCompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCompletion
     */
    select?: JobCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobCompletion
     */
    omit?: JobCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobCompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the JobCompletion to update in case it exists.
     */
    where: JobCompletionWhereUniqueInput
    /**
     * In case the JobCompletion found by the `where` argument doesn't exist, create a new JobCompletion with this data.
     */
    create: XOR<JobCompletionCreateInput, JobCompletionUncheckedCreateInput>
    /**
     * In case the JobCompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobCompletionUpdateInput, JobCompletionUncheckedUpdateInput>
  }

  /**
   * JobCompletion delete
   */
  export type JobCompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCompletion
     */
    select?: JobCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobCompletion
     */
    omit?: JobCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobCompletionInclude<ExtArgs> | null
    /**
     * Filter which JobCompletion to delete.
     */
    where: JobCompletionWhereUniqueInput
  }

  /**
   * JobCompletion deleteMany
   */
  export type JobCompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobCompletions to delete
     */
    where?: JobCompletionWhereInput
    /**
     * Limit how many JobCompletions to delete.
     */
    limit?: number
  }

  /**
   * JobCompletion without action
   */
  export type JobCompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCompletion
     */
    select?: JobCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobCompletion
     */
    omit?: JobCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobCompletionInclude<ExtArgs> | null
  }


  /**
   * Model JobPhoto
   */

  export type AggregateJobPhoto = {
    _count: JobPhotoCountAggregateOutputType | null
    _avg: JobPhotoAvgAggregateOutputType | null
    _sum: JobPhotoSumAggregateOutputType | null
    _min: JobPhotoMinAggregateOutputType | null
    _max: JobPhotoMaxAggregateOutputType | null
  }

  export type JobPhotoAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    fileSize: number | null
  }

  export type JobPhotoSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    fileSize: number | null
  }

  export type JobPhotoMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    filename: string | null
    originalName: string | null
    photoType: $Enums.PhotoType | null
    fileSize: number | null
    url: string | null
    createdAt: Date | null
  }

  export type JobPhotoMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    filename: string | null
    originalName: string | null
    photoType: $Enums.PhotoType | null
    fileSize: number | null
    url: string | null
    createdAt: Date | null
  }

  export type JobPhotoCountAggregateOutputType = {
    id: number
    bookingId: number
    filename: number
    originalName: number
    photoType: number
    fileSize: number
    url: number
    createdAt: number
    _all: number
  }


  export type JobPhotoAvgAggregateInputType = {
    id?: true
    bookingId?: true
    fileSize?: true
  }

  export type JobPhotoSumAggregateInputType = {
    id?: true
    bookingId?: true
    fileSize?: true
  }

  export type JobPhotoMinAggregateInputType = {
    id?: true
    bookingId?: true
    filename?: true
    originalName?: true
    photoType?: true
    fileSize?: true
    url?: true
    createdAt?: true
  }

  export type JobPhotoMaxAggregateInputType = {
    id?: true
    bookingId?: true
    filename?: true
    originalName?: true
    photoType?: true
    fileSize?: true
    url?: true
    createdAt?: true
  }

  export type JobPhotoCountAggregateInputType = {
    id?: true
    bookingId?: true
    filename?: true
    originalName?: true
    photoType?: true
    fileSize?: true
    url?: true
    createdAt?: true
    _all?: true
  }

  export type JobPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPhoto to aggregate.
     */
    where?: JobPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPhotos to fetch.
     */
    orderBy?: JobPhotoOrderByWithRelationInput | JobPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPhotos
    **/
    _count?: true | JobPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobPhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobPhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPhotoMaxAggregateInputType
  }

  export type GetJobPhotoAggregateType<T extends JobPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPhoto[P]>
      : GetScalarType<T[P], AggregateJobPhoto[P]>
  }




  export type JobPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPhotoWhereInput
    orderBy?: JobPhotoOrderByWithAggregationInput | JobPhotoOrderByWithAggregationInput[]
    by: JobPhotoScalarFieldEnum[] | JobPhotoScalarFieldEnum
    having?: JobPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPhotoCountAggregateInputType | true
    _avg?: JobPhotoAvgAggregateInputType
    _sum?: JobPhotoSumAggregateInputType
    _min?: JobPhotoMinAggregateInputType
    _max?: JobPhotoMaxAggregateInputType
  }

  export type JobPhotoGroupByOutputType = {
    id: number
    bookingId: number
    filename: string
    originalName: string
    photoType: $Enums.PhotoType
    fileSize: number
    url: string
    createdAt: Date
    _count: JobPhotoCountAggregateOutputType | null
    _avg: JobPhotoAvgAggregateOutputType | null
    _sum: JobPhotoSumAggregateOutputType | null
    _min: JobPhotoMinAggregateOutputType | null
    _max: JobPhotoMaxAggregateOutputType | null
  }

  type GetJobPhotoGroupByPayload<T extends JobPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], JobPhotoGroupByOutputType[P]>
        }
      >
    >


  export type JobPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    filename?: boolean
    originalName?: boolean
    photoType?: boolean
    fileSize?: boolean
    url?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPhoto"]>

  export type JobPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    filename?: boolean
    originalName?: boolean
    photoType?: boolean
    fileSize?: boolean
    url?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPhoto"]>

  export type JobPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    filename?: boolean
    originalName?: boolean
    photoType?: boolean
    fileSize?: boolean
    url?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPhoto"]>

  export type JobPhotoSelectScalar = {
    id?: boolean
    bookingId?: boolean
    filename?: boolean
    originalName?: boolean
    photoType?: boolean
    fileSize?: boolean
    url?: boolean
    createdAt?: boolean
  }

  export type JobPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "filename" | "originalName" | "photoType" | "fileSize" | "url" | "createdAt", ExtArgs["result"]["jobPhoto"]>
  export type JobPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type JobPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type JobPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $JobPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPhoto"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      filename: string
      originalName: string
      photoType: $Enums.PhotoType
      fileSize: number
      url: string
      createdAt: Date
    }, ExtArgs["result"]["jobPhoto"]>
    composites: {}
  }

  type JobPhotoGetPayload<S extends boolean | null | undefined | JobPhotoDefaultArgs> = $Result.GetResult<Prisma.$JobPhotoPayload, S>

  type JobPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobPhotoCountAggregateInputType | true
    }

  export interface JobPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPhoto'], meta: { name: 'JobPhoto' } }
    /**
     * Find zero or one JobPhoto that matches the filter.
     * @param {JobPhotoFindUniqueArgs} args - Arguments to find a JobPhoto
     * @example
     * // Get one JobPhoto
     * const jobPhoto = await prisma.jobPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobPhotoFindUniqueArgs>(args: SelectSubset<T, JobPhotoFindUniqueArgs<ExtArgs>>): Prisma__JobPhotoClient<$Result.GetResult<Prisma.$JobPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobPhotoFindUniqueOrThrowArgs} args - Arguments to find a JobPhoto
     * @example
     * // Get one JobPhoto
     * const jobPhoto = await prisma.jobPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, JobPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobPhotoClient<$Result.GetResult<Prisma.$JobPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPhotoFindFirstArgs} args - Arguments to find a JobPhoto
     * @example
     * // Get one JobPhoto
     * const jobPhoto = await prisma.jobPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobPhotoFindFirstArgs>(args?: SelectSubset<T, JobPhotoFindFirstArgs<ExtArgs>>): Prisma__JobPhotoClient<$Result.GetResult<Prisma.$JobPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPhotoFindFirstOrThrowArgs} args - Arguments to find a JobPhoto
     * @example
     * // Get one JobPhoto
     * const jobPhoto = await prisma.jobPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, JobPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobPhotoClient<$Result.GetResult<Prisma.$JobPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPhotos
     * const jobPhotos = await prisma.jobPhoto.findMany()
     * 
     * // Get first 10 JobPhotos
     * const jobPhotos = await prisma.jobPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPhotoWithIdOnly = await prisma.jobPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobPhotoFindManyArgs>(args?: SelectSubset<T, JobPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobPhoto.
     * @param {JobPhotoCreateArgs} args - Arguments to create a JobPhoto.
     * @example
     * // Create one JobPhoto
     * const JobPhoto = await prisma.jobPhoto.create({
     *   data: {
     *     // ... data to create a JobPhoto
     *   }
     * })
     * 
     */
    create<T extends JobPhotoCreateArgs>(args: SelectSubset<T, JobPhotoCreateArgs<ExtArgs>>): Prisma__JobPhotoClient<$Result.GetResult<Prisma.$JobPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobPhotos.
     * @param {JobPhotoCreateManyArgs} args - Arguments to create many JobPhotos.
     * @example
     * // Create many JobPhotos
     * const jobPhoto = await prisma.jobPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobPhotoCreateManyArgs>(args?: SelectSubset<T, JobPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobPhotos and returns the data saved in the database.
     * @param {JobPhotoCreateManyAndReturnArgs} args - Arguments to create many JobPhotos.
     * @example
     * // Create many JobPhotos
     * const jobPhoto = await prisma.jobPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobPhotos and only return the `id`
     * const jobPhotoWithIdOnly = await prisma.jobPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, JobPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobPhoto.
     * @param {JobPhotoDeleteArgs} args - Arguments to delete one JobPhoto.
     * @example
     * // Delete one JobPhoto
     * const JobPhoto = await prisma.jobPhoto.delete({
     *   where: {
     *     // ... filter to delete one JobPhoto
     *   }
     * })
     * 
     */
    delete<T extends JobPhotoDeleteArgs>(args: SelectSubset<T, JobPhotoDeleteArgs<ExtArgs>>): Prisma__JobPhotoClient<$Result.GetResult<Prisma.$JobPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobPhoto.
     * @param {JobPhotoUpdateArgs} args - Arguments to update one JobPhoto.
     * @example
     * // Update one JobPhoto
     * const jobPhoto = await prisma.jobPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobPhotoUpdateArgs>(args: SelectSubset<T, JobPhotoUpdateArgs<ExtArgs>>): Prisma__JobPhotoClient<$Result.GetResult<Prisma.$JobPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobPhotos.
     * @param {JobPhotoDeleteManyArgs} args - Arguments to filter JobPhotos to delete.
     * @example
     * // Delete a few JobPhotos
     * const { count } = await prisma.jobPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobPhotoDeleteManyArgs>(args?: SelectSubset<T, JobPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPhotos
     * const jobPhoto = await prisma.jobPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobPhotoUpdateManyArgs>(args: SelectSubset<T, JobPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPhotos and returns the data updated in the database.
     * @param {JobPhotoUpdateManyAndReturnArgs} args - Arguments to update many JobPhotos.
     * @example
     * // Update many JobPhotos
     * const jobPhoto = await prisma.jobPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobPhotos and only return the `id`
     * const jobPhotoWithIdOnly = await prisma.jobPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, JobPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobPhoto.
     * @param {JobPhotoUpsertArgs} args - Arguments to update or create a JobPhoto.
     * @example
     * // Update or create a JobPhoto
     * const jobPhoto = await prisma.jobPhoto.upsert({
     *   create: {
     *     // ... data to create a JobPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPhoto we want to update
     *   }
     * })
     */
    upsert<T extends JobPhotoUpsertArgs>(args: SelectSubset<T, JobPhotoUpsertArgs<ExtArgs>>): Prisma__JobPhotoClient<$Result.GetResult<Prisma.$JobPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPhotoCountArgs} args - Arguments to filter JobPhotos to count.
     * @example
     * // Count the number of JobPhotos
     * const count = await prisma.jobPhoto.count({
     *   where: {
     *     // ... the filter for the JobPhotos we want to count
     *   }
     * })
    **/
    count<T extends JobPhotoCountArgs>(
      args?: Subset<T, JobPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPhotoAggregateArgs>(args: Subset<T, JobPhotoAggregateArgs>): Prisma.PrismaPromise<GetJobPhotoAggregateType<T>>

    /**
     * Group by JobPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPhotoGroupByArgs['orderBy'] }
        : { orderBy?: JobPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPhoto model
   */
  readonly fields: JobPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobPhoto model
   */
  interface JobPhotoFieldRefs {
    readonly id: FieldRef<"JobPhoto", 'Int'>
    readonly bookingId: FieldRef<"JobPhoto", 'Int'>
    readonly filename: FieldRef<"JobPhoto", 'String'>
    readonly originalName: FieldRef<"JobPhoto", 'String'>
    readonly photoType: FieldRef<"JobPhoto", 'PhotoType'>
    readonly fileSize: FieldRef<"JobPhoto", 'Int'>
    readonly url: FieldRef<"JobPhoto", 'String'>
    readonly createdAt: FieldRef<"JobPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobPhoto findUnique
   */
  export type JobPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPhoto
     */
    select?: JobPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPhoto
     */
    omit?: JobPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPhotoInclude<ExtArgs> | null
    /**
     * Filter, which JobPhoto to fetch.
     */
    where: JobPhotoWhereUniqueInput
  }

  /**
   * JobPhoto findUniqueOrThrow
   */
  export type JobPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPhoto
     */
    select?: JobPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPhoto
     */
    omit?: JobPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPhotoInclude<ExtArgs> | null
    /**
     * Filter, which JobPhoto to fetch.
     */
    where: JobPhotoWhereUniqueInput
  }

  /**
   * JobPhoto findFirst
   */
  export type JobPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPhoto
     */
    select?: JobPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPhoto
     */
    omit?: JobPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPhotoInclude<ExtArgs> | null
    /**
     * Filter, which JobPhoto to fetch.
     */
    where?: JobPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPhotos to fetch.
     */
    orderBy?: JobPhotoOrderByWithRelationInput | JobPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPhotos.
     */
    cursor?: JobPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPhotos.
     */
    distinct?: JobPhotoScalarFieldEnum | JobPhotoScalarFieldEnum[]
  }

  /**
   * JobPhoto findFirstOrThrow
   */
  export type JobPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPhoto
     */
    select?: JobPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPhoto
     */
    omit?: JobPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPhotoInclude<ExtArgs> | null
    /**
     * Filter, which JobPhoto to fetch.
     */
    where?: JobPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPhotos to fetch.
     */
    orderBy?: JobPhotoOrderByWithRelationInput | JobPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPhotos.
     */
    cursor?: JobPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPhotos.
     */
    distinct?: JobPhotoScalarFieldEnum | JobPhotoScalarFieldEnum[]
  }

  /**
   * JobPhoto findMany
   */
  export type JobPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPhoto
     */
    select?: JobPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPhoto
     */
    omit?: JobPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPhotoInclude<ExtArgs> | null
    /**
     * Filter, which JobPhotos to fetch.
     */
    where?: JobPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPhotos to fetch.
     */
    orderBy?: JobPhotoOrderByWithRelationInput | JobPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPhotos.
     */
    cursor?: JobPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPhotos.
     */
    skip?: number
    distinct?: JobPhotoScalarFieldEnum | JobPhotoScalarFieldEnum[]
  }

  /**
   * JobPhoto create
   */
  export type JobPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPhoto
     */
    select?: JobPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPhoto
     */
    omit?: JobPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPhoto.
     */
    data: XOR<JobPhotoCreateInput, JobPhotoUncheckedCreateInput>
  }

  /**
   * JobPhoto createMany
   */
  export type JobPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPhotos.
     */
    data: JobPhotoCreateManyInput | JobPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPhoto createManyAndReturn
   */
  export type JobPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPhoto
     */
    select?: JobPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPhoto
     */
    omit?: JobPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many JobPhotos.
     */
    data: JobPhotoCreateManyInput | JobPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPhoto update
   */
  export type JobPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPhoto
     */
    select?: JobPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPhoto
     */
    omit?: JobPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPhoto.
     */
    data: XOR<JobPhotoUpdateInput, JobPhotoUncheckedUpdateInput>
    /**
     * Choose, which JobPhoto to update.
     */
    where: JobPhotoWhereUniqueInput
  }

  /**
   * JobPhoto updateMany
   */
  export type JobPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPhotos.
     */
    data: XOR<JobPhotoUpdateManyMutationInput, JobPhotoUncheckedUpdateManyInput>
    /**
     * Filter which JobPhotos to update
     */
    where?: JobPhotoWhereInput
    /**
     * Limit how many JobPhotos to update.
     */
    limit?: number
  }

  /**
   * JobPhoto updateManyAndReturn
   */
  export type JobPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPhoto
     */
    select?: JobPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPhoto
     */
    omit?: JobPhotoOmit<ExtArgs> | null
    /**
     * The data used to update JobPhotos.
     */
    data: XOR<JobPhotoUpdateManyMutationInput, JobPhotoUncheckedUpdateManyInput>
    /**
     * Filter which JobPhotos to update
     */
    where?: JobPhotoWhereInput
    /**
     * Limit how many JobPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPhoto upsert
   */
  export type JobPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPhoto
     */
    select?: JobPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPhoto
     */
    omit?: JobPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPhoto to update in case it exists.
     */
    where: JobPhotoWhereUniqueInput
    /**
     * In case the JobPhoto found by the `where` argument doesn't exist, create a new JobPhoto with this data.
     */
    create: XOR<JobPhotoCreateInput, JobPhotoUncheckedCreateInput>
    /**
     * In case the JobPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPhotoUpdateInput, JobPhotoUncheckedUpdateInput>
  }

  /**
   * JobPhoto delete
   */
  export type JobPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPhoto
     */
    select?: JobPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPhoto
     */
    omit?: JobPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPhotoInclude<ExtArgs> | null
    /**
     * Filter which JobPhoto to delete.
     */
    where: JobPhotoWhereUniqueInput
  }

  /**
   * JobPhoto deleteMany
   */
  export type JobPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPhotos to delete
     */
    where?: JobPhotoWhereInput
    /**
     * Limit how many JobPhotos to delete.
     */
    limit?: number
  }

  /**
   * JobPhoto without action
   */
  export type JobPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPhoto
     */
    select?: JobPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPhoto
     */
    omit?: JobPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPhotoInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    contractorId: number | null
    clientId: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    contractorId: number | null
    clientId: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    contractorId: number | null
    clientId: number | null
    subject: string | null
    status: $Enums.MessageStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    contractorId: number | null
    clientId: number | null
    subject: string | null
    status: $Enums.MessageStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    contractorId: number
    clientId: number
    subject: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
    subject?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
    subject?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
    subject?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    contractorId: number
    clientId: number
    subject: string | null
    status: $Enums.MessageStatus
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    clientId?: boolean
    subject?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    chatMessages?: boolean | Message$chatMessagesArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    clientId?: boolean
    subject?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    clientId?: boolean
    subject?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    contractorId?: boolean
    clientId?: boolean
    subject?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractorId" | "clientId" | "subject" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    chatMessages?: boolean | Message$chatMessagesArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      contractor: Prisma.$ContractorPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
      chatMessages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contractorId: number
      clientId: number
      subject: string | null
      status: $Enums.MessageStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contractor<T extends ContractorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractorDefaultArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chatMessages<T extends Message$chatMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Message$chatMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'Int'>
    readonly contractorId: FieldRef<"Message", 'Int'>
    readonly clientId: FieldRef<"Message", 'Int'>
    readonly subject: FieldRef<"Message", 'String'>
    readonly status: FieldRef<"Message", 'MessageStatus'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.chatMessages
   */
  export type Message$chatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageAvgAggregateOutputType = {
    id: number | null
    messageId: number | null
  }

  export type ChatMessageSumAggregateOutputType = {
    id: number | null
    messageId: number | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: number | null
    messageId: number | null
    sender: $Enums.SenderType | null
    messageText: string | null
    createdAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: number | null
    messageId: number | null
    sender: $Enums.SenderType | null
    messageText: string | null
    createdAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    messageId: number
    sender: number
    messageText: number
    createdAt: number
    _all: number
  }


  export type ChatMessageAvgAggregateInputType = {
    id?: true
    messageId?: true
  }

  export type ChatMessageSumAggregateInputType = {
    id?: true
    messageId?: true
  }

  export type ChatMessageMinAggregateInputType = {
    id?: true
    messageId?: true
    sender?: true
    messageText?: true
    createdAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    messageId?: true
    sender?: true
    messageText?: true
    createdAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    messageId?: true
    sender?: true
    messageText?: true
    createdAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _avg?: ChatMessageAvgAggregateInputType
    _sum?: ChatMessageSumAggregateInputType
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: number
    messageId: number
    sender: $Enums.SenderType
    messageText: string
    createdAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    sender?: boolean
    messageText?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    sender?: boolean
    messageText?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    sender?: boolean
    messageText?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    messageId?: boolean
    sender?: boolean
    messageText?: boolean
    createdAt?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "sender" | "messageText" | "createdAt", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      messageId: number
      sender: $Enums.SenderType
      messageText: string
      createdAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'Int'>
    readonly messageId: FieldRef<"ChatMessage", 'Int'>
    readonly sender: FieldRef<"ChatMessage", 'SenderType'>
    readonly messageText: FieldRef<"ChatMessage", 'String'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model FlaggedMessage
   */

  export type AggregateFlaggedMessage = {
    _count: FlaggedMessageCountAggregateOutputType | null
    _avg: FlaggedMessageAvgAggregateOutputType | null
    _sum: FlaggedMessageSumAggregateOutputType | null
    _min: FlaggedMessageMinAggregateOutputType | null
    _max: FlaggedMessageMaxAggregateOutputType | null
  }

  export type FlaggedMessageAvgAggregateOutputType = {
    id: number | null
    messageId: number | null
    flaggedById: number | null
    contractorId: number | null
    clientId: number | null
    reviewedBy: number | null
  }

  export type FlaggedMessageSumAggregateOutputType = {
    id: number | null
    messageId: number | null
    flaggedById: number | null
    contractorId: number | null
    clientId: number | null
    reviewedBy: number | null
  }

  export type FlaggedMessageMinAggregateOutputType = {
    id: number | null
    messageId: number | null
    messageText: string | null
    flaggedBy: $Enums.FlaggedByType | null
    flaggedById: number | null
    contractorId: number | null
    clientId: number | null
    reason: string | null
    details: string | null
    status: $Enums.FlagStatus | null
    reviewedBy: number | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type FlaggedMessageMaxAggregateOutputType = {
    id: number | null
    messageId: number | null
    messageText: string | null
    flaggedBy: $Enums.FlaggedByType | null
    flaggedById: number | null
    contractorId: number | null
    clientId: number | null
    reason: string | null
    details: string | null
    status: $Enums.FlagStatus | null
    reviewedBy: number | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type FlaggedMessageCountAggregateOutputType = {
    id: number
    messageId: number
    messageText: number
    flaggedBy: number
    flaggedById: number
    contractorId: number
    clientId: number
    reason: number
    details: number
    status: number
    reviewedBy: number
    reviewedAt: number
    createdAt: number
    _all: number
  }


  export type FlaggedMessageAvgAggregateInputType = {
    id?: true
    messageId?: true
    flaggedById?: true
    contractorId?: true
    clientId?: true
    reviewedBy?: true
  }

  export type FlaggedMessageSumAggregateInputType = {
    id?: true
    messageId?: true
    flaggedById?: true
    contractorId?: true
    clientId?: true
    reviewedBy?: true
  }

  export type FlaggedMessageMinAggregateInputType = {
    id?: true
    messageId?: true
    messageText?: true
    flaggedBy?: true
    flaggedById?: true
    contractorId?: true
    clientId?: true
    reason?: true
    details?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type FlaggedMessageMaxAggregateInputType = {
    id?: true
    messageId?: true
    messageText?: true
    flaggedBy?: true
    flaggedById?: true
    contractorId?: true
    clientId?: true
    reason?: true
    details?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type FlaggedMessageCountAggregateInputType = {
    id?: true
    messageId?: true
    messageText?: true
    flaggedBy?: true
    flaggedById?: true
    contractorId?: true
    clientId?: true
    reason?: true
    details?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    _all?: true
  }

  export type FlaggedMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlaggedMessage to aggregate.
     */
    where?: FlaggedMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlaggedMessages to fetch.
     */
    orderBy?: FlaggedMessageOrderByWithRelationInput | FlaggedMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlaggedMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlaggedMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlaggedMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlaggedMessages
    **/
    _count?: true | FlaggedMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlaggedMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlaggedMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlaggedMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlaggedMessageMaxAggregateInputType
  }

  export type GetFlaggedMessageAggregateType<T extends FlaggedMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateFlaggedMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlaggedMessage[P]>
      : GetScalarType<T[P], AggregateFlaggedMessage[P]>
  }




  export type FlaggedMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlaggedMessageWhereInput
    orderBy?: FlaggedMessageOrderByWithAggregationInput | FlaggedMessageOrderByWithAggregationInput[]
    by: FlaggedMessageScalarFieldEnum[] | FlaggedMessageScalarFieldEnum
    having?: FlaggedMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlaggedMessageCountAggregateInputType | true
    _avg?: FlaggedMessageAvgAggregateInputType
    _sum?: FlaggedMessageSumAggregateInputType
    _min?: FlaggedMessageMinAggregateInputType
    _max?: FlaggedMessageMaxAggregateInputType
  }

  export type FlaggedMessageGroupByOutputType = {
    id: number
    messageId: number | null
    messageText: string
    flaggedBy: $Enums.FlaggedByType
    flaggedById: number
    contractorId: number | null
    clientId: number | null
    reason: string
    details: string | null
    status: $Enums.FlagStatus
    reviewedBy: number | null
    reviewedAt: Date | null
    createdAt: Date
    _count: FlaggedMessageCountAggregateOutputType | null
    _avg: FlaggedMessageAvgAggregateOutputType | null
    _sum: FlaggedMessageSumAggregateOutputType | null
    _min: FlaggedMessageMinAggregateOutputType | null
    _max: FlaggedMessageMaxAggregateOutputType | null
  }

  type GetFlaggedMessageGroupByPayload<T extends FlaggedMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlaggedMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlaggedMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlaggedMessageGroupByOutputType[P]>
            : GetScalarType<T[P], FlaggedMessageGroupByOutputType[P]>
        }
      >
    >


  export type FlaggedMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    messageText?: boolean
    flaggedBy?: boolean
    flaggedById?: boolean
    contractorId?: boolean
    clientId?: boolean
    reason?: boolean
    details?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    contractor?: boolean | FlaggedMessage$contractorArgs<ExtArgs>
    client?: boolean | FlaggedMessage$clientArgs<ExtArgs>
  }, ExtArgs["result"]["flaggedMessage"]>

  export type FlaggedMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    messageText?: boolean
    flaggedBy?: boolean
    flaggedById?: boolean
    contractorId?: boolean
    clientId?: boolean
    reason?: boolean
    details?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    contractor?: boolean | FlaggedMessage$contractorArgs<ExtArgs>
    client?: boolean | FlaggedMessage$clientArgs<ExtArgs>
  }, ExtArgs["result"]["flaggedMessage"]>

  export type FlaggedMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    messageText?: boolean
    flaggedBy?: boolean
    flaggedById?: boolean
    contractorId?: boolean
    clientId?: boolean
    reason?: boolean
    details?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    contractor?: boolean | FlaggedMessage$contractorArgs<ExtArgs>
    client?: boolean | FlaggedMessage$clientArgs<ExtArgs>
  }, ExtArgs["result"]["flaggedMessage"]>

  export type FlaggedMessageSelectScalar = {
    id?: boolean
    messageId?: boolean
    messageText?: boolean
    flaggedBy?: boolean
    flaggedById?: boolean
    contractorId?: boolean
    clientId?: boolean
    reason?: boolean
    details?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
  }

  export type FlaggedMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "messageText" | "flaggedBy" | "flaggedById" | "contractorId" | "clientId" | "reason" | "details" | "status" | "reviewedBy" | "reviewedAt" | "createdAt", ExtArgs["result"]["flaggedMessage"]>
  export type FlaggedMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | FlaggedMessage$contractorArgs<ExtArgs>
    client?: boolean | FlaggedMessage$clientArgs<ExtArgs>
  }
  export type FlaggedMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | FlaggedMessage$contractorArgs<ExtArgs>
    client?: boolean | FlaggedMessage$clientArgs<ExtArgs>
  }
  export type FlaggedMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | FlaggedMessage$contractorArgs<ExtArgs>
    client?: boolean | FlaggedMessage$clientArgs<ExtArgs>
  }

  export type $FlaggedMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlaggedMessage"
    objects: {
      contractor: Prisma.$ContractorPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      messageId: number | null
      messageText: string
      flaggedBy: $Enums.FlaggedByType
      flaggedById: number
      contractorId: number | null
      clientId: number | null
      reason: string
      details: string | null
      status: $Enums.FlagStatus
      reviewedBy: number | null
      reviewedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["flaggedMessage"]>
    composites: {}
  }

  type FlaggedMessageGetPayload<S extends boolean | null | undefined | FlaggedMessageDefaultArgs> = $Result.GetResult<Prisma.$FlaggedMessagePayload, S>

  type FlaggedMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlaggedMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlaggedMessageCountAggregateInputType | true
    }

  export interface FlaggedMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlaggedMessage'], meta: { name: 'FlaggedMessage' } }
    /**
     * Find zero or one FlaggedMessage that matches the filter.
     * @param {FlaggedMessageFindUniqueArgs} args - Arguments to find a FlaggedMessage
     * @example
     * // Get one FlaggedMessage
     * const flaggedMessage = await prisma.flaggedMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlaggedMessageFindUniqueArgs>(args: SelectSubset<T, FlaggedMessageFindUniqueArgs<ExtArgs>>): Prisma__FlaggedMessageClient<$Result.GetResult<Prisma.$FlaggedMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FlaggedMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlaggedMessageFindUniqueOrThrowArgs} args - Arguments to find a FlaggedMessage
     * @example
     * // Get one FlaggedMessage
     * const flaggedMessage = await prisma.flaggedMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlaggedMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, FlaggedMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlaggedMessageClient<$Result.GetResult<Prisma.$FlaggedMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlaggedMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlaggedMessageFindFirstArgs} args - Arguments to find a FlaggedMessage
     * @example
     * // Get one FlaggedMessage
     * const flaggedMessage = await prisma.flaggedMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlaggedMessageFindFirstArgs>(args?: SelectSubset<T, FlaggedMessageFindFirstArgs<ExtArgs>>): Prisma__FlaggedMessageClient<$Result.GetResult<Prisma.$FlaggedMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlaggedMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlaggedMessageFindFirstOrThrowArgs} args - Arguments to find a FlaggedMessage
     * @example
     * // Get one FlaggedMessage
     * const flaggedMessage = await prisma.flaggedMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlaggedMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, FlaggedMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlaggedMessageClient<$Result.GetResult<Prisma.$FlaggedMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FlaggedMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlaggedMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlaggedMessages
     * const flaggedMessages = await prisma.flaggedMessage.findMany()
     * 
     * // Get first 10 FlaggedMessages
     * const flaggedMessages = await prisma.flaggedMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flaggedMessageWithIdOnly = await prisma.flaggedMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlaggedMessageFindManyArgs>(args?: SelectSubset<T, FlaggedMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlaggedMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FlaggedMessage.
     * @param {FlaggedMessageCreateArgs} args - Arguments to create a FlaggedMessage.
     * @example
     * // Create one FlaggedMessage
     * const FlaggedMessage = await prisma.flaggedMessage.create({
     *   data: {
     *     // ... data to create a FlaggedMessage
     *   }
     * })
     * 
     */
    create<T extends FlaggedMessageCreateArgs>(args: SelectSubset<T, FlaggedMessageCreateArgs<ExtArgs>>): Prisma__FlaggedMessageClient<$Result.GetResult<Prisma.$FlaggedMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FlaggedMessages.
     * @param {FlaggedMessageCreateManyArgs} args - Arguments to create many FlaggedMessages.
     * @example
     * // Create many FlaggedMessages
     * const flaggedMessage = await prisma.flaggedMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlaggedMessageCreateManyArgs>(args?: SelectSubset<T, FlaggedMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlaggedMessages and returns the data saved in the database.
     * @param {FlaggedMessageCreateManyAndReturnArgs} args - Arguments to create many FlaggedMessages.
     * @example
     * // Create many FlaggedMessages
     * const flaggedMessage = await prisma.flaggedMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlaggedMessages and only return the `id`
     * const flaggedMessageWithIdOnly = await prisma.flaggedMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlaggedMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, FlaggedMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlaggedMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FlaggedMessage.
     * @param {FlaggedMessageDeleteArgs} args - Arguments to delete one FlaggedMessage.
     * @example
     * // Delete one FlaggedMessage
     * const FlaggedMessage = await prisma.flaggedMessage.delete({
     *   where: {
     *     // ... filter to delete one FlaggedMessage
     *   }
     * })
     * 
     */
    delete<T extends FlaggedMessageDeleteArgs>(args: SelectSubset<T, FlaggedMessageDeleteArgs<ExtArgs>>): Prisma__FlaggedMessageClient<$Result.GetResult<Prisma.$FlaggedMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FlaggedMessage.
     * @param {FlaggedMessageUpdateArgs} args - Arguments to update one FlaggedMessage.
     * @example
     * // Update one FlaggedMessage
     * const flaggedMessage = await prisma.flaggedMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlaggedMessageUpdateArgs>(args: SelectSubset<T, FlaggedMessageUpdateArgs<ExtArgs>>): Prisma__FlaggedMessageClient<$Result.GetResult<Prisma.$FlaggedMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FlaggedMessages.
     * @param {FlaggedMessageDeleteManyArgs} args - Arguments to filter FlaggedMessages to delete.
     * @example
     * // Delete a few FlaggedMessages
     * const { count } = await prisma.flaggedMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlaggedMessageDeleteManyArgs>(args?: SelectSubset<T, FlaggedMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlaggedMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlaggedMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlaggedMessages
     * const flaggedMessage = await prisma.flaggedMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlaggedMessageUpdateManyArgs>(args: SelectSubset<T, FlaggedMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlaggedMessages and returns the data updated in the database.
     * @param {FlaggedMessageUpdateManyAndReturnArgs} args - Arguments to update many FlaggedMessages.
     * @example
     * // Update many FlaggedMessages
     * const flaggedMessage = await prisma.flaggedMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FlaggedMessages and only return the `id`
     * const flaggedMessageWithIdOnly = await prisma.flaggedMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlaggedMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, FlaggedMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlaggedMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FlaggedMessage.
     * @param {FlaggedMessageUpsertArgs} args - Arguments to update or create a FlaggedMessage.
     * @example
     * // Update or create a FlaggedMessage
     * const flaggedMessage = await prisma.flaggedMessage.upsert({
     *   create: {
     *     // ... data to create a FlaggedMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlaggedMessage we want to update
     *   }
     * })
     */
    upsert<T extends FlaggedMessageUpsertArgs>(args: SelectSubset<T, FlaggedMessageUpsertArgs<ExtArgs>>): Prisma__FlaggedMessageClient<$Result.GetResult<Prisma.$FlaggedMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FlaggedMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlaggedMessageCountArgs} args - Arguments to filter FlaggedMessages to count.
     * @example
     * // Count the number of FlaggedMessages
     * const count = await prisma.flaggedMessage.count({
     *   where: {
     *     // ... the filter for the FlaggedMessages we want to count
     *   }
     * })
    **/
    count<T extends FlaggedMessageCountArgs>(
      args?: Subset<T, FlaggedMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlaggedMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlaggedMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlaggedMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlaggedMessageAggregateArgs>(args: Subset<T, FlaggedMessageAggregateArgs>): Prisma.PrismaPromise<GetFlaggedMessageAggregateType<T>>

    /**
     * Group by FlaggedMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlaggedMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlaggedMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlaggedMessageGroupByArgs['orderBy'] }
        : { orderBy?: FlaggedMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlaggedMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlaggedMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlaggedMessage model
   */
  readonly fields: FlaggedMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlaggedMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlaggedMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contractor<T extends FlaggedMessage$contractorArgs<ExtArgs> = {}>(args?: Subset<T, FlaggedMessage$contractorArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends FlaggedMessage$clientArgs<ExtArgs> = {}>(args?: Subset<T, FlaggedMessage$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlaggedMessage model
   */
  interface FlaggedMessageFieldRefs {
    readonly id: FieldRef<"FlaggedMessage", 'Int'>
    readonly messageId: FieldRef<"FlaggedMessage", 'Int'>
    readonly messageText: FieldRef<"FlaggedMessage", 'String'>
    readonly flaggedBy: FieldRef<"FlaggedMessage", 'FlaggedByType'>
    readonly flaggedById: FieldRef<"FlaggedMessage", 'Int'>
    readonly contractorId: FieldRef<"FlaggedMessage", 'Int'>
    readonly clientId: FieldRef<"FlaggedMessage", 'Int'>
    readonly reason: FieldRef<"FlaggedMessage", 'String'>
    readonly details: FieldRef<"FlaggedMessage", 'String'>
    readonly status: FieldRef<"FlaggedMessage", 'FlagStatus'>
    readonly reviewedBy: FieldRef<"FlaggedMessage", 'Int'>
    readonly reviewedAt: FieldRef<"FlaggedMessage", 'DateTime'>
    readonly createdAt: FieldRef<"FlaggedMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlaggedMessage findUnique
   */
  export type FlaggedMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlaggedMessage
     */
    select?: FlaggedMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlaggedMessage
     */
    omit?: FlaggedMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlaggedMessageInclude<ExtArgs> | null
    /**
     * Filter, which FlaggedMessage to fetch.
     */
    where: FlaggedMessageWhereUniqueInput
  }

  /**
   * FlaggedMessage findUniqueOrThrow
   */
  export type FlaggedMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlaggedMessage
     */
    select?: FlaggedMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlaggedMessage
     */
    omit?: FlaggedMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlaggedMessageInclude<ExtArgs> | null
    /**
     * Filter, which FlaggedMessage to fetch.
     */
    where: FlaggedMessageWhereUniqueInput
  }

  /**
   * FlaggedMessage findFirst
   */
  export type FlaggedMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlaggedMessage
     */
    select?: FlaggedMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlaggedMessage
     */
    omit?: FlaggedMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlaggedMessageInclude<ExtArgs> | null
    /**
     * Filter, which FlaggedMessage to fetch.
     */
    where?: FlaggedMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlaggedMessages to fetch.
     */
    orderBy?: FlaggedMessageOrderByWithRelationInput | FlaggedMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlaggedMessages.
     */
    cursor?: FlaggedMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlaggedMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlaggedMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlaggedMessages.
     */
    distinct?: FlaggedMessageScalarFieldEnum | FlaggedMessageScalarFieldEnum[]
  }

  /**
   * FlaggedMessage findFirstOrThrow
   */
  export type FlaggedMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlaggedMessage
     */
    select?: FlaggedMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlaggedMessage
     */
    omit?: FlaggedMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlaggedMessageInclude<ExtArgs> | null
    /**
     * Filter, which FlaggedMessage to fetch.
     */
    where?: FlaggedMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlaggedMessages to fetch.
     */
    orderBy?: FlaggedMessageOrderByWithRelationInput | FlaggedMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlaggedMessages.
     */
    cursor?: FlaggedMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlaggedMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlaggedMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlaggedMessages.
     */
    distinct?: FlaggedMessageScalarFieldEnum | FlaggedMessageScalarFieldEnum[]
  }

  /**
   * FlaggedMessage findMany
   */
  export type FlaggedMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlaggedMessage
     */
    select?: FlaggedMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlaggedMessage
     */
    omit?: FlaggedMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlaggedMessageInclude<ExtArgs> | null
    /**
     * Filter, which FlaggedMessages to fetch.
     */
    where?: FlaggedMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlaggedMessages to fetch.
     */
    orderBy?: FlaggedMessageOrderByWithRelationInput | FlaggedMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlaggedMessages.
     */
    cursor?: FlaggedMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlaggedMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlaggedMessages.
     */
    skip?: number
    distinct?: FlaggedMessageScalarFieldEnum | FlaggedMessageScalarFieldEnum[]
  }

  /**
   * FlaggedMessage create
   */
  export type FlaggedMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlaggedMessage
     */
    select?: FlaggedMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlaggedMessage
     */
    omit?: FlaggedMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlaggedMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a FlaggedMessage.
     */
    data: XOR<FlaggedMessageCreateInput, FlaggedMessageUncheckedCreateInput>
  }

  /**
   * FlaggedMessage createMany
   */
  export type FlaggedMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlaggedMessages.
     */
    data: FlaggedMessageCreateManyInput | FlaggedMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlaggedMessage createManyAndReturn
   */
  export type FlaggedMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlaggedMessage
     */
    select?: FlaggedMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlaggedMessage
     */
    omit?: FlaggedMessageOmit<ExtArgs> | null
    /**
     * The data used to create many FlaggedMessages.
     */
    data: FlaggedMessageCreateManyInput | FlaggedMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlaggedMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlaggedMessage update
   */
  export type FlaggedMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlaggedMessage
     */
    select?: FlaggedMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlaggedMessage
     */
    omit?: FlaggedMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlaggedMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a FlaggedMessage.
     */
    data: XOR<FlaggedMessageUpdateInput, FlaggedMessageUncheckedUpdateInput>
    /**
     * Choose, which FlaggedMessage to update.
     */
    where: FlaggedMessageWhereUniqueInput
  }

  /**
   * FlaggedMessage updateMany
   */
  export type FlaggedMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlaggedMessages.
     */
    data: XOR<FlaggedMessageUpdateManyMutationInput, FlaggedMessageUncheckedUpdateManyInput>
    /**
     * Filter which FlaggedMessages to update
     */
    where?: FlaggedMessageWhereInput
    /**
     * Limit how many FlaggedMessages to update.
     */
    limit?: number
  }

  /**
   * FlaggedMessage updateManyAndReturn
   */
  export type FlaggedMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlaggedMessage
     */
    select?: FlaggedMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlaggedMessage
     */
    omit?: FlaggedMessageOmit<ExtArgs> | null
    /**
     * The data used to update FlaggedMessages.
     */
    data: XOR<FlaggedMessageUpdateManyMutationInput, FlaggedMessageUncheckedUpdateManyInput>
    /**
     * Filter which FlaggedMessages to update
     */
    where?: FlaggedMessageWhereInput
    /**
     * Limit how many FlaggedMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlaggedMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlaggedMessage upsert
   */
  export type FlaggedMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlaggedMessage
     */
    select?: FlaggedMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlaggedMessage
     */
    omit?: FlaggedMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlaggedMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the FlaggedMessage to update in case it exists.
     */
    where: FlaggedMessageWhereUniqueInput
    /**
     * In case the FlaggedMessage found by the `where` argument doesn't exist, create a new FlaggedMessage with this data.
     */
    create: XOR<FlaggedMessageCreateInput, FlaggedMessageUncheckedCreateInput>
    /**
     * In case the FlaggedMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlaggedMessageUpdateInput, FlaggedMessageUncheckedUpdateInput>
  }

  /**
   * FlaggedMessage delete
   */
  export type FlaggedMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlaggedMessage
     */
    select?: FlaggedMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlaggedMessage
     */
    omit?: FlaggedMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlaggedMessageInclude<ExtArgs> | null
    /**
     * Filter which FlaggedMessage to delete.
     */
    where: FlaggedMessageWhereUniqueInput
  }

  /**
   * FlaggedMessage deleteMany
   */
  export type FlaggedMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlaggedMessages to delete
     */
    where?: FlaggedMessageWhereInput
    /**
     * Limit how many FlaggedMessages to delete.
     */
    limit?: number
  }

  /**
   * FlaggedMessage.contractor
   */
  export type FlaggedMessage$contractorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contractor
     */
    select?: ContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contractor
     */
    omit?: ContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorInclude<ExtArgs> | null
    where?: ContractorWhereInput
  }

  /**
   * FlaggedMessage.client
   */
  export type FlaggedMessage$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * FlaggedMessage without action
   */
  export type FlaggedMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlaggedMessage
     */
    select?: FlaggedMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlaggedMessage
     */
    omit?: FlaggedMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlaggedMessageInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    id: number | null
    reporterId: number | null
    reportedUserId: number | null
    bookingId: number | null
    assignedTo: number | null
  }

  export type ReportSumAggregateOutputType = {
    id: number | null
    reporterId: number | null
    reportedUserId: number | null
    bookingId: number | null
    assignedTo: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: number | null
    type: $Enums.ReportType | null
    reporterType: $Enums.ReporterType | null
    reporterId: number | null
    reportedUserId: number | null
    reportedUserType: $Enums.ReporterType | null
    bookingId: number | null
    reason: string | null
    description: string | null
    evidence: string | null
    status: $Enums.ReportStatus | null
    priority: $Enums.ReportPriority | null
    assignedTo: number | null
    resolution: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: number | null
    type: $Enums.ReportType | null
    reporterType: $Enums.ReporterType | null
    reporterId: number | null
    reportedUserId: number | null
    reportedUserType: $Enums.ReporterType | null
    bookingId: number | null
    reason: string | null
    description: string | null
    evidence: string | null
    status: $Enums.ReportStatus | null
    priority: $Enums.ReportPriority | null
    assignedTo: number | null
    resolution: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    type: number
    reporterType: number
    reporterId: number
    reportedUserId: number
    reportedUserType: number
    bookingId: number
    reason: number
    description: number
    evidence: number
    status: number
    priority: number
    assignedTo: number
    resolution: number
    resolvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    id?: true
    reporterId?: true
    reportedUserId?: true
    bookingId?: true
    assignedTo?: true
  }

  export type ReportSumAggregateInputType = {
    id?: true
    reporterId?: true
    reportedUserId?: true
    bookingId?: true
    assignedTo?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    type?: true
    reporterType?: true
    reporterId?: true
    reportedUserId?: true
    reportedUserType?: true
    bookingId?: true
    reason?: true
    description?: true
    evidence?: true
    status?: true
    priority?: true
    assignedTo?: true
    resolution?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    type?: true
    reporterType?: true
    reporterId?: true
    reportedUserId?: true
    reportedUserType?: true
    bookingId?: true
    reason?: true
    description?: true
    evidence?: true
    status?: true
    priority?: true
    assignedTo?: true
    resolution?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    type?: true
    reporterType?: true
    reporterId?: true
    reportedUserId?: true
    reportedUserType?: true
    bookingId?: true
    reason?: true
    description?: true
    evidence?: true
    status?: true
    priority?: true
    assignedTo?: true
    resolution?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: number
    type: $Enums.ReportType
    reporterType: $Enums.ReporterType
    reporterId: number
    reportedUserId: number | null
    reportedUserType: $Enums.ReporterType | null
    bookingId: number | null
    reason: string
    description: string
    evidence: string | null
    status: $Enums.ReportStatus
    priority: $Enums.ReportPriority
    assignedTo: number | null
    resolution: string | null
    resolvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    reporterType?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    reportedUserType?: boolean
    bookingId?: boolean
    reason?: boolean
    description?: boolean
    evidence?: boolean
    status?: boolean
    priority?: boolean
    assignedTo?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | Report$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    reporterType?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    reportedUserType?: boolean
    bookingId?: boolean
    reason?: boolean
    description?: boolean
    evidence?: boolean
    status?: boolean
    priority?: boolean
    assignedTo?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | Report$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    reporterType?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    reportedUserType?: boolean
    bookingId?: boolean
    reason?: boolean
    description?: boolean
    evidence?: boolean
    status?: boolean
    priority?: boolean
    assignedTo?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | Report$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    type?: boolean
    reporterType?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    reportedUserType?: boolean
    bookingId?: boolean
    reason?: boolean
    description?: boolean
    evidence?: boolean
    status?: boolean
    priority?: boolean
    assignedTo?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "reporterType" | "reporterId" | "reportedUserId" | "reportedUserType" | "bookingId" | "reason" | "description" | "evidence" | "status" | "priority" | "assignedTo" | "resolution" | "resolvedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | Report$bookingArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | Report$bookingArgs<ExtArgs>
  }
  export type ReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | Report$bookingArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.ReportType
      reporterType: $Enums.ReporterType
      reporterId: number
      reportedUserId: number | null
      reportedUserType: $Enums.ReporterType | null
      bookingId: number | null
      reason: string
      description: string
      evidence: string | null
      status: $Enums.ReportStatus
      priority: $Enums.ReportPriority
      assignedTo: number | null
      resolution: string | null
      resolvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends Report$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Report$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'Int'>
    readonly type: FieldRef<"Report", 'ReportType'>
    readonly reporterType: FieldRef<"Report", 'ReporterType'>
    readonly reporterId: FieldRef<"Report", 'Int'>
    readonly reportedUserId: FieldRef<"Report", 'Int'>
    readonly reportedUserType: FieldRef<"Report", 'ReporterType'>
    readonly bookingId: FieldRef<"Report", 'Int'>
    readonly reason: FieldRef<"Report", 'String'>
    readonly description: FieldRef<"Report", 'String'>
    readonly evidence: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'ReportStatus'>
    readonly priority: FieldRef<"Report", 'ReportPriority'>
    readonly assignedTo: FieldRef<"Report", 'Int'>
    readonly resolution: FieldRef<"Report", 'String'>
    readonly resolvedAt: FieldRef<"Report", 'DateTime'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report.booking
   */
  export type Report$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number | null
    contractorId: number | null
    clientId: number | null
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    id: number | null
    contractorId: number | null
    clientId: number | null
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: number | null
    contractorId: number | null
    clientId: number | null
    rating: number | null
    reviewText: string | null
    createdAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: number | null
    contractorId: number | null
    clientId: number | null
    rating: number | null
    reviewText: string | null
    createdAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    contractorId: number
    clientId: number
    rating: number
    reviewText: number
    createdAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
    rating?: true
    reviewText?: true
    createdAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
    rating?: true
    reviewText?: true
    createdAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    contractorId?: true
    clientId?: true
    rating?: true
    reviewText?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: number
    contractorId: number
    clientId: number
    rating: number
    reviewText: string | null
    createdAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    clientId?: boolean
    rating?: boolean
    reviewText?: boolean
    createdAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    clientId?: boolean
    rating?: boolean
    reviewText?: boolean
    createdAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    clientId?: boolean
    rating?: boolean
    reviewText?: boolean
    createdAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    contractorId?: boolean
    clientId?: boolean
    rating?: boolean
    reviewText?: boolean
    createdAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractorId" | "clientId" | "rating" | "reviewText" | "createdAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      contractor: Prisma.$ContractorPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contractorId: number
      clientId: number
      rating: number
      reviewText: string | null
      createdAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contractor<T extends ContractorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractorDefaultArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'Int'>
    readonly contractorId: FieldRef<"Review", 'Int'>
    readonly clientId: FieldRef<"Review", 'Int'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly reviewText: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: number | null
    taxAmount: number | null
    totalAmount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: number | null
    taxAmount: number | null
    totalAmount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: number | null
    taxAmount: number | null
    totalAmount: number | null
    status: $Enums.InvoiceStatus | null
    dueDate: Date | null
    paidAt: Date | null
    stripePaymentIntentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: number | null
    taxAmount: number | null
    totalAmount: number | null
    status: $Enums.InvoiceStatus | null
    dueDate: Date | null
    paidAt: Date | null
    stripePaymentIntentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    bookingId: number
    amount: number
    taxAmount: number
    totalAmount: number
    status: number
    dueDate: number
    paidAt: number
    stripePaymentIntentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    taxAmount?: true
    totalAmount?: true
    status?: true
    dueDate?: true
    paidAt?: true
    stripePaymentIntentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    taxAmount?: true
    totalAmount?: true
    status?: true
    dueDate?: true
    paidAt?: true
    stripePaymentIntentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    taxAmount?: true
    totalAmount?: true
    status?: true
    dueDate?: true
    paidAt?: true
    stripePaymentIntentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: number
    bookingId: number
    amount: number
    taxAmount: number | null
    totalAmount: number
    status: $Enums.InvoiceStatus
    dueDate: Date | null
    paidAt: Date | null
    stripePaymentIntentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    status?: boolean
    dueDate?: boolean
    paidAt?: boolean
    stripePaymentIntentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    status?: boolean
    dueDate?: boolean
    paidAt?: boolean
    stripePaymentIntentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    status?: boolean
    dueDate?: boolean
    paidAt?: boolean
    stripePaymentIntentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    status?: boolean
    dueDate?: boolean
    paidAt?: boolean
    stripePaymentIntentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "amount" | "taxAmount" | "totalAmount" | "status" | "dueDate" | "paidAt" | "stripePaymentIntentId" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      amount: number
      taxAmount: number | null
      totalAmount: number
      status: $Enums.InvoiceStatus
      dueDate: Date | null
      paidAt: Date | null
      stripePaymentIntentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'Int'>
    readonly bookingId: FieldRef<"Invoice", 'Int'>
    readonly amount: FieldRef<"Invoice", 'Float'>
    readonly taxAmount: FieldRef<"Invoice", 'Float'>
    readonly totalAmount: FieldRef<"Invoice", 'Float'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly stripePaymentIntentId: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    invoiceId: number | null
    amount: number | null
    platformFee: number | null
    contractorPayout: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    invoiceId: number | null
    amount: number | null
    platformFee: number | null
    contractorPayout: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    invoiceId: number | null
    amount: number | null
    paymentMethod: string | null
    stripePaymentId: string | null
    stripePaymentIntent: string | null
    platformFee: number | null
    contractorPayout: number | null
    stripeTransferId: string | null
    status: $Enums.PaymentStatus | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    invoiceId: number | null
    amount: number | null
    paymentMethod: string | null
    stripePaymentId: string | null
    stripePaymentIntent: string | null
    platformFee: number | null
    contractorPayout: number | null
    stripeTransferId: string | null
    status: $Enums.PaymentStatus | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    bookingId: number
    invoiceId: number
    amount: number
    paymentMethod: number
    stripePaymentId: number
    stripePaymentIntent: number
    platformFee: number
    contractorPayout: number
    stripeTransferId: number
    status: number
    paidAt: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    bookingId?: true
    invoiceId?: true
    amount?: true
    platformFee?: true
    contractorPayout?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    bookingId?: true
    invoiceId?: true
    amount?: true
    platformFee?: true
    contractorPayout?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    bookingId?: true
    invoiceId?: true
    amount?: true
    paymentMethod?: true
    stripePaymentId?: true
    stripePaymentIntent?: true
    platformFee?: true
    contractorPayout?: true
    stripeTransferId?: true
    status?: true
    paidAt?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    invoiceId?: true
    amount?: true
    paymentMethod?: true
    stripePaymentId?: true
    stripePaymentIntent?: true
    platformFee?: true
    contractorPayout?: true
    stripeTransferId?: true
    status?: true
    paidAt?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    bookingId?: true
    invoiceId?: true
    amount?: true
    paymentMethod?: true
    stripePaymentId?: true
    stripePaymentIntent?: true
    platformFee?: true
    contractorPayout?: true
    stripeTransferId?: true
    status?: true
    paidAt?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    bookingId: number
    invoiceId: number | null
    amount: number
    paymentMethod: string
    stripePaymentId: string | null
    stripePaymentIntent: string | null
    platformFee: number | null
    contractorPayout: number | null
    stripeTransferId: string | null
    status: $Enums.PaymentStatus
    paidAt: Date | null
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    stripePaymentId?: boolean
    stripePaymentIntent?: boolean
    platformFee?: boolean
    contractorPayout?: boolean
    stripeTransferId?: boolean
    status?: boolean
    paidAt?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    stripePaymentId?: boolean
    stripePaymentIntent?: boolean
    platformFee?: boolean
    contractorPayout?: boolean
    stripeTransferId?: boolean
    status?: boolean
    paidAt?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    stripePaymentId?: boolean
    stripePaymentIntent?: boolean
    platformFee?: boolean
    contractorPayout?: boolean
    stripeTransferId?: boolean
    status?: boolean
    paidAt?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    stripePaymentId?: boolean
    stripePaymentIntent?: boolean
    platformFee?: boolean
    contractorPayout?: boolean
    stripeTransferId?: boolean
    status?: boolean
    paidAt?: boolean
    createdAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "invoiceId" | "amount" | "paymentMethod" | "stripePaymentId" | "stripePaymentIntent" | "platformFee" | "contractorPayout" | "stripeTransferId" | "status" | "paidAt" | "createdAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      invoiceId: number | null
      amount: number
      paymentMethod: string
      stripePaymentId: string | null
      stripePaymentIntent: string | null
      platformFee: number | null
      contractorPayout: number | null
      stripeTransferId: string | null
      status: $Enums.PaymentStatus
      paidAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends Payment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Payment$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly bookingId: FieldRef<"Payment", 'Int'>
    readonly invoiceId: FieldRef<"Payment", 'Int'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly stripePaymentId: FieldRef<"Payment", 'String'>
    readonly stripePaymentIntent: FieldRef<"Payment", 'String'>
    readonly platformFee: FieldRef<"Payment", 'Float'>
    readonly contractorPayout: FieldRef<"Payment", 'Float'>
    readonly stripeTransferId: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.invoice
   */
  export type Payment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Availability
   */

  export type AggregateAvailability = {
    _count: AvailabilityCountAggregateOutputType | null
    _avg: AvailabilityAvgAggregateOutputType | null
    _sum: AvailabilitySumAggregateOutputType | null
    _min: AvailabilityMinAggregateOutputType | null
    _max: AvailabilityMaxAggregateOutputType | null
  }

  export type AvailabilityAvgAggregateOutputType = {
    id: number | null
    contractorId: number | null
    dayOfWeek: number | null
    maxBookings: number | null
  }

  export type AvailabilitySumAggregateOutputType = {
    id: number | null
    contractorId: number | null
    dayOfWeek: number | null
    maxBookings: number | null
  }

  export type AvailabilityMinAggregateOutputType = {
    id: number | null
    contractorId: number | null
    dayOfWeek: number | null
    specificDate: Date | null
    startTime: string | null
    endTime: string | null
    maxBookings: number | null
    isAvailable: boolean | null
    isRecurring: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvailabilityMaxAggregateOutputType = {
    id: number | null
    contractorId: number | null
    dayOfWeek: number | null
    specificDate: Date | null
    startTime: string | null
    endTime: string | null
    maxBookings: number | null
    isAvailable: boolean | null
    isRecurring: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvailabilityCountAggregateOutputType = {
    id: number
    contractorId: number
    dayOfWeek: number
    specificDate: number
    startTime: number
    endTime: number
    maxBookings: number
    isAvailable: number
    isRecurring: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AvailabilityAvgAggregateInputType = {
    id?: true
    contractorId?: true
    dayOfWeek?: true
    maxBookings?: true
  }

  export type AvailabilitySumAggregateInputType = {
    id?: true
    contractorId?: true
    dayOfWeek?: true
    maxBookings?: true
  }

  export type AvailabilityMinAggregateInputType = {
    id?: true
    contractorId?: true
    dayOfWeek?: true
    specificDate?: true
    startTime?: true
    endTime?: true
    maxBookings?: true
    isAvailable?: true
    isRecurring?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvailabilityMaxAggregateInputType = {
    id?: true
    contractorId?: true
    dayOfWeek?: true
    specificDate?: true
    startTime?: true
    endTime?: true
    maxBookings?: true
    isAvailable?: true
    isRecurring?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvailabilityCountAggregateInputType = {
    id?: true
    contractorId?: true
    dayOfWeek?: true
    specificDate?: true
    startTime?: true
    endTime?: true
    maxBookings?: true
    isAvailable?: true
    isRecurring?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Availability to aggregate.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Availabilities
    **/
    _count?: true | AvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvailabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvailabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvailabilityMaxAggregateInputType
  }

  export type GetAvailabilityAggregateType<T extends AvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvailability[P]>
      : GetScalarType<T[P], AggregateAvailability[P]>
  }




  export type AvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithAggregationInput | AvailabilityOrderByWithAggregationInput[]
    by: AvailabilityScalarFieldEnum[] | AvailabilityScalarFieldEnum
    having?: AvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvailabilityCountAggregateInputType | true
    _avg?: AvailabilityAvgAggregateInputType
    _sum?: AvailabilitySumAggregateInputType
    _min?: AvailabilityMinAggregateInputType
    _max?: AvailabilityMaxAggregateInputType
  }

  export type AvailabilityGroupByOutputType = {
    id: number
    contractorId: number
    dayOfWeek: number | null
    specificDate: Date | null
    startTime: string
    endTime: string
    maxBookings: number
    isAvailable: boolean
    isRecurring: boolean
    createdAt: Date
    updatedAt: Date
    _count: AvailabilityCountAggregateOutputType | null
    _avg: AvailabilityAvgAggregateOutputType | null
    _sum: AvailabilitySumAggregateOutputType | null
    _min: AvailabilityMinAggregateOutputType | null
    _max: AvailabilityMaxAggregateOutputType | null
  }

  type GetAvailabilityGroupByPayload<T extends AvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], AvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type AvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    dayOfWeek?: boolean
    specificDate?: boolean
    startTime?: boolean
    endTime?: boolean
    maxBookings?: boolean
    isAvailable?: boolean
    isRecurring?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    dayOfWeek?: boolean
    specificDate?: boolean
    startTime?: boolean
    endTime?: boolean
    maxBookings?: boolean
    isAvailable?: boolean
    isRecurring?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    dayOfWeek?: boolean
    specificDate?: boolean
    startTime?: boolean
    endTime?: boolean
    maxBookings?: boolean
    isAvailable?: boolean
    isRecurring?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectScalar = {
    id?: boolean
    contractorId?: boolean
    dayOfWeek?: boolean
    specificDate?: boolean
    startTime?: boolean
    endTime?: boolean
    maxBookings?: boolean
    isAvailable?: boolean
    isRecurring?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AvailabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractorId" | "dayOfWeek" | "specificDate" | "startTime" | "endTime" | "maxBookings" | "isAvailable" | "isRecurring" | "createdAt" | "updatedAt", ExtArgs["result"]["availability"]>
  export type AvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }
  export type AvailabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }
  export type AvailabilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }

  export type $AvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Availability"
    objects: {
      contractor: Prisma.$ContractorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contractorId: number
      dayOfWeek: number | null
      specificDate: Date | null
      startTime: string
      endTime: string
      maxBookings: number
      isAvailable: boolean
      isRecurring: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["availability"]>
    composites: {}
  }

  type AvailabilityGetPayload<S extends boolean | null | undefined | AvailabilityDefaultArgs> = $Result.GetResult<Prisma.$AvailabilityPayload, S>

  type AvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvailabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvailabilityCountAggregateInputType | true
    }

  export interface AvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Availability'], meta: { name: 'Availability' } }
    /**
     * Find zero or one Availability that matches the filter.
     * @param {AvailabilityFindUniqueArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvailabilityFindUniqueArgs>(args: SelectSubset<T, AvailabilityFindUniqueArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Availability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvailabilityFindUniqueOrThrowArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, AvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Availability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindFirstArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvailabilityFindFirstArgs>(args?: SelectSubset<T, AvailabilityFindFirstArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Availability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindFirstOrThrowArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, AvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Availabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Availabilities
     * const availabilities = await prisma.availability.findMany()
     * 
     * // Get first 10 Availabilities
     * const availabilities = await prisma.availability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const availabilityWithIdOnly = await prisma.availability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvailabilityFindManyArgs>(args?: SelectSubset<T, AvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Availability.
     * @param {AvailabilityCreateArgs} args - Arguments to create a Availability.
     * @example
     * // Create one Availability
     * const Availability = await prisma.availability.create({
     *   data: {
     *     // ... data to create a Availability
     *   }
     * })
     * 
     */
    create<T extends AvailabilityCreateArgs>(args: SelectSubset<T, AvailabilityCreateArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Availabilities.
     * @param {AvailabilityCreateManyArgs} args - Arguments to create many Availabilities.
     * @example
     * // Create many Availabilities
     * const availability = await prisma.availability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvailabilityCreateManyArgs>(args?: SelectSubset<T, AvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Availabilities and returns the data saved in the database.
     * @param {AvailabilityCreateManyAndReturnArgs} args - Arguments to create many Availabilities.
     * @example
     * // Create many Availabilities
     * const availability = await prisma.availability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Availabilities and only return the `id`
     * const availabilityWithIdOnly = await prisma.availability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvailabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, AvailabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Availability.
     * @param {AvailabilityDeleteArgs} args - Arguments to delete one Availability.
     * @example
     * // Delete one Availability
     * const Availability = await prisma.availability.delete({
     *   where: {
     *     // ... filter to delete one Availability
     *   }
     * })
     * 
     */
    delete<T extends AvailabilityDeleteArgs>(args: SelectSubset<T, AvailabilityDeleteArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Availability.
     * @param {AvailabilityUpdateArgs} args - Arguments to update one Availability.
     * @example
     * // Update one Availability
     * const availability = await prisma.availability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvailabilityUpdateArgs>(args: SelectSubset<T, AvailabilityUpdateArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Availabilities.
     * @param {AvailabilityDeleteManyArgs} args - Arguments to filter Availabilities to delete.
     * @example
     * // Delete a few Availabilities
     * const { count } = await prisma.availability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvailabilityDeleteManyArgs>(args?: SelectSubset<T, AvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Availabilities
     * const availability = await prisma.availability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvailabilityUpdateManyArgs>(args: SelectSubset<T, AvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Availabilities and returns the data updated in the database.
     * @param {AvailabilityUpdateManyAndReturnArgs} args - Arguments to update many Availabilities.
     * @example
     * // Update many Availabilities
     * const availability = await prisma.availability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Availabilities and only return the `id`
     * const availabilityWithIdOnly = await prisma.availability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AvailabilityUpdateManyAndReturnArgs>(args: SelectSubset<T, AvailabilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Availability.
     * @param {AvailabilityUpsertArgs} args - Arguments to update or create a Availability.
     * @example
     * // Update or create a Availability
     * const availability = await prisma.availability.upsert({
     *   create: {
     *     // ... data to create a Availability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Availability we want to update
     *   }
     * })
     */
    upsert<T extends AvailabilityUpsertArgs>(args: SelectSubset<T, AvailabilityUpsertArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityCountArgs} args - Arguments to filter Availabilities to count.
     * @example
     * // Count the number of Availabilities
     * const count = await prisma.availability.count({
     *   where: {
     *     // ... the filter for the Availabilities we want to count
     *   }
     * })
    **/
    count<T extends AvailabilityCountArgs>(
      args?: Subset<T, AvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvailabilityAggregateArgs>(args: Subset<T, AvailabilityAggregateArgs>): Prisma.PrismaPromise<GetAvailabilityAggregateType<T>>

    /**
     * Group by Availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: AvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Availability model
   */
  readonly fields: AvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Availability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contractor<T extends ContractorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractorDefaultArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Availability model
   */
  interface AvailabilityFieldRefs {
    readonly id: FieldRef<"Availability", 'Int'>
    readonly contractorId: FieldRef<"Availability", 'Int'>
    readonly dayOfWeek: FieldRef<"Availability", 'Int'>
    readonly specificDate: FieldRef<"Availability", 'DateTime'>
    readonly startTime: FieldRef<"Availability", 'String'>
    readonly endTime: FieldRef<"Availability", 'String'>
    readonly maxBookings: FieldRef<"Availability", 'Int'>
    readonly isAvailable: FieldRef<"Availability", 'Boolean'>
    readonly isRecurring: FieldRef<"Availability", 'Boolean'>
    readonly createdAt: FieldRef<"Availability", 'DateTime'>
    readonly updatedAt: FieldRef<"Availability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Availability findUnique
   */
  export type AvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability findUniqueOrThrow
   */
  export type AvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability findFirst
   */
  export type AvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Availabilities.
     */
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability findFirstOrThrow
   */
  export type AvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Availabilities.
     */
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability findMany
   */
  export type AvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availabilities to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability create
   */
  export type AvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Availability.
     */
    data: XOR<AvailabilityCreateInput, AvailabilityUncheckedCreateInput>
  }

  /**
   * Availability createMany
   */
  export type AvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Availabilities.
     */
    data: AvailabilityCreateManyInput | AvailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Availability createManyAndReturn
   */
  export type AvailabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * The data used to create many Availabilities.
     */
    data: AvailabilityCreateManyInput | AvailabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Availability update
   */
  export type AvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Availability.
     */
    data: XOR<AvailabilityUpdateInput, AvailabilityUncheckedUpdateInput>
    /**
     * Choose, which Availability to update.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability updateMany
   */
  export type AvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Availabilities.
     */
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which Availabilities to update
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to update.
     */
    limit?: number
  }

  /**
   * Availability updateManyAndReturn
   */
  export type AvailabilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * The data used to update Availabilities.
     */
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which Availabilities to update
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Availability upsert
   */
  export type AvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Availability to update in case it exists.
     */
    where: AvailabilityWhereUniqueInput
    /**
     * In case the Availability found by the `where` argument doesn't exist, create a new Availability with this data.
     */
    create: XOR<AvailabilityCreateInput, AvailabilityUncheckedCreateInput>
    /**
     * In case the Availability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvailabilityUpdateInput, AvailabilityUncheckedUpdateInput>
  }

  /**
   * Availability delete
   */
  export type AvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter which Availability to delete.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability deleteMany
   */
  export type AvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Availabilities to delete
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to delete.
     */
    limit?: number
  }

  /**
   * Availability without action
   */
  export type AvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
  }


  /**
   * Model TimeSlot
   */

  export type AggregateTimeSlot = {
    _count: TimeSlotCountAggregateOutputType | null
    _avg: TimeSlotAvgAggregateOutputType | null
    _sum: TimeSlotSumAggregateOutputType | null
    _min: TimeSlotMinAggregateOutputType | null
    _max: TimeSlotMaxAggregateOutputType | null
  }

  export type TimeSlotAvgAggregateOutputType = {
    id: number | null
    contractorId: number | null
    bookingId: number | null
  }

  export type TimeSlotSumAggregateOutputType = {
    id: number | null
    contractorId: number | null
    bookingId: number | null
  }

  export type TimeSlotMinAggregateOutputType = {
    id: number | null
    contractorId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    slotType: $Enums.SlotType | null
    bookingId: number | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeSlotMaxAggregateOutputType = {
    id: number | null
    contractorId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    slotType: $Enums.SlotType | null
    bookingId: number | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeSlotCountAggregateOutputType = {
    id: number
    contractorId: number
    date: number
    startTime: number
    endTime: number
    slotType: number
    bookingId: number
    reason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimeSlotAvgAggregateInputType = {
    id?: true
    contractorId?: true
    bookingId?: true
  }

  export type TimeSlotSumAggregateInputType = {
    id?: true
    contractorId?: true
    bookingId?: true
  }

  export type TimeSlotMinAggregateInputType = {
    id?: true
    contractorId?: true
    date?: true
    startTime?: true
    endTime?: true
    slotType?: true
    bookingId?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeSlotMaxAggregateInputType = {
    id?: true
    contractorId?: true
    date?: true
    startTime?: true
    endTime?: true
    slotType?: true
    bookingId?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeSlotCountAggregateInputType = {
    id?: true
    contractorId?: true
    date?: true
    startTime?: true
    endTime?: true
    slotType?: true
    bookingId?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimeSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSlot to aggregate.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeSlots
    **/
    _count?: true | TimeSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeSlotMaxAggregateInputType
  }

  export type GetTimeSlotAggregateType<T extends TimeSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeSlot[P]>
      : GetScalarType<T[P], AggregateTimeSlot[P]>
  }




  export type TimeSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSlotWhereInput
    orderBy?: TimeSlotOrderByWithAggregationInput | TimeSlotOrderByWithAggregationInput[]
    by: TimeSlotScalarFieldEnum[] | TimeSlotScalarFieldEnum
    having?: TimeSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeSlotCountAggregateInputType | true
    _avg?: TimeSlotAvgAggregateInputType
    _sum?: TimeSlotSumAggregateInputType
    _min?: TimeSlotMinAggregateInputType
    _max?: TimeSlotMaxAggregateInputType
  }

  export type TimeSlotGroupByOutputType = {
    id: number
    contractorId: number
    date: Date
    startTime: string
    endTime: string
    slotType: $Enums.SlotType
    bookingId: number | null
    reason: string | null
    createdAt: Date
    updatedAt: Date
    _count: TimeSlotCountAggregateOutputType | null
    _avg: TimeSlotAvgAggregateOutputType | null
    _sum: TimeSlotSumAggregateOutputType | null
    _min: TimeSlotMinAggregateOutputType | null
    _max: TimeSlotMaxAggregateOutputType | null
  }

  type GetTimeSlotGroupByPayload<T extends TimeSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeSlotGroupByOutputType[P]>
            : GetScalarType<T[P], TimeSlotGroupByOutputType[P]>
        }
      >
    >


  export type TimeSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    slotType?: boolean
    bookingId?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlot"]>

  export type TimeSlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    slotType?: boolean
    bookingId?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlot"]>

  export type TimeSlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    slotType?: boolean
    bookingId?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlot"]>

  export type TimeSlotSelectScalar = {
    id?: boolean
    contractorId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    slotType?: boolean
    bookingId?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimeSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractorId" | "date" | "startTime" | "endTime" | "slotType" | "bookingId" | "reason" | "createdAt" | "updatedAt", ExtArgs["result"]["timeSlot"]>
  export type TimeSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }
  export type TimeSlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }
  export type TimeSlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }

  export type $TimeSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeSlot"
    objects: {
      contractor: Prisma.$ContractorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contractorId: number
      date: Date
      startTime: string
      endTime: string
      slotType: $Enums.SlotType
      bookingId: number | null
      reason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timeSlot"]>
    composites: {}
  }

  type TimeSlotGetPayload<S extends boolean | null | undefined | TimeSlotDefaultArgs> = $Result.GetResult<Prisma.$TimeSlotPayload, S>

  type TimeSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimeSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeSlotCountAggregateInputType | true
    }

  export interface TimeSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeSlot'], meta: { name: 'TimeSlot' } }
    /**
     * Find zero or one TimeSlot that matches the filter.
     * @param {TimeSlotFindUniqueArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeSlotFindUniqueArgs>(args: SelectSubset<T, TimeSlotFindUniqueArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimeSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimeSlotFindUniqueOrThrowArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindFirstArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeSlotFindFirstArgs>(args?: SelectSubset<T, TimeSlotFindFirstArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindFirstOrThrowArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimeSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeSlots
     * const timeSlots = await prisma.timeSlot.findMany()
     * 
     * // Get first 10 TimeSlots
     * const timeSlots = await prisma.timeSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeSlotWithIdOnly = await prisma.timeSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeSlotFindManyArgs>(args?: SelectSubset<T, TimeSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimeSlot.
     * @param {TimeSlotCreateArgs} args - Arguments to create a TimeSlot.
     * @example
     * // Create one TimeSlot
     * const TimeSlot = await prisma.timeSlot.create({
     *   data: {
     *     // ... data to create a TimeSlot
     *   }
     * })
     * 
     */
    create<T extends TimeSlotCreateArgs>(args: SelectSubset<T, TimeSlotCreateArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimeSlots.
     * @param {TimeSlotCreateManyArgs} args - Arguments to create many TimeSlots.
     * @example
     * // Create many TimeSlots
     * const timeSlot = await prisma.timeSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeSlotCreateManyArgs>(args?: SelectSubset<T, TimeSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeSlots and returns the data saved in the database.
     * @param {TimeSlotCreateManyAndReturnArgs} args - Arguments to create many TimeSlots.
     * @example
     * // Create many TimeSlots
     * const timeSlot = await prisma.timeSlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeSlots and only return the `id`
     * const timeSlotWithIdOnly = await prisma.timeSlot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeSlotCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeSlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimeSlot.
     * @param {TimeSlotDeleteArgs} args - Arguments to delete one TimeSlot.
     * @example
     * // Delete one TimeSlot
     * const TimeSlot = await prisma.timeSlot.delete({
     *   where: {
     *     // ... filter to delete one TimeSlot
     *   }
     * })
     * 
     */
    delete<T extends TimeSlotDeleteArgs>(args: SelectSubset<T, TimeSlotDeleteArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimeSlot.
     * @param {TimeSlotUpdateArgs} args - Arguments to update one TimeSlot.
     * @example
     * // Update one TimeSlot
     * const timeSlot = await prisma.timeSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeSlotUpdateArgs>(args: SelectSubset<T, TimeSlotUpdateArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimeSlots.
     * @param {TimeSlotDeleteManyArgs} args - Arguments to filter TimeSlots to delete.
     * @example
     * // Delete a few TimeSlots
     * const { count } = await prisma.timeSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeSlotDeleteManyArgs>(args?: SelectSubset<T, TimeSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeSlots
     * const timeSlot = await prisma.timeSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeSlotUpdateManyArgs>(args: SelectSubset<T, TimeSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSlots and returns the data updated in the database.
     * @param {TimeSlotUpdateManyAndReturnArgs} args - Arguments to update many TimeSlots.
     * @example
     * // Update many TimeSlots
     * const timeSlot = await prisma.timeSlot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimeSlots and only return the `id`
     * const timeSlotWithIdOnly = await prisma.timeSlot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimeSlotUpdateManyAndReturnArgs>(args: SelectSubset<T, TimeSlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimeSlot.
     * @param {TimeSlotUpsertArgs} args - Arguments to update or create a TimeSlot.
     * @example
     * // Update or create a TimeSlot
     * const timeSlot = await prisma.timeSlot.upsert({
     *   create: {
     *     // ... data to create a TimeSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeSlot we want to update
     *   }
     * })
     */
    upsert<T extends TimeSlotUpsertArgs>(args: SelectSubset<T, TimeSlotUpsertArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotCountArgs} args - Arguments to filter TimeSlots to count.
     * @example
     * // Count the number of TimeSlots
     * const count = await prisma.timeSlot.count({
     *   where: {
     *     // ... the filter for the TimeSlots we want to count
     *   }
     * })
    **/
    count<T extends TimeSlotCountArgs>(
      args?: Subset<T, TimeSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeSlotAggregateArgs>(args: Subset<T, TimeSlotAggregateArgs>): Prisma.PrismaPromise<GetTimeSlotAggregateType<T>>

    /**
     * Group by TimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeSlotGroupByArgs['orderBy'] }
        : { orderBy?: TimeSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeSlot model
   */
  readonly fields: TimeSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contractor<T extends ContractorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractorDefaultArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeSlot model
   */
  interface TimeSlotFieldRefs {
    readonly id: FieldRef<"TimeSlot", 'Int'>
    readonly contractorId: FieldRef<"TimeSlot", 'Int'>
    readonly date: FieldRef<"TimeSlot", 'DateTime'>
    readonly startTime: FieldRef<"TimeSlot", 'String'>
    readonly endTime: FieldRef<"TimeSlot", 'String'>
    readonly slotType: FieldRef<"TimeSlot", 'SlotType'>
    readonly bookingId: FieldRef<"TimeSlot", 'Int'>
    readonly reason: FieldRef<"TimeSlot", 'String'>
    readonly createdAt: FieldRef<"TimeSlot", 'DateTime'>
    readonly updatedAt: FieldRef<"TimeSlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TimeSlot findUnique
   */
  export type TimeSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot findUniqueOrThrow
   */
  export type TimeSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot findFirst
   */
  export type TimeSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSlots.
     */
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot findFirstOrThrow
   */
  export type TimeSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSlots.
     */
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot findMany
   */
  export type TimeSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlots to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot create
   */
  export type TimeSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeSlot.
     */
    data: XOR<TimeSlotCreateInput, TimeSlotUncheckedCreateInput>
  }

  /**
   * TimeSlot createMany
   */
  export type TimeSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeSlots.
     */
    data: TimeSlotCreateManyInput | TimeSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeSlot createManyAndReturn
   */
  export type TimeSlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * The data used to create many TimeSlots.
     */
    data: TimeSlotCreateManyInput | TimeSlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSlot update
   */
  export type TimeSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeSlot.
     */
    data: XOR<TimeSlotUpdateInput, TimeSlotUncheckedUpdateInput>
    /**
     * Choose, which TimeSlot to update.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot updateMany
   */
  export type TimeSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeSlots.
     */
    data: XOR<TimeSlotUpdateManyMutationInput, TimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which TimeSlots to update
     */
    where?: TimeSlotWhereInput
    /**
     * Limit how many TimeSlots to update.
     */
    limit?: number
  }

  /**
   * TimeSlot updateManyAndReturn
   */
  export type TimeSlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * The data used to update TimeSlots.
     */
    data: XOR<TimeSlotUpdateManyMutationInput, TimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which TimeSlots to update
     */
    where?: TimeSlotWhereInput
    /**
     * Limit how many TimeSlots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSlot upsert
   */
  export type TimeSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeSlot to update in case it exists.
     */
    where: TimeSlotWhereUniqueInput
    /**
     * In case the TimeSlot found by the `where` argument doesn't exist, create a new TimeSlot with this data.
     */
    create: XOR<TimeSlotCreateInput, TimeSlotUncheckedCreateInput>
    /**
     * In case the TimeSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeSlotUpdateInput, TimeSlotUncheckedUpdateInput>
  }

  /**
   * TimeSlot delete
   */
  export type TimeSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter which TimeSlot to delete.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot deleteMany
   */
  export type TimeSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSlots to delete
     */
    where?: TimeSlotWhereInput
    /**
     * Limit how many TimeSlots to delete.
     */
    limit?: number
  }

  /**
   * TimeSlot without action
   */
  export type TimeSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
  }


  /**
   * Model ServiceArea
   */

  export type AggregateServiceArea = {
    _count: ServiceAreaCountAggregateOutputType | null
    _avg: ServiceAreaAvgAggregateOutputType | null
    _sum: ServiceAreaSumAggregateOutputType | null
    _min: ServiceAreaMinAggregateOutputType | null
    _max: ServiceAreaMaxAggregateOutputType | null
  }

  export type ServiceAreaAvgAggregateOutputType = {
    id: number | null
  }

  export type ServiceAreaSumAggregateOutputType = {
    id: number | null
  }

  export type ServiceAreaMinAggregateOutputType = {
    id: number | null
    name: string | null
    state: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceAreaMaxAggregateOutputType = {
    id: number | null
    name: string | null
    state: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceAreaCountAggregateOutputType = {
    id: number
    name: number
    state: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAreaAvgAggregateInputType = {
    id?: true
  }

  export type ServiceAreaSumAggregateInputType = {
    id?: true
  }

  export type ServiceAreaMinAggregateInputType = {
    id?: true
    name?: true
    state?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceAreaMaxAggregateInputType = {
    id?: true
    name?: true
    state?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceAreaCountAggregateInputType = {
    id?: true
    name?: true
    state?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceArea to aggregate.
     */
    where?: ServiceAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAreas to fetch.
     */
    orderBy?: ServiceAreaOrderByWithRelationInput | ServiceAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceAreas
    **/
    _count?: true | ServiceAreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceAreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceAreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceAreaMaxAggregateInputType
  }

  export type GetServiceAreaAggregateType<T extends ServiceAreaAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceArea[P]>
      : GetScalarType<T[P], AggregateServiceArea[P]>
  }




  export type ServiceAreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAreaWhereInput
    orderBy?: ServiceAreaOrderByWithAggregationInput | ServiceAreaOrderByWithAggregationInput[]
    by: ServiceAreaScalarFieldEnum[] | ServiceAreaScalarFieldEnum
    having?: ServiceAreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceAreaCountAggregateInputType | true
    _avg?: ServiceAreaAvgAggregateInputType
    _sum?: ServiceAreaSumAggregateInputType
    _min?: ServiceAreaMinAggregateInputType
    _max?: ServiceAreaMaxAggregateInputType
  }

  export type ServiceAreaGroupByOutputType = {
    id: number
    name: string
    state: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceAreaCountAggregateOutputType | null
    _avg: ServiceAreaAvgAggregateOutputType | null
    _sum: ServiceAreaSumAggregateOutputType | null
    _min: ServiceAreaMinAggregateOutputType | null
    _max: ServiceAreaMaxAggregateOutputType | null
  }

  type GetServiceAreaGroupByPayload<T extends ServiceAreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceAreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceAreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceAreaGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceAreaGroupByOutputType[P]>
        }
      >
    >


  export type ServiceAreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    state?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceArea"]>

  export type ServiceAreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    state?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceArea"]>

  export type ServiceAreaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    state?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceArea"]>

  export type ServiceAreaSelectScalar = {
    id?: boolean
    name?: boolean
    state?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceAreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "state" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceArea"]>

  export type $ServiceAreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceArea"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      state: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceArea"]>
    composites: {}
  }

  type ServiceAreaGetPayload<S extends boolean | null | undefined | ServiceAreaDefaultArgs> = $Result.GetResult<Prisma.$ServiceAreaPayload, S>

  type ServiceAreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceAreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceAreaCountAggregateInputType | true
    }

  export interface ServiceAreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceArea'], meta: { name: 'ServiceArea' } }
    /**
     * Find zero or one ServiceArea that matches the filter.
     * @param {ServiceAreaFindUniqueArgs} args - Arguments to find a ServiceArea
     * @example
     * // Get one ServiceArea
     * const serviceArea = await prisma.serviceArea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceAreaFindUniqueArgs>(args: SelectSubset<T, ServiceAreaFindUniqueArgs<ExtArgs>>): Prisma__ServiceAreaClient<$Result.GetResult<Prisma.$ServiceAreaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceArea that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceAreaFindUniqueOrThrowArgs} args - Arguments to find a ServiceArea
     * @example
     * // Get one ServiceArea
     * const serviceArea = await prisma.serviceArea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceAreaFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceAreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceAreaClient<$Result.GetResult<Prisma.$ServiceAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceArea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAreaFindFirstArgs} args - Arguments to find a ServiceArea
     * @example
     * // Get one ServiceArea
     * const serviceArea = await prisma.serviceArea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceAreaFindFirstArgs>(args?: SelectSubset<T, ServiceAreaFindFirstArgs<ExtArgs>>): Prisma__ServiceAreaClient<$Result.GetResult<Prisma.$ServiceAreaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceArea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAreaFindFirstOrThrowArgs} args - Arguments to find a ServiceArea
     * @example
     * // Get one ServiceArea
     * const serviceArea = await prisma.serviceArea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceAreaFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceAreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceAreaClient<$Result.GetResult<Prisma.$ServiceAreaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceAreas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceAreas
     * const serviceAreas = await prisma.serviceArea.findMany()
     * 
     * // Get first 10 ServiceAreas
     * const serviceAreas = await prisma.serviceArea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceAreaWithIdOnly = await prisma.serviceArea.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceAreaFindManyArgs>(args?: SelectSubset<T, ServiceAreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceArea.
     * @param {ServiceAreaCreateArgs} args - Arguments to create a ServiceArea.
     * @example
     * // Create one ServiceArea
     * const ServiceArea = await prisma.serviceArea.create({
     *   data: {
     *     // ... data to create a ServiceArea
     *   }
     * })
     * 
     */
    create<T extends ServiceAreaCreateArgs>(args: SelectSubset<T, ServiceAreaCreateArgs<ExtArgs>>): Prisma__ServiceAreaClient<$Result.GetResult<Prisma.$ServiceAreaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceAreas.
     * @param {ServiceAreaCreateManyArgs} args - Arguments to create many ServiceAreas.
     * @example
     * // Create many ServiceAreas
     * const serviceArea = await prisma.serviceArea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceAreaCreateManyArgs>(args?: SelectSubset<T, ServiceAreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceAreas and returns the data saved in the database.
     * @param {ServiceAreaCreateManyAndReturnArgs} args - Arguments to create many ServiceAreas.
     * @example
     * // Create many ServiceAreas
     * const serviceArea = await prisma.serviceArea.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceAreas and only return the `id`
     * const serviceAreaWithIdOnly = await prisma.serviceArea.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceAreaCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceAreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAreaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceArea.
     * @param {ServiceAreaDeleteArgs} args - Arguments to delete one ServiceArea.
     * @example
     * // Delete one ServiceArea
     * const ServiceArea = await prisma.serviceArea.delete({
     *   where: {
     *     // ... filter to delete one ServiceArea
     *   }
     * })
     * 
     */
    delete<T extends ServiceAreaDeleteArgs>(args: SelectSubset<T, ServiceAreaDeleteArgs<ExtArgs>>): Prisma__ServiceAreaClient<$Result.GetResult<Prisma.$ServiceAreaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceArea.
     * @param {ServiceAreaUpdateArgs} args - Arguments to update one ServiceArea.
     * @example
     * // Update one ServiceArea
     * const serviceArea = await prisma.serviceArea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceAreaUpdateArgs>(args: SelectSubset<T, ServiceAreaUpdateArgs<ExtArgs>>): Prisma__ServiceAreaClient<$Result.GetResult<Prisma.$ServiceAreaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceAreas.
     * @param {ServiceAreaDeleteManyArgs} args - Arguments to filter ServiceAreas to delete.
     * @example
     * // Delete a few ServiceAreas
     * const { count } = await prisma.serviceArea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceAreaDeleteManyArgs>(args?: SelectSubset<T, ServiceAreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceAreas
     * const serviceArea = await prisma.serviceArea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceAreaUpdateManyArgs>(args: SelectSubset<T, ServiceAreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceAreas and returns the data updated in the database.
     * @param {ServiceAreaUpdateManyAndReturnArgs} args - Arguments to update many ServiceAreas.
     * @example
     * // Update many ServiceAreas
     * const serviceArea = await prisma.serviceArea.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceAreas and only return the `id`
     * const serviceAreaWithIdOnly = await prisma.serviceArea.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceAreaUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceAreaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAreaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceArea.
     * @param {ServiceAreaUpsertArgs} args - Arguments to update or create a ServiceArea.
     * @example
     * // Update or create a ServiceArea
     * const serviceArea = await prisma.serviceArea.upsert({
     *   create: {
     *     // ... data to create a ServiceArea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceArea we want to update
     *   }
     * })
     */
    upsert<T extends ServiceAreaUpsertArgs>(args: SelectSubset<T, ServiceAreaUpsertArgs<ExtArgs>>): Prisma__ServiceAreaClient<$Result.GetResult<Prisma.$ServiceAreaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAreaCountArgs} args - Arguments to filter ServiceAreas to count.
     * @example
     * // Count the number of ServiceAreas
     * const count = await prisma.serviceArea.count({
     *   where: {
     *     // ... the filter for the ServiceAreas we want to count
     *   }
     * })
    **/
    count<T extends ServiceAreaCountArgs>(
      args?: Subset<T, ServiceAreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceAreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAreaAggregateArgs>(args: Subset<T, ServiceAreaAggregateArgs>): Prisma.PrismaPromise<GetServiceAreaAggregateType<T>>

    /**
     * Group by ServiceArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceAreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceAreaGroupByArgs['orderBy'] }
        : { orderBy?: ServiceAreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceAreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceArea model
   */
  readonly fields: ServiceAreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceArea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceAreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceArea model
   */
  interface ServiceAreaFieldRefs {
    readonly id: FieldRef<"ServiceArea", 'Int'>
    readonly name: FieldRef<"ServiceArea", 'String'>
    readonly state: FieldRef<"ServiceArea", 'String'>
    readonly isActive: FieldRef<"ServiceArea", 'Boolean'>
    readonly createdAt: FieldRef<"ServiceArea", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceArea", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceArea findUnique
   */
  export type ServiceAreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceArea
     */
    select?: ServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceArea
     */
    omit?: ServiceAreaOmit<ExtArgs> | null
    /**
     * Filter, which ServiceArea to fetch.
     */
    where: ServiceAreaWhereUniqueInput
  }

  /**
   * ServiceArea findUniqueOrThrow
   */
  export type ServiceAreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceArea
     */
    select?: ServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceArea
     */
    omit?: ServiceAreaOmit<ExtArgs> | null
    /**
     * Filter, which ServiceArea to fetch.
     */
    where: ServiceAreaWhereUniqueInput
  }

  /**
   * ServiceArea findFirst
   */
  export type ServiceAreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceArea
     */
    select?: ServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceArea
     */
    omit?: ServiceAreaOmit<ExtArgs> | null
    /**
     * Filter, which ServiceArea to fetch.
     */
    where?: ServiceAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAreas to fetch.
     */
    orderBy?: ServiceAreaOrderByWithRelationInput | ServiceAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAreas.
     */
    cursor?: ServiceAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAreas.
     */
    distinct?: ServiceAreaScalarFieldEnum | ServiceAreaScalarFieldEnum[]
  }

  /**
   * ServiceArea findFirstOrThrow
   */
  export type ServiceAreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceArea
     */
    select?: ServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceArea
     */
    omit?: ServiceAreaOmit<ExtArgs> | null
    /**
     * Filter, which ServiceArea to fetch.
     */
    where?: ServiceAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAreas to fetch.
     */
    orderBy?: ServiceAreaOrderByWithRelationInput | ServiceAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAreas.
     */
    cursor?: ServiceAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAreas.
     */
    distinct?: ServiceAreaScalarFieldEnum | ServiceAreaScalarFieldEnum[]
  }

  /**
   * ServiceArea findMany
   */
  export type ServiceAreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceArea
     */
    select?: ServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceArea
     */
    omit?: ServiceAreaOmit<ExtArgs> | null
    /**
     * Filter, which ServiceAreas to fetch.
     */
    where?: ServiceAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAreas to fetch.
     */
    orderBy?: ServiceAreaOrderByWithRelationInput | ServiceAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceAreas.
     */
    cursor?: ServiceAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAreas.
     */
    skip?: number
    distinct?: ServiceAreaScalarFieldEnum | ServiceAreaScalarFieldEnum[]
  }

  /**
   * ServiceArea create
   */
  export type ServiceAreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceArea
     */
    select?: ServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceArea
     */
    omit?: ServiceAreaOmit<ExtArgs> | null
    /**
     * The data needed to create a ServiceArea.
     */
    data: XOR<ServiceAreaCreateInput, ServiceAreaUncheckedCreateInput>
  }

  /**
   * ServiceArea createMany
   */
  export type ServiceAreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceAreas.
     */
    data: ServiceAreaCreateManyInput | ServiceAreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceArea createManyAndReturn
   */
  export type ServiceAreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceArea
     */
    select?: ServiceAreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceArea
     */
    omit?: ServiceAreaOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceAreas.
     */
    data: ServiceAreaCreateManyInput | ServiceAreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceArea update
   */
  export type ServiceAreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceArea
     */
    select?: ServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceArea
     */
    omit?: ServiceAreaOmit<ExtArgs> | null
    /**
     * The data needed to update a ServiceArea.
     */
    data: XOR<ServiceAreaUpdateInput, ServiceAreaUncheckedUpdateInput>
    /**
     * Choose, which ServiceArea to update.
     */
    where: ServiceAreaWhereUniqueInput
  }

  /**
   * ServiceArea updateMany
   */
  export type ServiceAreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceAreas.
     */
    data: XOR<ServiceAreaUpdateManyMutationInput, ServiceAreaUncheckedUpdateManyInput>
    /**
     * Filter which ServiceAreas to update
     */
    where?: ServiceAreaWhereInput
    /**
     * Limit how many ServiceAreas to update.
     */
    limit?: number
  }

  /**
   * ServiceArea updateManyAndReturn
   */
  export type ServiceAreaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceArea
     */
    select?: ServiceAreaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceArea
     */
    omit?: ServiceAreaOmit<ExtArgs> | null
    /**
     * The data used to update ServiceAreas.
     */
    data: XOR<ServiceAreaUpdateManyMutationInput, ServiceAreaUncheckedUpdateManyInput>
    /**
     * Filter which ServiceAreas to update
     */
    where?: ServiceAreaWhereInput
    /**
     * Limit how many ServiceAreas to update.
     */
    limit?: number
  }

  /**
   * ServiceArea upsert
   */
  export type ServiceAreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceArea
     */
    select?: ServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceArea
     */
    omit?: ServiceAreaOmit<ExtArgs> | null
    /**
     * The filter to search for the ServiceArea to update in case it exists.
     */
    where: ServiceAreaWhereUniqueInput
    /**
     * In case the ServiceArea found by the `where` argument doesn't exist, create a new ServiceArea with this data.
     */
    create: XOR<ServiceAreaCreateInput, ServiceAreaUncheckedCreateInput>
    /**
     * In case the ServiceArea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceAreaUpdateInput, ServiceAreaUncheckedUpdateInput>
  }

  /**
   * ServiceArea delete
   */
  export type ServiceAreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceArea
     */
    select?: ServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceArea
     */
    omit?: ServiceAreaOmit<ExtArgs> | null
    /**
     * Filter which ServiceArea to delete.
     */
    where: ServiceAreaWhereUniqueInput
  }

  /**
   * ServiceArea deleteMany
   */
  export type ServiceAreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAreas to delete
     */
    where?: ServiceAreaWhereInput
    /**
     * Limit how many ServiceAreas to delete.
     */
    limit?: number
  }

  /**
   * ServiceArea without action
   */
  export type ServiceAreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceArea
     */
    select?: ServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceArea
     */
    omit?: ServiceAreaOmit<ExtArgs> | null
  }


  /**
   * Model ContractorServiceArea
   */

  export type AggregateContractorServiceArea = {
    _count: ContractorServiceAreaCountAggregateOutputType | null
    _avg: ContractorServiceAreaAvgAggregateOutputType | null
    _sum: ContractorServiceAreaSumAggregateOutputType | null
    _min: ContractorServiceAreaMinAggregateOutputType | null
    _max: ContractorServiceAreaMaxAggregateOutputType | null
  }

  export type ContractorServiceAreaAvgAggregateOutputType = {
    id: number | null
    contractorId: number | null
    dayOfWeek: number | null
  }

  export type ContractorServiceAreaSumAggregateOutputType = {
    id: number | null
    contractorId: number | null
    dayOfWeek: number | null
  }

  export type ContractorServiceAreaMinAggregateOutputType = {
    id: number | null
    contractorId: number | null
    dayOfWeek: number | null
    area: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractorServiceAreaMaxAggregateOutputType = {
    id: number | null
    contractorId: number | null
    dayOfWeek: number | null
    area: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractorServiceAreaCountAggregateOutputType = {
    id: number
    contractorId: number
    dayOfWeek: number
    area: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContractorServiceAreaAvgAggregateInputType = {
    id?: true
    contractorId?: true
    dayOfWeek?: true
  }

  export type ContractorServiceAreaSumAggregateInputType = {
    id?: true
    contractorId?: true
    dayOfWeek?: true
  }

  export type ContractorServiceAreaMinAggregateInputType = {
    id?: true
    contractorId?: true
    dayOfWeek?: true
    area?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractorServiceAreaMaxAggregateInputType = {
    id?: true
    contractorId?: true
    dayOfWeek?: true
    area?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractorServiceAreaCountAggregateInputType = {
    id?: true
    contractorId?: true
    dayOfWeek?: true
    area?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContractorServiceAreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractorServiceArea to aggregate.
     */
    where?: ContractorServiceAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorServiceAreas to fetch.
     */
    orderBy?: ContractorServiceAreaOrderByWithRelationInput | ContractorServiceAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractorServiceAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorServiceAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorServiceAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractorServiceAreas
    **/
    _count?: true | ContractorServiceAreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractorServiceAreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractorServiceAreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractorServiceAreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractorServiceAreaMaxAggregateInputType
  }

  export type GetContractorServiceAreaAggregateType<T extends ContractorServiceAreaAggregateArgs> = {
        [P in keyof T & keyof AggregateContractorServiceArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractorServiceArea[P]>
      : GetScalarType<T[P], AggregateContractorServiceArea[P]>
  }




  export type ContractorServiceAreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractorServiceAreaWhereInput
    orderBy?: ContractorServiceAreaOrderByWithAggregationInput | ContractorServiceAreaOrderByWithAggregationInput[]
    by: ContractorServiceAreaScalarFieldEnum[] | ContractorServiceAreaScalarFieldEnum
    having?: ContractorServiceAreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractorServiceAreaCountAggregateInputType | true
    _avg?: ContractorServiceAreaAvgAggregateInputType
    _sum?: ContractorServiceAreaSumAggregateInputType
    _min?: ContractorServiceAreaMinAggregateInputType
    _max?: ContractorServiceAreaMaxAggregateInputType
  }

  export type ContractorServiceAreaGroupByOutputType = {
    id: number
    contractorId: number
    dayOfWeek: number | null
    area: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ContractorServiceAreaCountAggregateOutputType | null
    _avg: ContractorServiceAreaAvgAggregateOutputType | null
    _sum: ContractorServiceAreaSumAggregateOutputType | null
    _min: ContractorServiceAreaMinAggregateOutputType | null
    _max: ContractorServiceAreaMaxAggregateOutputType | null
  }

  type GetContractorServiceAreaGroupByPayload<T extends ContractorServiceAreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractorServiceAreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractorServiceAreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractorServiceAreaGroupByOutputType[P]>
            : GetScalarType<T[P], ContractorServiceAreaGroupByOutputType[P]>
        }
      >
    >


  export type ContractorServiceAreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    dayOfWeek?: boolean
    area?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractorServiceArea"]>

  export type ContractorServiceAreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    dayOfWeek?: boolean
    area?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractorServiceArea"]>

  export type ContractorServiceAreaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    dayOfWeek?: boolean
    area?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractorServiceArea"]>

  export type ContractorServiceAreaSelectScalar = {
    id?: boolean
    contractorId?: boolean
    dayOfWeek?: boolean
    area?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContractorServiceAreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractorId" | "dayOfWeek" | "area" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["contractorServiceArea"]>
  export type ContractorServiceAreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }
  export type ContractorServiceAreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }
  export type ContractorServiceAreaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }

  export type $ContractorServiceAreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractorServiceArea"
    objects: {
      contractor: Prisma.$ContractorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contractorId: number
      dayOfWeek: number | null
      area: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contractorServiceArea"]>
    composites: {}
  }

  type ContractorServiceAreaGetPayload<S extends boolean | null | undefined | ContractorServiceAreaDefaultArgs> = $Result.GetResult<Prisma.$ContractorServiceAreaPayload, S>

  type ContractorServiceAreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractorServiceAreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractorServiceAreaCountAggregateInputType | true
    }

  export interface ContractorServiceAreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractorServiceArea'], meta: { name: 'ContractorServiceArea' } }
    /**
     * Find zero or one ContractorServiceArea that matches the filter.
     * @param {ContractorServiceAreaFindUniqueArgs} args - Arguments to find a ContractorServiceArea
     * @example
     * // Get one ContractorServiceArea
     * const contractorServiceArea = await prisma.contractorServiceArea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractorServiceAreaFindUniqueArgs>(args: SelectSubset<T, ContractorServiceAreaFindUniqueArgs<ExtArgs>>): Prisma__ContractorServiceAreaClient<$Result.GetResult<Prisma.$ContractorServiceAreaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContractorServiceArea that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractorServiceAreaFindUniqueOrThrowArgs} args - Arguments to find a ContractorServiceArea
     * @example
     * // Get one ContractorServiceArea
     * const contractorServiceArea = await prisma.contractorServiceArea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractorServiceAreaFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractorServiceAreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractorServiceAreaClient<$Result.GetResult<Prisma.$ContractorServiceAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractorServiceArea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorServiceAreaFindFirstArgs} args - Arguments to find a ContractorServiceArea
     * @example
     * // Get one ContractorServiceArea
     * const contractorServiceArea = await prisma.contractorServiceArea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractorServiceAreaFindFirstArgs>(args?: SelectSubset<T, ContractorServiceAreaFindFirstArgs<ExtArgs>>): Prisma__ContractorServiceAreaClient<$Result.GetResult<Prisma.$ContractorServiceAreaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractorServiceArea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorServiceAreaFindFirstOrThrowArgs} args - Arguments to find a ContractorServiceArea
     * @example
     * // Get one ContractorServiceArea
     * const contractorServiceArea = await prisma.contractorServiceArea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractorServiceAreaFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractorServiceAreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractorServiceAreaClient<$Result.GetResult<Prisma.$ContractorServiceAreaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContractorServiceAreas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorServiceAreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractorServiceAreas
     * const contractorServiceAreas = await prisma.contractorServiceArea.findMany()
     * 
     * // Get first 10 ContractorServiceAreas
     * const contractorServiceAreas = await prisma.contractorServiceArea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractorServiceAreaWithIdOnly = await prisma.contractorServiceArea.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractorServiceAreaFindManyArgs>(args?: SelectSubset<T, ContractorServiceAreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorServiceAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContractorServiceArea.
     * @param {ContractorServiceAreaCreateArgs} args - Arguments to create a ContractorServiceArea.
     * @example
     * // Create one ContractorServiceArea
     * const ContractorServiceArea = await prisma.contractorServiceArea.create({
     *   data: {
     *     // ... data to create a ContractorServiceArea
     *   }
     * })
     * 
     */
    create<T extends ContractorServiceAreaCreateArgs>(args: SelectSubset<T, ContractorServiceAreaCreateArgs<ExtArgs>>): Prisma__ContractorServiceAreaClient<$Result.GetResult<Prisma.$ContractorServiceAreaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContractorServiceAreas.
     * @param {ContractorServiceAreaCreateManyArgs} args - Arguments to create many ContractorServiceAreas.
     * @example
     * // Create many ContractorServiceAreas
     * const contractorServiceArea = await prisma.contractorServiceArea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractorServiceAreaCreateManyArgs>(args?: SelectSubset<T, ContractorServiceAreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContractorServiceAreas and returns the data saved in the database.
     * @param {ContractorServiceAreaCreateManyAndReturnArgs} args - Arguments to create many ContractorServiceAreas.
     * @example
     * // Create many ContractorServiceAreas
     * const contractorServiceArea = await prisma.contractorServiceArea.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContractorServiceAreas and only return the `id`
     * const contractorServiceAreaWithIdOnly = await prisma.contractorServiceArea.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractorServiceAreaCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractorServiceAreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorServiceAreaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContractorServiceArea.
     * @param {ContractorServiceAreaDeleteArgs} args - Arguments to delete one ContractorServiceArea.
     * @example
     * // Delete one ContractorServiceArea
     * const ContractorServiceArea = await prisma.contractorServiceArea.delete({
     *   where: {
     *     // ... filter to delete one ContractorServiceArea
     *   }
     * })
     * 
     */
    delete<T extends ContractorServiceAreaDeleteArgs>(args: SelectSubset<T, ContractorServiceAreaDeleteArgs<ExtArgs>>): Prisma__ContractorServiceAreaClient<$Result.GetResult<Prisma.$ContractorServiceAreaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContractorServiceArea.
     * @param {ContractorServiceAreaUpdateArgs} args - Arguments to update one ContractorServiceArea.
     * @example
     * // Update one ContractorServiceArea
     * const contractorServiceArea = await prisma.contractorServiceArea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractorServiceAreaUpdateArgs>(args: SelectSubset<T, ContractorServiceAreaUpdateArgs<ExtArgs>>): Prisma__ContractorServiceAreaClient<$Result.GetResult<Prisma.$ContractorServiceAreaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContractorServiceAreas.
     * @param {ContractorServiceAreaDeleteManyArgs} args - Arguments to filter ContractorServiceAreas to delete.
     * @example
     * // Delete a few ContractorServiceAreas
     * const { count } = await prisma.contractorServiceArea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractorServiceAreaDeleteManyArgs>(args?: SelectSubset<T, ContractorServiceAreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractorServiceAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorServiceAreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractorServiceAreas
     * const contractorServiceArea = await prisma.contractorServiceArea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractorServiceAreaUpdateManyArgs>(args: SelectSubset<T, ContractorServiceAreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractorServiceAreas and returns the data updated in the database.
     * @param {ContractorServiceAreaUpdateManyAndReturnArgs} args - Arguments to update many ContractorServiceAreas.
     * @example
     * // Update many ContractorServiceAreas
     * const contractorServiceArea = await prisma.contractorServiceArea.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContractorServiceAreas and only return the `id`
     * const contractorServiceAreaWithIdOnly = await prisma.contractorServiceArea.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractorServiceAreaUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractorServiceAreaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorServiceAreaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContractorServiceArea.
     * @param {ContractorServiceAreaUpsertArgs} args - Arguments to update or create a ContractorServiceArea.
     * @example
     * // Update or create a ContractorServiceArea
     * const contractorServiceArea = await prisma.contractorServiceArea.upsert({
     *   create: {
     *     // ... data to create a ContractorServiceArea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractorServiceArea we want to update
     *   }
     * })
     */
    upsert<T extends ContractorServiceAreaUpsertArgs>(args: SelectSubset<T, ContractorServiceAreaUpsertArgs<ExtArgs>>): Prisma__ContractorServiceAreaClient<$Result.GetResult<Prisma.$ContractorServiceAreaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContractorServiceAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorServiceAreaCountArgs} args - Arguments to filter ContractorServiceAreas to count.
     * @example
     * // Count the number of ContractorServiceAreas
     * const count = await prisma.contractorServiceArea.count({
     *   where: {
     *     // ... the filter for the ContractorServiceAreas we want to count
     *   }
     * })
    **/
    count<T extends ContractorServiceAreaCountArgs>(
      args?: Subset<T, ContractorServiceAreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractorServiceAreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractorServiceArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorServiceAreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractorServiceAreaAggregateArgs>(args: Subset<T, ContractorServiceAreaAggregateArgs>): Prisma.PrismaPromise<GetContractorServiceAreaAggregateType<T>>

    /**
     * Group by ContractorServiceArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorServiceAreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractorServiceAreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractorServiceAreaGroupByArgs['orderBy'] }
        : { orderBy?: ContractorServiceAreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractorServiceAreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractorServiceAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractorServiceArea model
   */
  readonly fields: ContractorServiceAreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractorServiceArea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractorServiceAreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contractor<T extends ContractorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractorDefaultArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContractorServiceArea model
   */
  interface ContractorServiceAreaFieldRefs {
    readonly id: FieldRef<"ContractorServiceArea", 'Int'>
    readonly contractorId: FieldRef<"ContractorServiceArea", 'Int'>
    readonly dayOfWeek: FieldRef<"ContractorServiceArea", 'Int'>
    readonly area: FieldRef<"ContractorServiceArea", 'String'>
    readonly isActive: FieldRef<"ContractorServiceArea", 'Boolean'>
    readonly createdAt: FieldRef<"ContractorServiceArea", 'DateTime'>
    readonly updatedAt: FieldRef<"ContractorServiceArea", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContractorServiceArea findUnique
   */
  export type ContractorServiceAreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorServiceArea
     */
    select?: ContractorServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorServiceArea
     */
    omit?: ContractorServiceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceAreaInclude<ExtArgs> | null
    /**
     * Filter, which ContractorServiceArea to fetch.
     */
    where: ContractorServiceAreaWhereUniqueInput
  }

  /**
   * ContractorServiceArea findUniqueOrThrow
   */
  export type ContractorServiceAreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorServiceArea
     */
    select?: ContractorServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorServiceArea
     */
    omit?: ContractorServiceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceAreaInclude<ExtArgs> | null
    /**
     * Filter, which ContractorServiceArea to fetch.
     */
    where: ContractorServiceAreaWhereUniqueInput
  }

  /**
   * ContractorServiceArea findFirst
   */
  export type ContractorServiceAreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorServiceArea
     */
    select?: ContractorServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorServiceArea
     */
    omit?: ContractorServiceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceAreaInclude<ExtArgs> | null
    /**
     * Filter, which ContractorServiceArea to fetch.
     */
    where?: ContractorServiceAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorServiceAreas to fetch.
     */
    orderBy?: ContractorServiceAreaOrderByWithRelationInput | ContractorServiceAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractorServiceAreas.
     */
    cursor?: ContractorServiceAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorServiceAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorServiceAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractorServiceAreas.
     */
    distinct?: ContractorServiceAreaScalarFieldEnum | ContractorServiceAreaScalarFieldEnum[]
  }

  /**
   * ContractorServiceArea findFirstOrThrow
   */
  export type ContractorServiceAreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorServiceArea
     */
    select?: ContractorServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorServiceArea
     */
    omit?: ContractorServiceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceAreaInclude<ExtArgs> | null
    /**
     * Filter, which ContractorServiceArea to fetch.
     */
    where?: ContractorServiceAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorServiceAreas to fetch.
     */
    orderBy?: ContractorServiceAreaOrderByWithRelationInput | ContractorServiceAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractorServiceAreas.
     */
    cursor?: ContractorServiceAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorServiceAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorServiceAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractorServiceAreas.
     */
    distinct?: ContractorServiceAreaScalarFieldEnum | ContractorServiceAreaScalarFieldEnum[]
  }

  /**
   * ContractorServiceArea findMany
   */
  export type ContractorServiceAreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorServiceArea
     */
    select?: ContractorServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorServiceArea
     */
    omit?: ContractorServiceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceAreaInclude<ExtArgs> | null
    /**
     * Filter, which ContractorServiceAreas to fetch.
     */
    where?: ContractorServiceAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorServiceAreas to fetch.
     */
    orderBy?: ContractorServiceAreaOrderByWithRelationInput | ContractorServiceAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractorServiceAreas.
     */
    cursor?: ContractorServiceAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorServiceAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorServiceAreas.
     */
    skip?: number
    distinct?: ContractorServiceAreaScalarFieldEnum | ContractorServiceAreaScalarFieldEnum[]
  }

  /**
   * ContractorServiceArea create
   */
  export type ContractorServiceAreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorServiceArea
     */
    select?: ContractorServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorServiceArea
     */
    omit?: ContractorServiceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceAreaInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractorServiceArea.
     */
    data: XOR<ContractorServiceAreaCreateInput, ContractorServiceAreaUncheckedCreateInput>
  }

  /**
   * ContractorServiceArea createMany
   */
  export type ContractorServiceAreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractorServiceAreas.
     */
    data: ContractorServiceAreaCreateManyInput | ContractorServiceAreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractorServiceArea createManyAndReturn
   */
  export type ContractorServiceAreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorServiceArea
     */
    select?: ContractorServiceAreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorServiceArea
     */
    omit?: ContractorServiceAreaOmit<ExtArgs> | null
    /**
     * The data used to create many ContractorServiceAreas.
     */
    data: ContractorServiceAreaCreateManyInput | ContractorServiceAreaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceAreaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractorServiceArea update
   */
  export type ContractorServiceAreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorServiceArea
     */
    select?: ContractorServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorServiceArea
     */
    omit?: ContractorServiceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceAreaInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractorServiceArea.
     */
    data: XOR<ContractorServiceAreaUpdateInput, ContractorServiceAreaUncheckedUpdateInput>
    /**
     * Choose, which ContractorServiceArea to update.
     */
    where: ContractorServiceAreaWhereUniqueInput
  }

  /**
   * ContractorServiceArea updateMany
   */
  export type ContractorServiceAreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractorServiceAreas.
     */
    data: XOR<ContractorServiceAreaUpdateManyMutationInput, ContractorServiceAreaUncheckedUpdateManyInput>
    /**
     * Filter which ContractorServiceAreas to update
     */
    where?: ContractorServiceAreaWhereInput
    /**
     * Limit how many ContractorServiceAreas to update.
     */
    limit?: number
  }

  /**
   * ContractorServiceArea updateManyAndReturn
   */
  export type ContractorServiceAreaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorServiceArea
     */
    select?: ContractorServiceAreaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorServiceArea
     */
    omit?: ContractorServiceAreaOmit<ExtArgs> | null
    /**
     * The data used to update ContractorServiceAreas.
     */
    data: XOR<ContractorServiceAreaUpdateManyMutationInput, ContractorServiceAreaUncheckedUpdateManyInput>
    /**
     * Filter which ContractorServiceAreas to update
     */
    where?: ContractorServiceAreaWhereInput
    /**
     * Limit how many ContractorServiceAreas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceAreaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractorServiceArea upsert
   */
  export type ContractorServiceAreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorServiceArea
     */
    select?: ContractorServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorServiceArea
     */
    omit?: ContractorServiceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceAreaInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractorServiceArea to update in case it exists.
     */
    where: ContractorServiceAreaWhereUniqueInput
    /**
     * In case the ContractorServiceArea found by the `where` argument doesn't exist, create a new ContractorServiceArea with this data.
     */
    create: XOR<ContractorServiceAreaCreateInput, ContractorServiceAreaUncheckedCreateInput>
    /**
     * In case the ContractorServiceArea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractorServiceAreaUpdateInput, ContractorServiceAreaUncheckedUpdateInput>
  }

  /**
   * ContractorServiceArea delete
   */
  export type ContractorServiceAreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorServiceArea
     */
    select?: ContractorServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorServiceArea
     */
    omit?: ContractorServiceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceAreaInclude<ExtArgs> | null
    /**
     * Filter which ContractorServiceArea to delete.
     */
    where: ContractorServiceAreaWhereUniqueInput
  }

  /**
   * ContractorServiceArea deleteMany
   */
  export type ContractorServiceAreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractorServiceAreas to delete
     */
    where?: ContractorServiceAreaWhereInput
    /**
     * Limit how many ContractorServiceAreas to delete.
     */
    limit?: number
  }

  /**
   * ContractorServiceArea without action
   */
  export type ContractorServiceAreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorServiceArea
     */
    select?: ContractorServiceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorServiceArea
     */
    omit?: ContractorServiceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorServiceAreaInclude<ExtArgs> | null
  }


  /**
   * Model FavoriteContractor
   */

  export type AggregateFavoriteContractor = {
    _count: FavoriteContractorCountAggregateOutputType | null
    _avg: FavoriteContractorAvgAggregateOutputType | null
    _sum: FavoriteContractorSumAggregateOutputType | null
    _min: FavoriteContractorMinAggregateOutputType | null
    _max: FavoriteContractorMaxAggregateOutputType | null
  }

  export type FavoriteContractorAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
    contractorId: number | null
  }

  export type FavoriteContractorSumAggregateOutputType = {
    id: number | null
    clientId: number | null
    contractorId: number | null
  }

  export type FavoriteContractorMinAggregateOutputType = {
    id: number | null
    clientId: number | null
    contractorId: number | null
    createdAt: Date | null
  }

  export type FavoriteContractorMaxAggregateOutputType = {
    id: number | null
    clientId: number | null
    contractorId: number | null
    createdAt: Date | null
  }

  export type FavoriteContractorCountAggregateOutputType = {
    id: number
    clientId: number
    contractorId: number
    createdAt: number
    _all: number
  }


  export type FavoriteContractorAvgAggregateInputType = {
    id?: true
    clientId?: true
    contractorId?: true
  }

  export type FavoriteContractorSumAggregateInputType = {
    id?: true
    clientId?: true
    contractorId?: true
  }

  export type FavoriteContractorMinAggregateInputType = {
    id?: true
    clientId?: true
    contractorId?: true
    createdAt?: true
  }

  export type FavoriteContractorMaxAggregateInputType = {
    id?: true
    clientId?: true
    contractorId?: true
    createdAt?: true
  }

  export type FavoriteContractorCountAggregateInputType = {
    id?: true
    clientId?: true
    contractorId?: true
    createdAt?: true
    _all?: true
  }

  export type FavoriteContractorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavoriteContractor to aggregate.
     */
    where?: FavoriteContractorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteContractors to fetch.
     */
    orderBy?: FavoriteContractorOrderByWithRelationInput | FavoriteContractorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteContractorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteContractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteContractors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FavoriteContractors
    **/
    _count?: true | FavoriteContractorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FavoriteContractorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FavoriteContractorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteContractorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteContractorMaxAggregateInputType
  }

  export type GetFavoriteContractorAggregateType<T extends FavoriteContractorAggregateArgs> = {
        [P in keyof T & keyof AggregateFavoriteContractor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavoriteContractor[P]>
      : GetScalarType<T[P], AggregateFavoriteContractor[P]>
  }




  export type FavoriteContractorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteContractorWhereInput
    orderBy?: FavoriteContractorOrderByWithAggregationInput | FavoriteContractorOrderByWithAggregationInput[]
    by: FavoriteContractorScalarFieldEnum[] | FavoriteContractorScalarFieldEnum
    having?: FavoriteContractorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteContractorCountAggregateInputType | true
    _avg?: FavoriteContractorAvgAggregateInputType
    _sum?: FavoriteContractorSumAggregateInputType
    _min?: FavoriteContractorMinAggregateInputType
    _max?: FavoriteContractorMaxAggregateInputType
  }

  export type FavoriteContractorGroupByOutputType = {
    id: number
    clientId: number
    contractorId: number
    createdAt: Date
    _count: FavoriteContractorCountAggregateOutputType | null
    _avg: FavoriteContractorAvgAggregateOutputType | null
    _sum: FavoriteContractorSumAggregateOutputType | null
    _min: FavoriteContractorMinAggregateOutputType | null
    _max: FavoriteContractorMaxAggregateOutputType | null
  }

  type GetFavoriteContractorGroupByPayload<T extends FavoriteContractorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteContractorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteContractorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteContractorGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteContractorGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteContractorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    contractorId?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteContractor"]>

  export type FavoriteContractorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    contractorId?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteContractor"]>

  export type FavoriteContractorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    contractorId?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteContractor"]>

  export type FavoriteContractorSelectScalar = {
    id?: boolean
    clientId?: boolean
    contractorId?: boolean
    createdAt?: boolean
  }

  export type FavoriteContractorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "contractorId" | "createdAt", ExtArgs["result"]["favoriteContractor"]>
  export type FavoriteContractorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }
  export type FavoriteContractorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }
  export type FavoriteContractorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }

  export type $FavoriteContractorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FavoriteContractor"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      contractor: Prisma.$ContractorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clientId: number
      contractorId: number
      createdAt: Date
    }, ExtArgs["result"]["favoriteContractor"]>
    composites: {}
  }

  type FavoriteContractorGetPayload<S extends boolean | null | undefined | FavoriteContractorDefaultArgs> = $Result.GetResult<Prisma.$FavoriteContractorPayload, S>

  type FavoriteContractorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoriteContractorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoriteContractorCountAggregateInputType | true
    }

  export interface FavoriteContractorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FavoriteContractor'], meta: { name: 'FavoriteContractor' } }
    /**
     * Find zero or one FavoriteContractor that matches the filter.
     * @param {FavoriteContractorFindUniqueArgs} args - Arguments to find a FavoriteContractor
     * @example
     * // Get one FavoriteContractor
     * const favoriteContractor = await prisma.favoriteContractor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteContractorFindUniqueArgs>(args: SelectSubset<T, FavoriteContractorFindUniqueArgs<ExtArgs>>): Prisma__FavoriteContractorClient<$Result.GetResult<Prisma.$FavoriteContractorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FavoriteContractor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoriteContractorFindUniqueOrThrowArgs} args - Arguments to find a FavoriteContractor
     * @example
     * // Get one FavoriteContractor
     * const favoriteContractor = await prisma.favoriteContractor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteContractorFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteContractorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteContractorClient<$Result.GetResult<Prisma.$FavoriteContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FavoriteContractor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteContractorFindFirstArgs} args - Arguments to find a FavoriteContractor
     * @example
     * // Get one FavoriteContractor
     * const favoriteContractor = await prisma.favoriteContractor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteContractorFindFirstArgs>(args?: SelectSubset<T, FavoriteContractorFindFirstArgs<ExtArgs>>): Prisma__FavoriteContractorClient<$Result.GetResult<Prisma.$FavoriteContractorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FavoriteContractor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteContractorFindFirstOrThrowArgs} args - Arguments to find a FavoriteContractor
     * @example
     * // Get one FavoriteContractor
     * const favoriteContractor = await prisma.favoriteContractor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteContractorFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteContractorFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteContractorClient<$Result.GetResult<Prisma.$FavoriteContractorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FavoriteContractors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteContractorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FavoriteContractors
     * const favoriteContractors = await prisma.favoriteContractor.findMany()
     * 
     * // Get first 10 FavoriteContractors
     * const favoriteContractors = await prisma.favoriteContractor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteContractorWithIdOnly = await prisma.favoriteContractor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteContractorFindManyArgs>(args?: SelectSubset<T, FavoriteContractorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteContractorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FavoriteContractor.
     * @param {FavoriteContractorCreateArgs} args - Arguments to create a FavoriteContractor.
     * @example
     * // Create one FavoriteContractor
     * const FavoriteContractor = await prisma.favoriteContractor.create({
     *   data: {
     *     // ... data to create a FavoriteContractor
     *   }
     * })
     * 
     */
    create<T extends FavoriteContractorCreateArgs>(args: SelectSubset<T, FavoriteContractorCreateArgs<ExtArgs>>): Prisma__FavoriteContractorClient<$Result.GetResult<Prisma.$FavoriteContractorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FavoriteContractors.
     * @param {FavoriteContractorCreateManyArgs} args - Arguments to create many FavoriteContractors.
     * @example
     * // Create many FavoriteContractors
     * const favoriteContractor = await prisma.favoriteContractor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteContractorCreateManyArgs>(args?: SelectSubset<T, FavoriteContractorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FavoriteContractors and returns the data saved in the database.
     * @param {FavoriteContractorCreateManyAndReturnArgs} args - Arguments to create many FavoriteContractors.
     * @example
     * // Create many FavoriteContractors
     * const favoriteContractor = await prisma.favoriteContractor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FavoriteContractors and only return the `id`
     * const favoriteContractorWithIdOnly = await prisma.favoriteContractor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteContractorCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteContractorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteContractorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FavoriteContractor.
     * @param {FavoriteContractorDeleteArgs} args - Arguments to delete one FavoriteContractor.
     * @example
     * // Delete one FavoriteContractor
     * const FavoriteContractor = await prisma.favoriteContractor.delete({
     *   where: {
     *     // ... filter to delete one FavoriteContractor
     *   }
     * })
     * 
     */
    delete<T extends FavoriteContractorDeleteArgs>(args: SelectSubset<T, FavoriteContractorDeleteArgs<ExtArgs>>): Prisma__FavoriteContractorClient<$Result.GetResult<Prisma.$FavoriteContractorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FavoriteContractor.
     * @param {FavoriteContractorUpdateArgs} args - Arguments to update one FavoriteContractor.
     * @example
     * // Update one FavoriteContractor
     * const favoriteContractor = await prisma.favoriteContractor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteContractorUpdateArgs>(args: SelectSubset<T, FavoriteContractorUpdateArgs<ExtArgs>>): Prisma__FavoriteContractorClient<$Result.GetResult<Prisma.$FavoriteContractorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FavoriteContractors.
     * @param {FavoriteContractorDeleteManyArgs} args - Arguments to filter FavoriteContractors to delete.
     * @example
     * // Delete a few FavoriteContractors
     * const { count } = await prisma.favoriteContractor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteContractorDeleteManyArgs>(args?: SelectSubset<T, FavoriteContractorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FavoriteContractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteContractorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FavoriteContractors
     * const favoriteContractor = await prisma.favoriteContractor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteContractorUpdateManyArgs>(args: SelectSubset<T, FavoriteContractorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FavoriteContractors and returns the data updated in the database.
     * @param {FavoriteContractorUpdateManyAndReturnArgs} args - Arguments to update many FavoriteContractors.
     * @example
     * // Update many FavoriteContractors
     * const favoriteContractor = await prisma.favoriteContractor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FavoriteContractors and only return the `id`
     * const favoriteContractorWithIdOnly = await prisma.favoriteContractor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FavoriteContractorUpdateManyAndReturnArgs>(args: SelectSubset<T, FavoriteContractorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteContractorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FavoriteContractor.
     * @param {FavoriteContractorUpsertArgs} args - Arguments to update or create a FavoriteContractor.
     * @example
     * // Update or create a FavoriteContractor
     * const favoriteContractor = await prisma.favoriteContractor.upsert({
     *   create: {
     *     // ... data to create a FavoriteContractor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FavoriteContractor we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteContractorUpsertArgs>(args: SelectSubset<T, FavoriteContractorUpsertArgs<ExtArgs>>): Prisma__FavoriteContractorClient<$Result.GetResult<Prisma.$FavoriteContractorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FavoriteContractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteContractorCountArgs} args - Arguments to filter FavoriteContractors to count.
     * @example
     * // Count the number of FavoriteContractors
     * const count = await prisma.favoriteContractor.count({
     *   where: {
     *     // ... the filter for the FavoriteContractors we want to count
     *   }
     * })
    **/
    count<T extends FavoriteContractorCountArgs>(
      args?: Subset<T, FavoriteContractorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteContractorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FavoriteContractor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteContractorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteContractorAggregateArgs>(args: Subset<T, FavoriteContractorAggregateArgs>): Prisma.PrismaPromise<GetFavoriteContractorAggregateType<T>>

    /**
     * Group by FavoriteContractor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteContractorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteContractorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteContractorGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteContractorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteContractorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteContractorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FavoriteContractor model
   */
  readonly fields: FavoriteContractorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FavoriteContractor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteContractorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contractor<T extends ContractorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractorDefaultArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FavoriteContractor model
   */
  interface FavoriteContractorFieldRefs {
    readonly id: FieldRef<"FavoriteContractor", 'Int'>
    readonly clientId: FieldRef<"FavoriteContractor", 'Int'>
    readonly contractorId: FieldRef<"FavoriteContractor", 'Int'>
    readonly createdAt: FieldRef<"FavoriteContractor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FavoriteContractor findUnique
   */
  export type FavoriteContractorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteContractor
     */
    select?: FavoriteContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteContractor
     */
    omit?: FavoriteContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteContractorInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteContractor to fetch.
     */
    where: FavoriteContractorWhereUniqueInput
  }

  /**
   * FavoriteContractor findUniqueOrThrow
   */
  export type FavoriteContractorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteContractor
     */
    select?: FavoriteContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteContractor
     */
    omit?: FavoriteContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteContractorInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteContractor to fetch.
     */
    where: FavoriteContractorWhereUniqueInput
  }

  /**
   * FavoriteContractor findFirst
   */
  export type FavoriteContractorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteContractor
     */
    select?: FavoriteContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteContractor
     */
    omit?: FavoriteContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteContractorInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteContractor to fetch.
     */
    where?: FavoriteContractorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteContractors to fetch.
     */
    orderBy?: FavoriteContractorOrderByWithRelationInput | FavoriteContractorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavoriteContractors.
     */
    cursor?: FavoriteContractorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteContractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteContractors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavoriteContractors.
     */
    distinct?: FavoriteContractorScalarFieldEnum | FavoriteContractorScalarFieldEnum[]
  }

  /**
   * FavoriteContractor findFirstOrThrow
   */
  export type FavoriteContractorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteContractor
     */
    select?: FavoriteContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteContractor
     */
    omit?: FavoriteContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteContractorInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteContractor to fetch.
     */
    where?: FavoriteContractorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteContractors to fetch.
     */
    orderBy?: FavoriteContractorOrderByWithRelationInput | FavoriteContractorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavoriteContractors.
     */
    cursor?: FavoriteContractorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteContractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteContractors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavoriteContractors.
     */
    distinct?: FavoriteContractorScalarFieldEnum | FavoriteContractorScalarFieldEnum[]
  }

  /**
   * FavoriteContractor findMany
   */
  export type FavoriteContractorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteContractor
     */
    select?: FavoriteContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteContractor
     */
    omit?: FavoriteContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteContractorInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteContractors to fetch.
     */
    where?: FavoriteContractorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteContractors to fetch.
     */
    orderBy?: FavoriteContractorOrderByWithRelationInput | FavoriteContractorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FavoriteContractors.
     */
    cursor?: FavoriteContractorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteContractors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteContractors.
     */
    skip?: number
    distinct?: FavoriteContractorScalarFieldEnum | FavoriteContractorScalarFieldEnum[]
  }

  /**
   * FavoriteContractor create
   */
  export type FavoriteContractorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteContractor
     */
    select?: FavoriteContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteContractor
     */
    omit?: FavoriteContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteContractorInclude<ExtArgs> | null
    /**
     * The data needed to create a FavoriteContractor.
     */
    data: XOR<FavoriteContractorCreateInput, FavoriteContractorUncheckedCreateInput>
  }

  /**
   * FavoriteContractor createMany
   */
  export type FavoriteContractorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FavoriteContractors.
     */
    data: FavoriteContractorCreateManyInput | FavoriteContractorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FavoriteContractor createManyAndReturn
   */
  export type FavoriteContractorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteContractor
     */
    select?: FavoriteContractorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteContractor
     */
    omit?: FavoriteContractorOmit<ExtArgs> | null
    /**
     * The data used to create many FavoriteContractors.
     */
    data: FavoriteContractorCreateManyInput | FavoriteContractorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteContractorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FavoriteContractor update
   */
  export type FavoriteContractorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteContractor
     */
    select?: FavoriteContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteContractor
     */
    omit?: FavoriteContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteContractorInclude<ExtArgs> | null
    /**
     * The data needed to update a FavoriteContractor.
     */
    data: XOR<FavoriteContractorUpdateInput, FavoriteContractorUncheckedUpdateInput>
    /**
     * Choose, which FavoriteContractor to update.
     */
    where: FavoriteContractorWhereUniqueInput
  }

  /**
   * FavoriteContractor updateMany
   */
  export type FavoriteContractorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FavoriteContractors.
     */
    data: XOR<FavoriteContractorUpdateManyMutationInput, FavoriteContractorUncheckedUpdateManyInput>
    /**
     * Filter which FavoriteContractors to update
     */
    where?: FavoriteContractorWhereInput
    /**
     * Limit how many FavoriteContractors to update.
     */
    limit?: number
  }

  /**
   * FavoriteContractor updateManyAndReturn
   */
  export type FavoriteContractorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteContractor
     */
    select?: FavoriteContractorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteContractor
     */
    omit?: FavoriteContractorOmit<ExtArgs> | null
    /**
     * The data used to update FavoriteContractors.
     */
    data: XOR<FavoriteContractorUpdateManyMutationInput, FavoriteContractorUncheckedUpdateManyInput>
    /**
     * Filter which FavoriteContractors to update
     */
    where?: FavoriteContractorWhereInput
    /**
     * Limit how many FavoriteContractors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteContractorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FavoriteContractor upsert
   */
  export type FavoriteContractorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteContractor
     */
    select?: FavoriteContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteContractor
     */
    omit?: FavoriteContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteContractorInclude<ExtArgs> | null
    /**
     * The filter to search for the FavoriteContractor to update in case it exists.
     */
    where: FavoriteContractorWhereUniqueInput
    /**
     * In case the FavoriteContractor found by the `where` argument doesn't exist, create a new FavoriteContractor with this data.
     */
    create: XOR<FavoriteContractorCreateInput, FavoriteContractorUncheckedCreateInput>
    /**
     * In case the FavoriteContractor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteContractorUpdateInput, FavoriteContractorUncheckedUpdateInput>
  }

  /**
   * FavoriteContractor delete
   */
  export type FavoriteContractorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteContractor
     */
    select?: FavoriteContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteContractor
     */
    omit?: FavoriteContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteContractorInclude<ExtArgs> | null
    /**
     * Filter which FavoriteContractor to delete.
     */
    where: FavoriteContractorWhereUniqueInput
  }

  /**
   * FavoriteContractor deleteMany
   */
  export type FavoriteContractorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavoriteContractors to delete
     */
    where?: FavoriteContractorWhereInput
    /**
     * Limit how many FavoriteContractors to delete.
     */
    limit?: number
  }

  /**
   * FavoriteContractor without action
   */
  export type FavoriteContractorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteContractor
     */
    select?: FavoriteContractorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteContractor
     */
    omit?: FavoriteContractorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteContractorInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    id: number | null
    contractorId: number | null
    price: number | null
  }

  export type MaterialSumAggregateOutputType = {
    id: number | null
    contractorId: number | null
    price: number | null
  }

  export type MaterialMinAggregateOutputType = {
    id: number | null
    contractorId: number | null
    name: string | null
    price: number | null
    unit: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: number | null
    contractorId: number | null
    name: string | null
    price: number | null
    unit: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    contractorId: number
    name: number
    price: number
    unit: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    id?: true
    contractorId?: true
    price?: true
  }

  export type MaterialSumAggregateInputType = {
    id?: true
    contractorId?: true
    price?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    contractorId?: true
    name?: true
    price?: true
    unit?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    contractorId?: true
    name?: true
    price?: true
    unit?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    contractorId?: true
    name?: true
    price?: true
    unit?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: number
    contractorId: number
    name: string
    price: number
    unit: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    name?: boolean
    price?: boolean
    unit?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    name?: boolean
    price?: boolean
    unit?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractorId?: boolean
    name?: boolean
    price?: boolean
    unit?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    contractorId?: boolean
    name?: boolean
    price?: boolean
    unit?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractorId" | "name" | "price" | "unit" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["material"]>
  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractor?: boolean | ContractorDefaultArgs<ExtArgs>
  }

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      contractor: Prisma.$ContractorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contractorId: number
      name: string
      price: number
      unit: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials and returns the data updated in the database.
     * @param {MaterialUpdateManyAndReturnArgs} args - Arguments to update many Materials.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contractor<T extends ContractorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractorDefaultArgs<ExtArgs>>): Prisma__ContractorClient<$Result.GetResult<Prisma.$ContractorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'Int'>
    readonly contractorId: FieldRef<"Material", 'Int'>
    readonly name: FieldRef<"Material", 'String'>
    readonly price: FieldRef<"Material", 'Float'>
    readonly unit: FieldRef<"Material", 'String'>
    readonly description: FieldRef<"Material", 'String'>
    readonly createdAt: FieldRef<"Material", 'DateTime'>
    readonly updatedAt: FieldRef<"Material", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
  }

  /**
   * Material updateManyAndReturn
   */
  export type MaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to delete.
     */
    limit?: number
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ActivityLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    details: string | null
    severity: $Enums.ActivitySeverity | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    details: string | null
    severity: $Enums.ActivitySeverity | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    details: number
    severity: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ActivityLogAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ActivityLogSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    severity?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    severity?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    severity?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _avg?: ActivityLogAvgAggregateInputType
    _sum?: ActivityLogSumAggregateInputType
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: number
    userId: number | null
    action: string
    details: string
    severity: $Enums.ActivitySeverity
    metadata: JsonValue | null
    createdAt: Date
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    severity?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    severity?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    severity?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    severity?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "details" | "severity" | "metadata" | "createdAt", ExtArgs["result"]["activityLog"]>

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      action: string
      details: string
      severity: $Enums.ActivitySeverity
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'Int'>
    readonly userId: FieldRef<"ActivityLog", 'Int'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly details: FieldRef<"ActivityLog", 'String'>
    readonly severity: FieldRef<"ActivityLog", 'ActivitySeverity'>
    readonly metadata: FieldRef<"ActivityLog", 'Json'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    type: 'type',
    authProvider: 'authProvider',
    googleId: 'googleId',
    facebookId: 'facebookId',
    phoneNumber: 'phoneNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    address: 'address',
    city: 'city',
    state: 'state',
    zip: 'zip',
    notificationEmail: 'notificationEmail',
    notificationSms: 'notificationSms',
    profilePicture: 'profilePicture',
    isActive: 'isActive',
    isBanned: 'isBanned',
    suspendedUntil: 'suspendedUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ContractorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    name: 'name',
    email: 'email',
    phone: 'phone',
    description: 'description',
    yearsInBusiness: 'yearsInBusiness',
    location: 'location',
    googleBusinessUrl: 'googleBusinessUrl',
    verified: 'verified',
    licensed: 'licensed',
    insured: 'insured',
    afterHoursAvailable: 'afterHoursAvailable',
    speaksSpanish: 'speaksSpanish',
    hourlyRate: 'hourlyRate',
    taxRate: 'taxRate',
    rating: 'rating',
    reviewCount: 'reviewCount',
    profilePicture: 'profilePicture',
    isActive: 'isActive',
    isBanned: 'isBanned',
    suspendedUntil: 'suspendedUntil',
    stripeAccountId: 'stripeAccountId',
    stripeOnboardingComplete: 'stripeOnboardingComplete',
    stripeChargesEnabled: 'stripeChargesEnabled',
    stripePayoutsEnabled: 'stripePayoutsEnabled',
    bookingPageSlug: 'bookingPageSlug',
    bookingPageEnabled: 'bookingPageEnabled',
    bookingPagePrimaryColor: 'bookingPagePrimaryColor',
    bookingPageAccentColor: 'bookingPageAccentColor',
    bookingPageTagline: 'bookingPageTagline',
    bookingPageLogo: 'bookingPageLogo',
    bookingPageShowReviews: 'bookingPageShowReviews',
    bookingPageShowPrices: 'bookingPageShowPrices',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContractorScalarFieldEnum = (typeof ContractorScalarFieldEnum)[keyof typeof ContractorScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    contractorId: 'contractorId',
    tier: 'tier',
    status: 'status',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    stripePriceId: 'stripePriceId',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    canceledAt: 'canceledAt',
    trialStart: 'trialStart',
    trialEnd: 'trialEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    flag: 'flag',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const ContractorLanguageScalarFieldEnum: {
    id: 'id',
    contractorId: 'contractorId',
    languageId: 'languageId',
    createdAt: 'createdAt'
  };

  export type ContractorLanguageScalarFieldEnum = (typeof ContractorLanguageScalarFieldEnum)[keyof typeof ContractorLanguageScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ContractorServiceScalarFieldEnum: {
    id: 'id',
    contractorId: 'contractorId',
    serviceId: 'serviceId',
    basePrice: 'basePrice',
    createdAt: 'createdAt'
  };

  export type ContractorServiceScalarFieldEnum = (typeof ContractorServiceScalarFieldEnum)[keyof typeof ContractorServiceScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    contractorId: 'contractorId',
    clientId: 'clientId',
    serviceId: 'serviceId',
    serviceAddress: 'serviceAddress',
    scheduledDate: 'scheduledDate',
    scheduledTime: 'scheduledTime',
    estimatedDuration: 'estimatedDuration',
    status: 'status',
    price: 'price',
    paymentReceived: 'paymentReceived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const JobCompletionScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    startTime: 'startTime',
    endTime: 'endTime',
    materials: 'materials',
    notes: 'notes',
    audioNoteUrl: 'audioNoteUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobCompletionScalarFieldEnum = (typeof JobCompletionScalarFieldEnum)[keyof typeof JobCompletionScalarFieldEnum]


  export const JobPhotoScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    filename: 'filename',
    originalName: 'originalName',
    photoType: 'photoType',
    fileSize: 'fileSize',
    url: 'url',
    createdAt: 'createdAt'
  };

  export type JobPhotoScalarFieldEnum = (typeof JobPhotoScalarFieldEnum)[keyof typeof JobPhotoScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    contractorId: 'contractorId',
    clientId: 'clientId',
    subject: 'subject',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    sender: 'sender',
    messageText: 'messageText',
    createdAt: 'createdAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const FlaggedMessageScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    messageText: 'messageText',
    flaggedBy: 'flaggedBy',
    flaggedById: 'flaggedById',
    contractorId: 'contractorId',
    clientId: 'clientId',
    reason: 'reason',
    details: 'details',
    status: 'status',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt'
  };

  export type FlaggedMessageScalarFieldEnum = (typeof FlaggedMessageScalarFieldEnum)[keyof typeof FlaggedMessageScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    type: 'type',
    reporterType: 'reporterType',
    reporterId: 'reporterId',
    reportedUserId: 'reportedUserId',
    reportedUserType: 'reportedUserType',
    bookingId: 'bookingId',
    reason: 'reason',
    description: 'description',
    evidence: 'evidence',
    status: 'status',
    priority: 'priority',
    assignedTo: 'assignedTo',
    resolution: 'resolution',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    contractorId: 'contractorId',
    clientId: 'clientId',
    rating: 'rating',
    reviewText: 'reviewText',
    createdAt: 'createdAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    amount: 'amount',
    taxAmount: 'taxAmount',
    totalAmount: 'totalAmount',
    status: 'status',
    dueDate: 'dueDate',
    paidAt: 'paidAt',
    stripePaymentIntentId: 'stripePaymentIntentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    invoiceId: 'invoiceId',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    stripePaymentId: 'stripePaymentId',
    stripePaymentIntent: 'stripePaymentIntent',
    platformFee: 'platformFee',
    contractorPayout: 'contractorPayout',
    stripeTransferId: 'stripeTransferId',
    status: 'status',
    paidAt: 'paidAt',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const AvailabilityScalarFieldEnum: {
    id: 'id',
    contractorId: 'contractorId',
    dayOfWeek: 'dayOfWeek',
    specificDate: 'specificDate',
    startTime: 'startTime',
    endTime: 'endTime',
    maxBookings: 'maxBookings',
    isAvailable: 'isAvailable',
    isRecurring: 'isRecurring',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AvailabilityScalarFieldEnum = (typeof AvailabilityScalarFieldEnum)[keyof typeof AvailabilityScalarFieldEnum]


  export const TimeSlotScalarFieldEnum: {
    id: 'id',
    contractorId: 'contractorId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    slotType: 'slotType',
    bookingId: 'bookingId',
    reason: 'reason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimeSlotScalarFieldEnum = (typeof TimeSlotScalarFieldEnum)[keyof typeof TimeSlotScalarFieldEnum]


  export const ServiceAreaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    state: 'state',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceAreaScalarFieldEnum = (typeof ServiceAreaScalarFieldEnum)[keyof typeof ServiceAreaScalarFieldEnum]


  export const ContractorServiceAreaScalarFieldEnum: {
    id: 'id',
    contractorId: 'contractorId',
    dayOfWeek: 'dayOfWeek',
    area: 'area',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContractorServiceAreaScalarFieldEnum = (typeof ContractorServiceAreaScalarFieldEnum)[keyof typeof ContractorServiceAreaScalarFieldEnum]


  export const FavoriteContractorScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    contractorId: 'contractorId',
    createdAt: 'createdAt'
  };

  export type FavoriteContractorScalarFieldEnum = (typeof FavoriteContractorScalarFieldEnum)[keyof typeof FavoriteContractorScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    contractorId: 'contractorId',
    name: 'name',
    price: 'price',
    unit: 'unit',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    details: 'details',
    severity: 'severity',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'AuthProvider'
   */
  export type EnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider'>
    


  /**
   * Reference to a field of type 'AuthProvider[]'
   */
  export type ListEnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'SubscriptionTier'
   */
  export type EnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier'>
    


  /**
   * Reference to a field of type 'SubscriptionTier[]'
   */
  export type ListEnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'PhotoType'
   */
  export type EnumPhotoTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhotoType'>
    


  /**
   * Reference to a field of type 'PhotoType[]'
   */
  export type ListEnumPhotoTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhotoType[]'>
    


  /**
   * Reference to a field of type 'MessageStatus'
   */
  export type EnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus'>
    


  /**
   * Reference to a field of type 'MessageStatus[]'
   */
  export type ListEnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus[]'>
    


  /**
   * Reference to a field of type 'SenderType'
   */
  export type EnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType'>
    


  /**
   * Reference to a field of type 'SenderType[]'
   */
  export type ListEnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType[]'>
    


  /**
   * Reference to a field of type 'FlaggedByType'
   */
  export type EnumFlaggedByTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlaggedByType'>
    


  /**
   * Reference to a field of type 'FlaggedByType[]'
   */
  export type ListEnumFlaggedByTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlaggedByType[]'>
    


  /**
   * Reference to a field of type 'FlagStatus'
   */
  export type EnumFlagStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlagStatus'>
    


  /**
   * Reference to a field of type 'FlagStatus[]'
   */
  export type ListEnumFlagStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlagStatus[]'>
    


  /**
   * Reference to a field of type 'ReportType'
   */
  export type EnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType'>
    


  /**
   * Reference to a field of type 'ReportType[]'
   */
  export type ListEnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType[]'>
    


  /**
   * Reference to a field of type 'ReporterType'
   */
  export type EnumReporterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReporterType'>
    


  /**
   * Reference to a field of type 'ReporterType[]'
   */
  export type ListEnumReporterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReporterType[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    


  /**
   * Reference to a field of type 'ReportPriority'
   */
  export type EnumReportPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportPriority'>
    


  /**
   * Reference to a field of type 'ReportPriority[]'
   */
  export type ListEnumReportPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportPriority[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'SlotType'
   */
  export type EnumSlotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SlotType'>
    


  /**
   * Reference to a field of type 'SlotType[]'
   */
  export type ListEnumSlotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SlotType[]'>
    


  /**
   * Reference to a field of type 'ActivitySeverity'
   */
  export type EnumActivitySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivitySeverity'>
    


  /**
   * Reference to a field of type 'ActivitySeverity[]'
   */
  export type ListEnumActivitySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivitySeverity[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    type?: EnumUserTypeFilter<"User"> | $Enums.UserType
    authProvider?: EnumAuthProviderFilter<"User"> | $Enums.AuthProvider
    googleId?: StringNullableFilter<"User"> | string | null
    facebookId?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    contractor?: XOR<ContractorNullableScalarRelationFilter, ContractorWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    type?: SortOrder
    authProvider?: SortOrder
    googleId?: SortOrderInput | SortOrder
    facebookId?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    contractor?: ContractorOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    googleId?: string
    facebookId?: string
    phoneNumber?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    type?: EnumUserTypeFilter<"User"> | $Enums.UserType
    authProvider?: EnumAuthProviderFilter<"User"> | $Enums.AuthProvider
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    contractor?: XOR<ContractorNullableScalarRelationFilter, ContractorWhereInput> | null
  }, "id" | "username" | "googleId" | "facebookId" | "phoneNumber">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    type?: SortOrder
    authProvider?: SortOrder
    googleId?: SortOrderInput | SortOrder
    facebookId?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    type?: EnumUserTypeWithAggregatesFilter<"User"> | $Enums.UserType
    authProvider?: EnumAuthProviderWithAggregatesFilter<"User"> | $Enums.AuthProvider
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    facebookId?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: IntFilter<"Client"> | number
    userId?: IntFilter<"Client"> | number
    firstName?: StringFilter<"Client"> | string
    lastName?: StringFilter<"Client"> | string
    email?: StringFilter<"Client"> | string
    phone?: StringFilter<"Client"> | string
    address?: StringNullableFilter<"Client"> | string | null
    city?: StringNullableFilter<"Client"> | string | null
    state?: StringNullableFilter<"Client"> | string | null
    zip?: StringNullableFilter<"Client"> | string | null
    notificationEmail?: BoolFilter<"Client"> | boolean
    notificationSms?: BoolFilter<"Client"> | boolean
    profilePicture?: StringNullableFilter<"Client"> | string | null
    isActive?: BoolFilter<"Client"> | boolean
    isBanned?: BoolFilter<"Client"> | boolean
    suspendedUntil?: DateTimeNullableFilter<"Client"> | Date | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    messages?: MessageListRelationFilter
    flaggedMessages?: FlaggedMessageListRelationFilter
    favorites?: FavoriteContractorListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    notificationEmail?: SortOrder
    notificationSms?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    suspendedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    flaggedMessages?: FlaggedMessageOrderByRelationAggregateInput
    favorites?: FavoriteContractorOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    email?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    firstName?: StringFilter<"Client"> | string
    lastName?: StringFilter<"Client"> | string
    phone?: StringFilter<"Client"> | string
    address?: StringNullableFilter<"Client"> | string | null
    city?: StringNullableFilter<"Client"> | string | null
    state?: StringNullableFilter<"Client"> | string | null
    zip?: StringNullableFilter<"Client"> | string | null
    notificationEmail?: BoolFilter<"Client"> | boolean
    notificationSms?: BoolFilter<"Client"> | boolean
    profilePicture?: StringNullableFilter<"Client"> | string | null
    isActive?: BoolFilter<"Client"> | boolean
    isBanned?: BoolFilter<"Client"> | boolean
    suspendedUntil?: DateTimeNullableFilter<"Client"> | Date | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    messages?: MessageListRelationFilter
    flaggedMessages?: FlaggedMessageListRelationFilter
    favorites?: FavoriteContractorListRelationFilter
  }, "id" | "userId" | "email">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    notificationEmail?: SortOrder
    notificationSms?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    suspendedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Client"> | number
    userId?: IntWithAggregatesFilter<"Client"> | number
    firstName?: StringWithAggregatesFilter<"Client"> | string
    lastName?: StringWithAggregatesFilter<"Client"> | string
    email?: StringWithAggregatesFilter<"Client"> | string
    phone?: StringWithAggregatesFilter<"Client"> | string
    address?: StringNullableWithAggregatesFilter<"Client"> | string | null
    city?: StringNullableWithAggregatesFilter<"Client"> | string | null
    state?: StringNullableWithAggregatesFilter<"Client"> | string | null
    zip?: StringNullableWithAggregatesFilter<"Client"> | string | null
    notificationEmail?: BoolWithAggregatesFilter<"Client"> | boolean
    notificationSms?: BoolWithAggregatesFilter<"Client"> | boolean
    profilePicture?: StringNullableWithAggregatesFilter<"Client"> | string | null
    isActive?: BoolWithAggregatesFilter<"Client"> | boolean
    isBanned?: BoolWithAggregatesFilter<"Client"> | boolean
    suspendedUntil?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type ContractorWhereInput = {
    AND?: ContractorWhereInput | ContractorWhereInput[]
    OR?: ContractorWhereInput[]
    NOT?: ContractorWhereInput | ContractorWhereInput[]
    id?: IntFilter<"Contractor"> | number
    userId?: IntFilter<"Contractor"> | number
    firstName?: StringNullableFilter<"Contractor"> | string | null
    lastName?: StringNullableFilter<"Contractor"> | string | null
    name?: StringFilter<"Contractor"> | string
    email?: StringNullableFilter<"Contractor"> | string | null
    phone?: StringNullableFilter<"Contractor"> | string | null
    description?: StringNullableFilter<"Contractor"> | string | null
    yearsInBusiness?: IntNullableFilter<"Contractor"> | number | null
    location?: StringNullableFilter<"Contractor"> | string | null
    googleBusinessUrl?: StringNullableFilter<"Contractor"> | string | null
    verified?: BoolFilter<"Contractor"> | boolean
    licensed?: BoolFilter<"Contractor"> | boolean
    insured?: BoolFilter<"Contractor"> | boolean
    afterHoursAvailable?: BoolFilter<"Contractor"> | boolean
    speaksSpanish?: BoolFilter<"Contractor"> | boolean
    hourlyRate?: FloatNullableFilter<"Contractor"> | number | null
    taxRate?: FloatNullableFilter<"Contractor"> | number | null
    rating?: FloatFilter<"Contractor"> | number
    reviewCount?: IntFilter<"Contractor"> | number
    profilePicture?: StringNullableFilter<"Contractor"> | string | null
    isActive?: BoolFilter<"Contractor"> | boolean
    isBanned?: BoolFilter<"Contractor"> | boolean
    suspendedUntil?: DateTimeNullableFilter<"Contractor"> | Date | string | null
    stripeAccountId?: StringNullableFilter<"Contractor"> | string | null
    stripeOnboardingComplete?: BoolFilter<"Contractor"> | boolean
    stripeChargesEnabled?: BoolFilter<"Contractor"> | boolean
    stripePayoutsEnabled?: BoolFilter<"Contractor"> | boolean
    bookingPageSlug?: StringNullableFilter<"Contractor"> | string | null
    bookingPageEnabled?: BoolFilter<"Contractor"> | boolean
    bookingPagePrimaryColor?: StringNullableFilter<"Contractor"> | string | null
    bookingPageAccentColor?: StringNullableFilter<"Contractor"> | string | null
    bookingPageTagline?: StringNullableFilter<"Contractor"> | string | null
    bookingPageLogo?: StringNullableFilter<"Contractor"> | string | null
    bookingPageShowReviews?: BoolFilter<"Contractor"> | boolean
    bookingPageShowPrices?: BoolFilter<"Contractor"> | boolean
    createdAt?: DateTimeFilter<"Contractor"> | Date | string
    updatedAt?: DateTimeFilter<"Contractor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    services?: ContractorServiceListRelationFilter
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    messages?: MessageListRelationFilter
    availability?: AvailabilityListRelationFilter
    timeSlots?: TimeSlotListRelationFilter
    serviceAreas?: ContractorServiceAreaListRelationFilter
    flaggedMessages?: FlaggedMessageListRelationFilter
    favoritedBy?: FavoriteContractorListRelationFilter
    materials?: MaterialListRelationFilter
    languages?: ContractorLanguageListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
  }

  export type ContractorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    yearsInBusiness?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    googleBusinessUrl?: SortOrderInput | SortOrder
    verified?: SortOrder
    licensed?: SortOrder
    insured?: SortOrder
    afterHoursAvailable?: SortOrder
    speaksSpanish?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    suspendedUntil?: SortOrderInput | SortOrder
    stripeAccountId?: SortOrderInput | SortOrder
    stripeOnboardingComplete?: SortOrder
    stripeChargesEnabled?: SortOrder
    stripePayoutsEnabled?: SortOrder
    bookingPageSlug?: SortOrderInput | SortOrder
    bookingPageEnabled?: SortOrder
    bookingPagePrimaryColor?: SortOrderInput | SortOrder
    bookingPageAccentColor?: SortOrderInput | SortOrder
    bookingPageTagline?: SortOrderInput | SortOrder
    bookingPageLogo?: SortOrderInput | SortOrder
    bookingPageShowReviews?: SortOrder
    bookingPageShowPrices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    services?: ContractorServiceOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    availability?: AvailabilityOrderByRelationAggregateInput
    timeSlots?: TimeSlotOrderByRelationAggregateInput
    serviceAreas?: ContractorServiceAreaOrderByRelationAggregateInput
    flaggedMessages?: FlaggedMessageOrderByRelationAggregateInput
    favoritedBy?: FavoriteContractorOrderByRelationAggregateInput
    materials?: MaterialOrderByRelationAggregateInput
    languages?: ContractorLanguageOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type ContractorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    stripeAccountId?: string
    bookingPageSlug?: string
    AND?: ContractorWhereInput | ContractorWhereInput[]
    OR?: ContractorWhereInput[]
    NOT?: ContractorWhereInput | ContractorWhereInput[]
    firstName?: StringNullableFilter<"Contractor"> | string | null
    lastName?: StringNullableFilter<"Contractor"> | string | null
    name?: StringFilter<"Contractor"> | string
    email?: StringNullableFilter<"Contractor"> | string | null
    phone?: StringNullableFilter<"Contractor"> | string | null
    description?: StringNullableFilter<"Contractor"> | string | null
    yearsInBusiness?: IntNullableFilter<"Contractor"> | number | null
    location?: StringNullableFilter<"Contractor"> | string | null
    googleBusinessUrl?: StringNullableFilter<"Contractor"> | string | null
    verified?: BoolFilter<"Contractor"> | boolean
    licensed?: BoolFilter<"Contractor"> | boolean
    insured?: BoolFilter<"Contractor"> | boolean
    afterHoursAvailable?: BoolFilter<"Contractor"> | boolean
    speaksSpanish?: BoolFilter<"Contractor"> | boolean
    hourlyRate?: FloatNullableFilter<"Contractor"> | number | null
    taxRate?: FloatNullableFilter<"Contractor"> | number | null
    rating?: FloatFilter<"Contractor"> | number
    reviewCount?: IntFilter<"Contractor"> | number
    profilePicture?: StringNullableFilter<"Contractor"> | string | null
    isActive?: BoolFilter<"Contractor"> | boolean
    isBanned?: BoolFilter<"Contractor"> | boolean
    suspendedUntil?: DateTimeNullableFilter<"Contractor"> | Date | string | null
    stripeOnboardingComplete?: BoolFilter<"Contractor"> | boolean
    stripeChargesEnabled?: BoolFilter<"Contractor"> | boolean
    stripePayoutsEnabled?: BoolFilter<"Contractor"> | boolean
    bookingPageEnabled?: BoolFilter<"Contractor"> | boolean
    bookingPagePrimaryColor?: StringNullableFilter<"Contractor"> | string | null
    bookingPageAccentColor?: StringNullableFilter<"Contractor"> | string | null
    bookingPageTagline?: StringNullableFilter<"Contractor"> | string | null
    bookingPageLogo?: StringNullableFilter<"Contractor"> | string | null
    bookingPageShowReviews?: BoolFilter<"Contractor"> | boolean
    bookingPageShowPrices?: BoolFilter<"Contractor"> | boolean
    createdAt?: DateTimeFilter<"Contractor"> | Date | string
    updatedAt?: DateTimeFilter<"Contractor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    services?: ContractorServiceListRelationFilter
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    messages?: MessageListRelationFilter
    availability?: AvailabilityListRelationFilter
    timeSlots?: TimeSlotListRelationFilter
    serviceAreas?: ContractorServiceAreaListRelationFilter
    flaggedMessages?: FlaggedMessageListRelationFilter
    favoritedBy?: FavoriteContractorListRelationFilter
    materials?: MaterialListRelationFilter
    languages?: ContractorLanguageListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
  }, "id" | "userId" | "stripeAccountId" | "bookingPageSlug">

  export type ContractorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    yearsInBusiness?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    googleBusinessUrl?: SortOrderInput | SortOrder
    verified?: SortOrder
    licensed?: SortOrder
    insured?: SortOrder
    afterHoursAvailable?: SortOrder
    speaksSpanish?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    suspendedUntil?: SortOrderInput | SortOrder
    stripeAccountId?: SortOrderInput | SortOrder
    stripeOnboardingComplete?: SortOrder
    stripeChargesEnabled?: SortOrder
    stripePayoutsEnabled?: SortOrder
    bookingPageSlug?: SortOrderInput | SortOrder
    bookingPageEnabled?: SortOrder
    bookingPagePrimaryColor?: SortOrderInput | SortOrder
    bookingPageAccentColor?: SortOrderInput | SortOrder
    bookingPageTagline?: SortOrderInput | SortOrder
    bookingPageLogo?: SortOrderInput | SortOrder
    bookingPageShowReviews?: SortOrder
    bookingPageShowPrices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContractorCountOrderByAggregateInput
    _avg?: ContractorAvgOrderByAggregateInput
    _max?: ContractorMaxOrderByAggregateInput
    _min?: ContractorMinOrderByAggregateInput
    _sum?: ContractorSumOrderByAggregateInput
  }

  export type ContractorScalarWhereWithAggregatesInput = {
    AND?: ContractorScalarWhereWithAggregatesInput | ContractorScalarWhereWithAggregatesInput[]
    OR?: ContractorScalarWhereWithAggregatesInput[]
    NOT?: ContractorScalarWhereWithAggregatesInput | ContractorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contractor"> | number
    userId?: IntWithAggregatesFilter<"Contractor"> | number
    firstName?: StringNullableWithAggregatesFilter<"Contractor"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Contractor"> | string | null
    name?: StringWithAggregatesFilter<"Contractor"> | string
    email?: StringNullableWithAggregatesFilter<"Contractor"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Contractor"> | string | null
    description?: StringNullableWithAggregatesFilter<"Contractor"> | string | null
    yearsInBusiness?: IntNullableWithAggregatesFilter<"Contractor"> | number | null
    location?: StringNullableWithAggregatesFilter<"Contractor"> | string | null
    googleBusinessUrl?: StringNullableWithAggregatesFilter<"Contractor"> | string | null
    verified?: BoolWithAggregatesFilter<"Contractor"> | boolean
    licensed?: BoolWithAggregatesFilter<"Contractor"> | boolean
    insured?: BoolWithAggregatesFilter<"Contractor"> | boolean
    afterHoursAvailable?: BoolWithAggregatesFilter<"Contractor"> | boolean
    speaksSpanish?: BoolWithAggregatesFilter<"Contractor"> | boolean
    hourlyRate?: FloatNullableWithAggregatesFilter<"Contractor"> | number | null
    taxRate?: FloatNullableWithAggregatesFilter<"Contractor"> | number | null
    rating?: FloatWithAggregatesFilter<"Contractor"> | number
    reviewCount?: IntWithAggregatesFilter<"Contractor"> | number
    profilePicture?: StringNullableWithAggregatesFilter<"Contractor"> | string | null
    isActive?: BoolWithAggregatesFilter<"Contractor"> | boolean
    isBanned?: BoolWithAggregatesFilter<"Contractor"> | boolean
    suspendedUntil?: DateTimeNullableWithAggregatesFilter<"Contractor"> | Date | string | null
    stripeAccountId?: StringNullableWithAggregatesFilter<"Contractor"> | string | null
    stripeOnboardingComplete?: BoolWithAggregatesFilter<"Contractor"> | boolean
    stripeChargesEnabled?: BoolWithAggregatesFilter<"Contractor"> | boolean
    stripePayoutsEnabled?: BoolWithAggregatesFilter<"Contractor"> | boolean
    bookingPageSlug?: StringNullableWithAggregatesFilter<"Contractor"> | string | null
    bookingPageEnabled?: BoolWithAggregatesFilter<"Contractor"> | boolean
    bookingPagePrimaryColor?: StringNullableWithAggregatesFilter<"Contractor"> | string | null
    bookingPageAccentColor?: StringNullableWithAggregatesFilter<"Contractor"> | string | null
    bookingPageTagline?: StringNullableWithAggregatesFilter<"Contractor"> | string | null
    bookingPageLogo?: StringNullableWithAggregatesFilter<"Contractor"> | string | null
    bookingPageShowReviews?: BoolWithAggregatesFilter<"Contractor"> | boolean
    bookingPageShowPrices?: BoolWithAggregatesFilter<"Contractor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Contractor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contractor"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: IntFilter<"Subscription"> | number
    contractorId?: IntFilter<"Subscription"> | number
    tier?: EnumSubscriptionTierFilter<"Subscription"> | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    stripePriceId?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contractor?: ContractorOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    contractorId?: number
    stripeCustomerId?: string
    stripeSubscriptionId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    tier?: EnumSubscriptionTierFilter<"Subscription"> | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    stripePriceId?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
  }, "id" | "contractorId" | "stripeCustomerId" | "stripeSubscriptionId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subscription"> | number
    contractorId?: IntWithAggregatesFilter<"Subscription"> | number
    tier?: EnumSubscriptionTierWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripePriceId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    id?: IntFilter<"Language"> | number
    name?: StringFilter<"Language"> | string
    code?: StringFilter<"Language"> | string
    flag?: StringFilter<"Language"> | string
    isActive?: BoolFilter<"Language"> | boolean
    createdAt?: DateTimeFilter<"Language"> | Date | string
    contractors?: ContractorLanguageListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    flag?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    contractors?: ContractorLanguageOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    code?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    flag?: StringFilter<"Language"> | string
    isActive?: BoolFilter<"Language"> | boolean
    createdAt?: DateTimeFilter<"Language"> | Date | string
    contractors?: ContractorLanguageListRelationFilter
  }, "id" | "name" | "code">

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    flag?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _avg?: LanguageAvgOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
    _sum?: LanguageSumOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Language"> | number
    name?: StringWithAggregatesFilter<"Language"> | string
    code?: StringWithAggregatesFilter<"Language"> | string
    flag?: StringWithAggregatesFilter<"Language"> | string
    isActive?: BoolWithAggregatesFilter<"Language"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Language"> | Date | string
  }

  export type ContractorLanguageWhereInput = {
    AND?: ContractorLanguageWhereInput | ContractorLanguageWhereInput[]
    OR?: ContractorLanguageWhereInput[]
    NOT?: ContractorLanguageWhereInput | ContractorLanguageWhereInput[]
    id?: IntFilter<"ContractorLanguage"> | number
    contractorId?: IntFilter<"ContractorLanguage"> | number
    languageId?: IntFilter<"ContractorLanguage"> | number
    createdAt?: DateTimeFilter<"ContractorLanguage"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
    language?: XOR<LanguageScalarRelationFilter, LanguageWhereInput>
  }

  export type ContractorLanguageOrderByWithRelationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    languageId?: SortOrder
    createdAt?: SortOrder
    contractor?: ContractorOrderByWithRelationInput
    language?: LanguageOrderByWithRelationInput
  }

  export type ContractorLanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    contractorId_languageId?: ContractorLanguageContractorIdLanguageIdCompoundUniqueInput
    AND?: ContractorLanguageWhereInput | ContractorLanguageWhereInput[]
    OR?: ContractorLanguageWhereInput[]
    NOT?: ContractorLanguageWhereInput | ContractorLanguageWhereInput[]
    contractorId?: IntFilter<"ContractorLanguage"> | number
    languageId?: IntFilter<"ContractorLanguage"> | number
    createdAt?: DateTimeFilter<"ContractorLanguage"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
    language?: XOR<LanguageScalarRelationFilter, LanguageWhereInput>
  }, "id" | "contractorId_languageId">

  export type ContractorLanguageOrderByWithAggregationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    languageId?: SortOrder
    createdAt?: SortOrder
    _count?: ContractorLanguageCountOrderByAggregateInput
    _avg?: ContractorLanguageAvgOrderByAggregateInput
    _max?: ContractorLanguageMaxOrderByAggregateInput
    _min?: ContractorLanguageMinOrderByAggregateInput
    _sum?: ContractorLanguageSumOrderByAggregateInput
  }

  export type ContractorLanguageScalarWhereWithAggregatesInput = {
    AND?: ContractorLanguageScalarWhereWithAggregatesInput | ContractorLanguageScalarWhereWithAggregatesInput[]
    OR?: ContractorLanguageScalarWhereWithAggregatesInput[]
    NOT?: ContractorLanguageScalarWhereWithAggregatesInput | ContractorLanguageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContractorLanguage"> | number
    contractorId?: IntWithAggregatesFilter<"ContractorLanguage"> | number
    languageId?: IntWithAggregatesFilter<"ContractorLanguage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContractorLanguage"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: IntFilter<"Service"> | number
    name?: StringFilter<"Service"> | string
    icon?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    contractors?: ContractorServiceListRelationFilter
    bookings?: BookingListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    contractors?: ContractorServiceOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    icon?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    contractors?: ContractorServiceListRelationFilter
    bookings?: BookingListRelationFilter
  }, "id" | "name">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Service"> | number
    name?: StringWithAggregatesFilter<"Service"> | string
    icon?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type ContractorServiceWhereInput = {
    AND?: ContractorServiceWhereInput | ContractorServiceWhereInput[]
    OR?: ContractorServiceWhereInput[]
    NOT?: ContractorServiceWhereInput | ContractorServiceWhereInput[]
    id?: IntFilter<"ContractorService"> | number
    contractorId?: IntFilter<"ContractorService"> | number
    serviceId?: IntFilter<"ContractorService"> | number
    basePrice?: FloatNullableFilter<"ContractorService"> | number | null
    createdAt?: DateTimeFilter<"ContractorService"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type ContractorServiceOrderByWithRelationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    serviceId?: SortOrder
    basePrice?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    contractor?: ContractorOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type ContractorServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    contractorId_serviceId?: ContractorServiceContractorIdServiceIdCompoundUniqueInput
    AND?: ContractorServiceWhereInput | ContractorServiceWhereInput[]
    OR?: ContractorServiceWhereInput[]
    NOT?: ContractorServiceWhereInput | ContractorServiceWhereInput[]
    contractorId?: IntFilter<"ContractorService"> | number
    serviceId?: IntFilter<"ContractorService"> | number
    basePrice?: FloatNullableFilter<"ContractorService"> | number | null
    createdAt?: DateTimeFilter<"ContractorService"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id" | "contractorId_serviceId">

  export type ContractorServiceOrderByWithAggregationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    serviceId?: SortOrder
    basePrice?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ContractorServiceCountOrderByAggregateInput
    _avg?: ContractorServiceAvgOrderByAggregateInput
    _max?: ContractorServiceMaxOrderByAggregateInput
    _min?: ContractorServiceMinOrderByAggregateInput
    _sum?: ContractorServiceSumOrderByAggregateInput
  }

  export type ContractorServiceScalarWhereWithAggregatesInput = {
    AND?: ContractorServiceScalarWhereWithAggregatesInput | ContractorServiceScalarWhereWithAggregatesInput[]
    OR?: ContractorServiceScalarWhereWithAggregatesInput[]
    NOT?: ContractorServiceScalarWhereWithAggregatesInput | ContractorServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContractorService"> | number
    contractorId?: IntWithAggregatesFilter<"ContractorService"> | number
    serviceId?: IntWithAggregatesFilter<"ContractorService"> | number
    basePrice?: FloatNullableWithAggregatesFilter<"ContractorService"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ContractorService"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    contractorId?: IntFilter<"Booking"> | number
    clientId?: IntFilter<"Booking"> | number
    serviceId?: IntFilter<"Booking"> | number
    serviceAddress?: StringFilter<"Booking"> | string
    scheduledDate?: DateTimeFilter<"Booking"> | Date | string
    scheduledTime?: StringFilter<"Booking"> | string
    estimatedDuration?: IntNullableFilter<"Booking"> | number | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    price?: FloatNullableFilter<"Booking"> | number | null
    paymentReceived?: BoolFilter<"Booking"> | boolean
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    completion?: XOR<JobCompletionNullableScalarRelationFilter, JobCompletionWhereInput> | null
    photos?: JobPhotoListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    payments?: PaymentListRelationFilter
    reports?: ReportListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    serviceAddress?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    status?: SortOrder
    price?: SortOrderInput | SortOrder
    paymentReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contractor?: ContractorOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    completion?: JobCompletionOrderByWithRelationInput
    photos?: JobPhotoOrderByRelationAggregateInput
    invoice?: InvoiceOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    contractorId?: IntFilter<"Booking"> | number
    clientId?: IntFilter<"Booking"> | number
    serviceId?: IntFilter<"Booking"> | number
    serviceAddress?: StringFilter<"Booking"> | string
    scheduledDate?: DateTimeFilter<"Booking"> | Date | string
    scheduledTime?: StringFilter<"Booking"> | string
    estimatedDuration?: IntNullableFilter<"Booking"> | number | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    price?: FloatNullableFilter<"Booking"> | number | null
    paymentReceived?: BoolFilter<"Booking"> | boolean
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    completion?: XOR<JobCompletionNullableScalarRelationFilter, JobCompletionWhereInput> | null
    photos?: JobPhotoListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    payments?: PaymentListRelationFilter
    reports?: ReportListRelationFilter
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    serviceAddress?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    status?: SortOrder
    price?: SortOrderInput | SortOrder
    paymentReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    contractorId?: IntWithAggregatesFilter<"Booking"> | number
    clientId?: IntWithAggregatesFilter<"Booking"> | number
    serviceId?: IntWithAggregatesFilter<"Booking"> | number
    serviceAddress?: StringWithAggregatesFilter<"Booking"> | string
    scheduledDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    scheduledTime?: StringWithAggregatesFilter<"Booking"> | string
    estimatedDuration?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    price?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    paymentReceived?: BoolWithAggregatesFilter<"Booking"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type JobCompletionWhereInput = {
    AND?: JobCompletionWhereInput | JobCompletionWhereInput[]
    OR?: JobCompletionWhereInput[]
    NOT?: JobCompletionWhereInput | JobCompletionWhereInput[]
    id?: IntFilter<"JobCompletion"> | number
    bookingId?: IntFilter<"JobCompletion"> | number
    startTime?: DateTimeNullableFilter<"JobCompletion"> | Date | string | null
    endTime?: DateTimeNullableFilter<"JobCompletion"> | Date | string | null
    materials?: StringNullableFilter<"JobCompletion"> | string | null
    notes?: StringNullableFilter<"JobCompletion"> | string | null
    audioNoteUrl?: StringNullableFilter<"JobCompletion"> | string | null
    createdAt?: DateTimeFilter<"JobCompletion"> | Date | string
    updatedAt?: DateTimeFilter<"JobCompletion"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }

  export type JobCompletionOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    materials?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    audioNoteUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type JobCompletionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bookingId?: number
    AND?: JobCompletionWhereInput | JobCompletionWhereInput[]
    OR?: JobCompletionWhereInput[]
    NOT?: JobCompletionWhereInput | JobCompletionWhereInput[]
    startTime?: DateTimeNullableFilter<"JobCompletion"> | Date | string | null
    endTime?: DateTimeNullableFilter<"JobCompletion"> | Date | string | null
    materials?: StringNullableFilter<"JobCompletion"> | string | null
    notes?: StringNullableFilter<"JobCompletion"> | string | null
    audioNoteUrl?: StringNullableFilter<"JobCompletion"> | string | null
    createdAt?: DateTimeFilter<"JobCompletion"> | Date | string
    updatedAt?: DateTimeFilter<"JobCompletion"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }, "id" | "bookingId">

  export type JobCompletionOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    materials?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    audioNoteUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobCompletionCountOrderByAggregateInput
    _avg?: JobCompletionAvgOrderByAggregateInput
    _max?: JobCompletionMaxOrderByAggregateInput
    _min?: JobCompletionMinOrderByAggregateInput
    _sum?: JobCompletionSumOrderByAggregateInput
  }

  export type JobCompletionScalarWhereWithAggregatesInput = {
    AND?: JobCompletionScalarWhereWithAggregatesInput | JobCompletionScalarWhereWithAggregatesInput[]
    OR?: JobCompletionScalarWhereWithAggregatesInput[]
    NOT?: JobCompletionScalarWhereWithAggregatesInput | JobCompletionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JobCompletion"> | number
    bookingId?: IntWithAggregatesFilter<"JobCompletion"> | number
    startTime?: DateTimeNullableWithAggregatesFilter<"JobCompletion"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"JobCompletion"> | Date | string | null
    materials?: StringNullableWithAggregatesFilter<"JobCompletion"> | string | null
    notes?: StringNullableWithAggregatesFilter<"JobCompletion"> | string | null
    audioNoteUrl?: StringNullableWithAggregatesFilter<"JobCompletion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JobCompletion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobCompletion"> | Date | string
  }

  export type JobPhotoWhereInput = {
    AND?: JobPhotoWhereInput | JobPhotoWhereInput[]
    OR?: JobPhotoWhereInput[]
    NOT?: JobPhotoWhereInput | JobPhotoWhereInput[]
    id?: IntFilter<"JobPhoto"> | number
    bookingId?: IntFilter<"JobPhoto"> | number
    filename?: StringFilter<"JobPhoto"> | string
    originalName?: StringFilter<"JobPhoto"> | string
    photoType?: EnumPhotoTypeFilter<"JobPhoto"> | $Enums.PhotoType
    fileSize?: IntFilter<"JobPhoto"> | number
    url?: StringFilter<"JobPhoto"> | string
    createdAt?: DateTimeFilter<"JobPhoto"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }

  export type JobPhotoOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    photoType?: SortOrder
    fileSize?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type JobPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JobPhotoWhereInput | JobPhotoWhereInput[]
    OR?: JobPhotoWhereInput[]
    NOT?: JobPhotoWhereInput | JobPhotoWhereInput[]
    bookingId?: IntFilter<"JobPhoto"> | number
    filename?: StringFilter<"JobPhoto"> | string
    originalName?: StringFilter<"JobPhoto"> | string
    photoType?: EnumPhotoTypeFilter<"JobPhoto"> | $Enums.PhotoType
    fileSize?: IntFilter<"JobPhoto"> | number
    url?: StringFilter<"JobPhoto"> | string
    createdAt?: DateTimeFilter<"JobPhoto"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }, "id">

  export type JobPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    photoType?: SortOrder
    fileSize?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    _count?: JobPhotoCountOrderByAggregateInput
    _avg?: JobPhotoAvgOrderByAggregateInput
    _max?: JobPhotoMaxOrderByAggregateInput
    _min?: JobPhotoMinOrderByAggregateInput
    _sum?: JobPhotoSumOrderByAggregateInput
  }

  export type JobPhotoScalarWhereWithAggregatesInput = {
    AND?: JobPhotoScalarWhereWithAggregatesInput | JobPhotoScalarWhereWithAggregatesInput[]
    OR?: JobPhotoScalarWhereWithAggregatesInput[]
    NOT?: JobPhotoScalarWhereWithAggregatesInput | JobPhotoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JobPhoto"> | number
    bookingId?: IntWithAggregatesFilter<"JobPhoto"> | number
    filename?: StringWithAggregatesFilter<"JobPhoto"> | string
    originalName?: StringWithAggregatesFilter<"JobPhoto"> | string
    photoType?: EnumPhotoTypeWithAggregatesFilter<"JobPhoto"> | $Enums.PhotoType
    fileSize?: IntWithAggregatesFilter<"JobPhoto"> | number
    url?: StringWithAggregatesFilter<"JobPhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JobPhoto"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: IntFilter<"Message"> | number
    contractorId?: IntFilter<"Message"> | number
    clientId?: IntFilter<"Message"> | number
    subject?: StringNullableFilter<"Message"> | string | null
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    chatMessages?: ChatMessageListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    subject?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contractor?: ContractorOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    chatMessages?: ChatMessageOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    contractorId?: IntFilter<"Message"> | number
    clientId?: IntFilter<"Message"> | number
    subject?: StringNullableFilter<"Message"> | string | null
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    chatMessages?: ChatMessageListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    subject?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Message"> | number
    contractorId?: IntWithAggregatesFilter<"Message"> | number
    clientId?: IntWithAggregatesFilter<"Message"> | number
    subject?: StringNullableWithAggregatesFilter<"Message"> | string | null
    status?: EnumMessageStatusWithAggregatesFilter<"Message"> | $Enums.MessageStatus
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    messageId?: IntFilter<"ChatMessage"> | number
    sender?: EnumSenderTypeFilter<"ChatMessage"> | $Enums.SenderType
    messageText?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    sender?: SortOrder
    messageText?: SortOrder
    createdAt?: SortOrder
    message?: MessageOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    messageId?: IntFilter<"ChatMessage"> | number
    sender?: EnumSenderTypeFilter<"ChatMessage"> | $Enums.SenderType
    messageText?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    sender?: SortOrder
    messageText?: SortOrder
    createdAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _avg?: ChatMessageAvgOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
    _sum?: ChatMessageSumOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatMessage"> | number
    messageId?: IntWithAggregatesFilter<"ChatMessage"> | number
    sender?: EnumSenderTypeWithAggregatesFilter<"ChatMessage"> | $Enums.SenderType
    messageText?: StringWithAggregatesFilter<"ChatMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type FlaggedMessageWhereInput = {
    AND?: FlaggedMessageWhereInput | FlaggedMessageWhereInput[]
    OR?: FlaggedMessageWhereInput[]
    NOT?: FlaggedMessageWhereInput | FlaggedMessageWhereInput[]
    id?: IntFilter<"FlaggedMessage"> | number
    messageId?: IntNullableFilter<"FlaggedMessage"> | number | null
    messageText?: StringFilter<"FlaggedMessage"> | string
    flaggedBy?: EnumFlaggedByTypeFilter<"FlaggedMessage"> | $Enums.FlaggedByType
    flaggedById?: IntFilter<"FlaggedMessage"> | number
    contractorId?: IntNullableFilter<"FlaggedMessage"> | number | null
    clientId?: IntNullableFilter<"FlaggedMessage"> | number | null
    reason?: StringFilter<"FlaggedMessage"> | string
    details?: StringNullableFilter<"FlaggedMessage"> | string | null
    status?: EnumFlagStatusFilter<"FlaggedMessage"> | $Enums.FlagStatus
    reviewedBy?: IntNullableFilter<"FlaggedMessage"> | number | null
    reviewedAt?: DateTimeNullableFilter<"FlaggedMessage"> | Date | string | null
    createdAt?: DateTimeFilter<"FlaggedMessage"> | Date | string
    contractor?: XOR<ContractorNullableScalarRelationFilter, ContractorWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type FlaggedMessageOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrderInput | SortOrder
    messageText?: SortOrder
    flaggedBy?: SortOrder
    flaggedById?: SortOrder
    contractorId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    reason?: SortOrder
    details?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    contractor?: ContractorOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
  }

  export type FlaggedMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FlaggedMessageWhereInput | FlaggedMessageWhereInput[]
    OR?: FlaggedMessageWhereInput[]
    NOT?: FlaggedMessageWhereInput | FlaggedMessageWhereInput[]
    messageId?: IntNullableFilter<"FlaggedMessage"> | number | null
    messageText?: StringFilter<"FlaggedMessage"> | string
    flaggedBy?: EnumFlaggedByTypeFilter<"FlaggedMessage"> | $Enums.FlaggedByType
    flaggedById?: IntFilter<"FlaggedMessage"> | number
    contractorId?: IntNullableFilter<"FlaggedMessage"> | number | null
    clientId?: IntNullableFilter<"FlaggedMessage"> | number | null
    reason?: StringFilter<"FlaggedMessage"> | string
    details?: StringNullableFilter<"FlaggedMessage"> | string | null
    status?: EnumFlagStatusFilter<"FlaggedMessage"> | $Enums.FlagStatus
    reviewedBy?: IntNullableFilter<"FlaggedMessage"> | number | null
    reviewedAt?: DateTimeNullableFilter<"FlaggedMessage"> | Date | string | null
    createdAt?: DateTimeFilter<"FlaggedMessage"> | Date | string
    contractor?: XOR<ContractorNullableScalarRelationFilter, ContractorWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id">

  export type FlaggedMessageOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrderInput | SortOrder
    messageText?: SortOrder
    flaggedBy?: SortOrder
    flaggedById?: SortOrder
    contractorId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    reason?: SortOrder
    details?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FlaggedMessageCountOrderByAggregateInput
    _avg?: FlaggedMessageAvgOrderByAggregateInput
    _max?: FlaggedMessageMaxOrderByAggregateInput
    _min?: FlaggedMessageMinOrderByAggregateInput
    _sum?: FlaggedMessageSumOrderByAggregateInput
  }

  export type FlaggedMessageScalarWhereWithAggregatesInput = {
    AND?: FlaggedMessageScalarWhereWithAggregatesInput | FlaggedMessageScalarWhereWithAggregatesInput[]
    OR?: FlaggedMessageScalarWhereWithAggregatesInput[]
    NOT?: FlaggedMessageScalarWhereWithAggregatesInput | FlaggedMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FlaggedMessage"> | number
    messageId?: IntNullableWithAggregatesFilter<"FlaggedMessage"> | number | null
    messageText?: StringWithAggregatesFilter<"FlaggedMessage"> | string
    flaggedBy?: EnumFlaggedByTypeWithAggregatesFilter<"FlaggedMessage"> | $Enums.FlaggedByType
    flaggedById?: IntWithAggregatesFilter<"FlaggedMessage"> | number
    contractorId?: IntNullableWithAggregatesFilter<"FlaggedMessage"> | number | null
    clientId?: IntNullableWithAggregatesFilter<"FlaggedMessage"> | number | null
    reason?: StringWithAggregatesFilter<"FlaggedMessage"> | string
    details?: StringNullableWithAggregatesFilter<"FlaggedMessage"> | string | null
    status?: EnumFlagStatusWithAggregatesFilter<"FlaggedMessage"> | $Enums.FlagStatus
    reviewedBy?: IntNullableWithAggregatesFilter<"FlaggedMessage"> | number | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"FlaggedMessage"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FlaggedMessage"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: IntFilter<"Report"> | number
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    reporterType?: EnumReporterTypeFilter<"Report"> | $Enums.ReporterType
    reporterId?: IntFilter<"Report"> | number
    reportedUserId?: IntNullableFilter<"Report"> | number | null
    reportedUserType?: EnumReporterTypeNullableFilter<"Report"> | $Enums.ReporterType | null
    bookingId?: IntNullableFilter<"Report"> | number | null
    reason?: StringFilter<"Report"> | string
    description?: StringFilter<"Report"> | string
    evidence?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    priority?: EnumReportPriorityFilter<"Report"> | $Enums.ReportPriority
    assignedTo?: IntNullableFilter<"Report"> | number | null
    resolution?: StringNullableFilter<"Report"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    reporterType?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrderInput | SortOrder
    reportedUserType?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    reason?: SortOrder
    description?: SortOrder
    evidence?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    reporterType?: EnumReporterTypeFilter<"Report"> | $Enums.ReporterType
    reporterId?: IntFilter<"Report"> | number
    reportedUserId?: IntNullableFilter<"Report"> | number | null
    reportedUserType?: EnumReporterTypeNullableFilter<"Report"> | $Enums.ReporterType | null
    bookingId?: IntNullableFilter<"Report"> | number | null
    reason?: StringFilter<"Report"> | string
    description?: StringFilter<"Report"> | string
    evidence?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    priority?: EnumReportPriorityFilter<"Report"> | $Enums.ReportPriority
    assignedTo?: IntNullableFilter<"Report"> | number | null
    resolution?: StringNullableFilter<"Report"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    reporterType?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrderInput | SortOrder
    reportedUserType?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    reason?: SortOrder
    description?: SortOrder
    evidence?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Report"> | number
    type?: EnumReportTypeWithAggregatesFilter<"Report"> | $Enums.ReportType
    reporterType?: EnumReporterTypeWithAggregatesFilter<"Report"> | $Enums.ReporterType
    reporterId?: IntWithAggregatesFilter<"Report"> | number
    reportedUserId?: IntNullableWithAggregatesFilter<"Report"> | number | null
    reportedUserType?: EnumReporterTypeNullableWithAggregatesFilter<"Report"> | $Enums.ReporterType | null
    bookingId?: IntNullableWithAggregatesFilter<"Report"> | number | null
    reason?: StringWithAggregatesFilter<"Report"> | string
    description?: StringWithAggregatesFilter<"Report"> | string
    evidence?: StringNullableWithAggregatesFilter<"Report"> | string | null
    status?: EnumReportStatusWithAggregatesFilter<"Report"> | $Enums.ReportStatus
    priority?: EnumReportPriorityWithAggregatesFilter<"Report"> | $Enums.ReportPriority
    assignedTo?: IntNullableWithAggregatesFilter<"Report"> | number | null
    resolution?: StringNullableWithAggregatesFilter<"Report"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: IntFilter<"Review"> | number
    contractorId?: IntFilter<"Review"> | number
    clientId?: IntFilter<"Review"> | number
    rating?: IntFilter<"Review"> | number
    reviewText?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    reviewText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    contractor?: ContractorOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    contractorId?: IntFilter<"Review"> | number
    clientId?: IntFilter<"Review"> | number
    rating?: IntFilter<"Review"> | number
    reviewText?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    reviewText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Review"> | number
    contractorId?: IntWithAggregatesFilter<"Review"> | number
    clientId?: IntWithAggregatesFilter<"Review"> | number
    rating?: IntWithAggregatesFilter<"Review"> | number
    reviewText?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: IntFilter<"Invoice"> | number
    bookingId?: IntFilter<"Invoice"> | number
    amount?: FloatFilter<"Invoice"> | number
    taxAmount?: FloatNullableFilter<"Invoice"> | number | null
    totalAmount?: FloatFilter<"Invoice"> | number
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    stripePaymentIntentId?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    taxAmount?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bookingId?: number
    stripePaymentIntentId?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    amount?: FloatFilter<"Invoice"> | number
    taxAmount?: FloatNullableFilter<"Invoice"> | number | null
    totalAmount?: FloatFilter<"Invoice"> | number
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    payments?: PaymentListRelationFilter
  }, "id" | "bookingId" | "stripePaymentIntentId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    taxAmount?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invoice"> | number
    bookingId?: IntWithAggregatesFilter<"Invoice"> | number
    amount?: FloatWithAggregatesFilter<"Invoice"> | number
    taxAmount?: FloatNullableWithAggregatesFilter<"Invoice"> | number | null
    totalAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    stripePaymentIntentId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    bookingId?: IntFilter<"Payment"> | number
    invoiceId?: IntNullableFilter<"Payment"> | number | null
    amount?: FloatFilter<"Payment"> | number
    paymentMethod?: StringFilter<"Payment"> | string
    stripePaymentId?: StringNullableFilter<"Payment"> | string | null
    stripePaymentIntent?: StringNullableFilter<"Payment"> | string | null
    platformFee?: FloatNullableFilter<"Payment"> | number | null
    contractorPayout?: FloatNullableFilter<"Payment"> | number | null
    stripeTransferId?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    stripePaymentId?: SortOrderInput | SortOrder
    stripePaymentIntent?: SortOrderInput | SortOrder
    platformFee?: SortOrderInput | SortOrder
    contractorPayout?: SortOrderInput | SortOrder
    stripeTransferId?: SortOrderInput | SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    stripePaymentId?: string
    stripePaymentIntent?: string
    stripeTransferId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    bookingId?: IntFilter<"Payment"> | number
    invoiceId?: IntNullableFilter<"Payment"> | number | null
    amount?: FloatFilter<"Payment"> | number
    paymentMethod?: StringFilter<"Payment"> | string
    platformFee?: FloatNullableFilter<"Payment"> | number | null
    contractorPayout?: FloatNullableFilter<"Payment"> | number | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }, "id" | "stripePaymentId" | "stripePaymentIntent" | "stripeTransferId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    stripePaymentId?: SortOrderInput | SortOrder
    stripePaymentIntent?: SortOrderInput | SortOrder
    platformFee?: SortOrderInput | SortOrder
    contractorPayout?: SortOrderInput | SortOrder
    stripeTransferId?: SortOrderInput | SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    bookingId?: IntWithAggregatesFilter<"Payment"> | number
    invoiceId?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    paymentMethod?: StringWithAggregatesFilter<"Payment"> | string
    stripePaymentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    stripePaymentIntent?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    platformFee?: FloatNullableWithAggregatesFilter<"Payment"> | number | null
    contractorPayout?: FloatNullableWithAggregatesFilter<"Payment"> | number | null
    stripeTransferId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type AvailabilityWhereInput = {
    AND?: AvailabilityWhereInput | AvailabilityWhereInput[]
    OR?: AvailabilityWhereInput[]
    NOT?: AvailabilityWhereInput | AvailabilityWhereInput[]
    id?: IntFilter<"Availability"> | number
    contractorId?: IntFilter<"Availability"> | number
    dayOfWeek?: IntNullableFilter<"Availability"> | number | null
    specificDate?: DateTimeNullableFilter<"Availability"> | Date | string | null
    startTime?: StringFilter<"Availability"> | string
    endTime?: StringFilter<"Availability"> | string
    maxBookings?: IntFilter<"Availability"> | number
    isAvailable?: BoolFilter<"Availability"> | boolean
    isRecurring?: BoolFilter<"Availability"> | boolean
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
  }

  export type AvailabilityOrderByWithRelationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    specificDate?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxBookings?: SortOrder
    isAvailable?: SortOrder
    isRecurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contractor?: ContractorOrderByWithRelationInput
  }

  export type AvailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AvailabilityWhereInput | AvailabilityWhereInput[]
    OR?: AvailabilityWhereInput[]
    NOT?: AvailabilityWhereInput | AvailabilityWhereInput[]
    contractorId?: IntFilter<"Availability"> | number
    dayOfWeek?: IntNullableFilter<"Availability"> | number | null
    specificDate?: DateTimeNullableFilter<"Availability"> | Date | string | null
    startTime?: StringFilter<"Availability"> | string
    endTime?: StringFilter<"Availability"> | string
    maxBookings?: IntFilter<"Availability"> | number
    isAvailable?: BoolFilter<"Availability"> | boolean
    isRecurring?: BoolFilter<"Availability"> | boolean
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
  }, "id">

  export type AvailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    specificDate?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxBookings?: SortOrder
    isAvailable?: SortOrder
    isRecurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AvailabilityCountOrderByAggregateInput
    _avg?: AvailabilityAvgOrderByAggregateInput
    _max?: AvailabilityMaxOrderByAggregateInput
    _min?: AvailabilityMinOrderByAggregateInput
    _sum?: AvailabilitySumOrderByAggregateInput
  }

  export type AvailabilityScalarWhereWithAggregatesInput = {
    AND?: AvailabilityScalarWhereWithAggregatesInput | AvailabilityScalarWhereWithAggregatesInput[]
    OR?: AvailabilityScalarWhereWithAggregatesInput[]
    NOT?: AvailabilityScalarWhereWithAggregatesInput | AvailabilityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Availability"> | number
    contractorId?: IntWithAggregatesFilter<"Availability"> | number
    dayOfWeek?: IntNullableWithAggregatesFilter<"Availability"> | number | null
    specificDate?: DateTimeNullableWithAggregatesFilter<"Availability"> | Date | string | null
    startTime?: StringWithAggregatesFilter<"Availability"> | string
    endTime?: StringWithAggregatesFilter<"Availability"> | string
    maxBookings?: IntWithAggregatesFilter<"Availability"> | number
    isAvailable?: BoolWithAggregatesFilter<"Availability"> | boolean
    isRecurring?: BoolWithAggregatesFilter<"Availability"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
  }

  export type TimeSlotWhereInput = {
    AND?: TimeSlotWhereInput | TimeSlotWhereInput[]
    OR?: TimeSlotWhereInput[]
    NOT?: TimeSlotWhereInput | TimeSlotWhereInput[]
    id?: IntFilter<"TimeSlot"> | number
    contractorId?: IntFilter<"TimeSlot"> | number
    date?: DateTimeFilter<"TimeSlot"> | Date | string
    startTime?: StringFilter<"TimeSlot"> | string
    endTime?: StringFilter<"TimeSlot"> | string
    slotType?: EnumSlotTypeFilter<"TimeSlot"> | $Enums.SlotType
    bookingId?: IntNullableFilter<"TimeSlot"> | number | null
    reason?: StringNullableFilter<"TimeSlot"> | string | null
    createdAt?: DateTimeFilter<"TimeSlot"> | Date | string
    updatedAt?: DateTimeFilter<"TimeSlot"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
  }

  export type TimeSlotOrderByWithRelationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotType?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contractor?: ContractorOrderByWithRelationInput
  }

  export type TimeSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TimeSlotWhereInput | TimeSlotWhereInput[]
    OR?: TimeSlotWhereInput[]
    NOT?: TimeSlotWhereInput | TimeSlotWhereInput[]
    contractorId?: IntFilter<"TimeSlot"> | number
    date?: DateTimeFilter<"TimeSlot"> | Date | string
    startTime?: StringFilter<"TimeSlot"> | string
    endTime?: StringFilter<"TimeSlot"> | string
    slotType?: EnumSlotTypeFilter<"TimeSlot"> | $Enums.SlotType
    bookingId?: IntNullableFilter<"TimeSlot"> | number | null
    reason?: StringNullableFilter<"TimeSlot"> | string | null
    createdAt?: DateTimeFilter<"TimeSlot"> | Date | string
    updatedAt?: DateTimeFilter<"TimeSlot"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
  }, "id">

  export type TimeSlotOrderByWithAggregationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotType?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimeSlotCountOrderByAggregateInput
    _avg?: TimeSlotAvgOrderByAggregateInput
    _max?: TimeSlotMaxOrderByAggregateInput
    _min?: TimeSlotMinOrderByAggregateInput
    _sum?: TimeSlotSumOrderByAggregateInput
  }

  export type TimeSlotScalarWhereWithAggregatesInput = {
    AND?: TimeSlotScalarWhereWithAggregatesInput | TimeSlotScalarWhereWithAggregatesInput[]
    OR?: TimeSlotScalarWhereWithAggregatesInput[]
    NOT?: TimeSlotScalarWhereWithAggregatesInput | TimeSlotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TimeSlot"> | number
    contractorId?: IntWithAggregatesFilter<"TimeSlot"> | number
    date?: DateTimeWithAggregatesFilter<"TimeSlot"> | Date | string
    startTime?: StringWithAggregatesFilter<"TimeSlot"> | string
    endTime?: StringWithAggregatesFilter<"TimeSlot"> | string
    slotType?: EnumSlotTypeWithAggregatesFilter<"TimeSlot"> | $Enums.SlotType
    bookingId?: IntNullableWithAggregatesFilter<"TimeSlot"> | number | null
    reason?: StringNullableWithAggregatesFilter<"TimeSlot"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TimeSlot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimeSlot"> | Date | string
  }

  export type ServiceAreaWhereInput = {
    AND?: ServiceAreaWhereInput | ServiceAreaWhereInput[]
    OR?: ServiceAreaWhereInput[]
    NOT?: ServiceAreaWhereInput | ServiceAreaWhereInput[]
    id?: IntFilter<"ServiceArea"> | number
    name?: StringFilter<"ServiceArea"> | string
    state?: StringNullableFilter<"ServiceArea"> | string | null
    isActive?: BoolFilter<"ServiceArea"> | boolean
    createdAt?: DateTimeFilter<"ServiceArea"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceArea"> | Date | string
  }

  export type ServiceAreaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAreaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ServiceAreaWhereInput | ServiceAreaWhereInput[]
    OR?: ServiceAreaWhereInput[]
    NOT?: ServiceAreaWhereInput | ServiceAreaWhereInput[]
    state?: StringNullableFilter<"ServiceArea"> | string | null
    isActive?: BoolFilter<"ServiceArea"> | boolean
    createdAt?: DateTimeFilter<"ServiceArea"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceArea"> | Date | string
  }, "id" | "name">

  export type ServiceAreaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceAreaCountOrderByAggregateInput
    _avg?: ServiceAreaAvgOrderByAggregateInput
    _max?: ServiceAreaMaxOrderByAggregateInput
    _min?: ServiceAreaMinOrderByAggregateInput
    _sum?: ServiceAreaSumOrderByAggregateInput
  }

  export type ServiceAreaScalarWhereWithAggregatesInput = {
    AND?: ServiceAreaScalarWhereWithAggregatesInput | ServiceAreaScalarWhereWithAggregatesInput[]
    OR?: ServiceAreaScalarWhereWithAggregatesInput[]
    NOT?: ServiceAreaScalarWhereWithAggregatesInput | ServiceAreaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceArea"> | number
    name?: StringWithAggregatesFilter<"ServiceArea"> | string
    state?: StringNullableWithAggregatesFilter<"ServiceArea"> | string | null
    isActive?: BoolWithAggregatesFilter<"ServiceArea"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ServiceArea"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceArea"> | Date | string
  }

  export type ContractorServiceAreaWhereInput = {
    AND?: ContractorServiceAreaWhereInput | ContractorServiceAreaWhereInput[]
    OR?: ContractorServiceAreaWhereInput[]
    NOT?: ContractorServiceAreaWhereInput | ContractorServiceAreaWhereInput[]
    id?: IntFilter<"ContractorServiceArea"> | number
    contractorId?: IntFilter<"ContractorServiceArea"> | number
    dayOfWeek?: IntNullableFilter<"ContractorServiceArea"> | number | null
    area?: StringFilter<"ContractorServiceArea"> | string
    isActive?: BoolFilter<"ContractorServiceArea"> | boolean
    createdAt?: DateTimeFilter<"ContractorServiceArea"> | Date | string
    updatedAt?: DateTimeFilter<"ContractorServiceArea"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
  }

  export type ContractorServiceAreaOrderByWithRelationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    area?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contractor?: ContractorOrderByWithRelationInput
  }

  export type ContractorServiceAreaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContractorServiceAreaWhereInput | ContractorServiceAreaWhereInput[]
    OR?: ContractorServiceAreaWhereInput[]
    NOT?: ContractorServiceAreaWhereInput | ContractorServiceAreaWhereInput[]
    contractorId?: IntFilter<"ContractorServiceArea"> | number
    dayOfWeek?: IntNullableFilter<"ContractorServiceArea"> | number | null
    area?: StringFilter<"ContractorServiceArea"> | string
    isActive?: BoolFilter<"ContractorServiceArea"> | boolean
    createdAt?: DateTimeFilter<"ContractorServiceArea"> | Date | string
    updatedAt?: DateTimeFilter<"ContractorServiceArea"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
  }, "id">

  export type ContractorServiceAreaOrderByWithAggregationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    area?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContractorServiceAreaCountOrderByAggregateInput
    _avg?: ContractorServiceAreaAvgOrderByAggregateInput
    _max?: ContractorServiceAreaMaxOrderByAggregateInput
    _min?: ContractorServiceAreaMinOrderByAggregateInput
    _sum?: ContractorServiceAreaSumOrderByAggregateInput
  }

  export type ContractorServiceAreaScalarWhereWithAggregatesInput = {
    AND?: ContractorServiceAreaScalarWhereWithAggregatesInput | ContractorServiceAreaScalarWhereWithAggregatesInput[]
    OR?: ContractorServiceAreaScalarWhereWithAggregatesInput[]
    NOT?: ContractorServiceAreaScalarWhereWithAggregatesInput | ContractorServiceAreaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContractorServiceArea"> | number
    contractorId?: IntWithAggregatesFilter<"ContractorServiceArea"> | number
    dayOfWeek?: IntNullableWithAggregatesFilter<"ContractorServiceArea"> | number | null
    area?: StringWithAggregatesFilter<"ContractorServiceArea"> | string
    isActive?: BoolWithAggregatesFilter<"ContractorServiceArea"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ContractorServiceArea"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContractorServiceArea"> | Date | string
  }

  export type FavoriteContractorWhereInput = {
    AND?: FavoriteContractorWhereInput | FavoriteContractorWhereInput[]
    OR?: FavoriteContractorWhereInput[]
    NOT?: FavoriteContractorWhereInput | FavoriteContractorWhereInput[]
    id?: IntFilter<"FavoriteContractor"> | number
    clientId?: IntFilter<"FavoriteContractor"> | number
    contractorId?: IntFilter<"FavoriteContractor"> | number
    createdAt?: DateTimeFilter<"FavoriteContractor"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
  }

  export type FavoriteContractorOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    contractorId?: SortOrder
    createdAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    contractor?: ContractorOrderByWithRelationInput
  }

  export type FavoriteContractorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    clientId_contractorId?: FavoriteContractorClientIdContractorIdCompoundUniqueInput
    AND?: FavoriteContractorWhereInput | FavoriteContractorWhereInput[]
    OR?: FavoriteContractorWhereInput[]
    NOT?: FavoriteContractorWhereInput | FavoriteContractorWhereInput[]
    clientId?: IntFilter<"FavoriteContractor"> | number
    contractorId?: IntFilter<"FavoriteContractor"> | number
    createdAt?: DateTimeFilter<"FavoriteContractor"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
  }, "id" | "clientId_contractorId">

  export type FavoriteContractorOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    contractorId?: SortOrder
    createdAt?: SortOrder
    _count?: FavoriteContractorCountOrderByAggregateInput
    _avg?: FavoriteContractorAvgOrderByAggregateInput
    _max?: FavoriteContractorMaxOrderByAggregateInput
    _min?: FavoriteContractorMinOrderByAggregateInput
    _sum?: FavoriteContractorSumOrderByAggregateInput
  }

  export type FavoriteContractorScalarWhereWithAggregatesInput = {
    AND?: FavoriteContractorScalarWhereWithAggregatesInput | FavoriteContractorScalarWhereWithAggregatesInput[]
    OR?: FavoriteContractorScalarWhereWithAggregatesInput[]
    NOT?: FavoriteContractorScalarWhereWithAggregatesInput | FavoriteContractorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FavoriteContractor"> | number
    clientId?: IntWithAggregatesFilter<"FavoriteContractor"> | number
    contractorId?: IntWithAggregatesFilter<"FavoriteContractor"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FavoriteContractor"> | Date | string
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: IntFilter<"Material"> | number
    contractorId?: IntFilter<"Material"> | number
    name?: StringFilter<"Material"> | string
    price?: FloatFilter<"Material"> | number
    unit?: StringFilter<"Material"> | string
    description?: StringNullableFilter<"Material"> | string | null
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contractor?: ContractorOrderByWithRelationInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    contractorId?: IntFilter<"Material"> | number
    name?: StringFilter<"Material"> | string
    price?: FloatFilter<"Material"> | number
    unit?: StringFilter<"Material"> | string
    description?: StringNullableFilter<"Material"> | string | null
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    contractor?: XOR<ContractorScalarRelationFilter, ContractorWhereInput>
  }, "id">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    contractorId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Material"> | number
    contractorId?: IntWithAggregatesFilter<"Material"> | number
    name?: StringWithAggregatesFilter<"Material"> | string
    price?: FloatWithAggregatesFilter<"Material"> | number
    unit?: StringWithAggregatesFilter<"Material"> | string
    description?: StringNullableWithAggregatesFilter<"Material"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    userId?: IntNullableFilter<"ActivityLog"> | number | null
    action?: StringFilter<"ActivityLog"> | string
    details?: StringFilter<"ActivityLog"> | string
    severity?: EnumActivitySeverityFilter<"ActivityLog"> | $Enums.ActivitySeverity
    metadata?: JsonNullableFilter<"ActivityLog">
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrder
    severity?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    userId?: IntNullableFilter<"ActivityLog"> | number | null
    action?: StringFilter<"ActivityLog"> | string
    details?: StringFilter<"ActivityLog"> | string
    severity?: EnumActivitySeverityFilter<"ActivityLog"> | $Enums.ActivitySeverity
    metadata?: JsonNullableFilter<"ActivityLog">
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrder
    severity?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _avg?: ActivityLogAvgOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
    _sum?: ActivityLogSumOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActivityLog"> | number
    userId?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    details?: StringWithAggregatesFilter<"ActivityLog"> | string
    severity?: EnumActivitySeverityWithAggregatesFilter<"ActivityLog"> | $Enums.ActivitySeverity
    metadata?: JsonNullableWithAggregatesFilter<"ActivityLog">
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    password: string
    type: $Enums.UserType
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    facebookId?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutUserInput
    contractor?: ContractorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    type: $Enums.UserType
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    facebookId?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    contractor?: ContractorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutUserNestedInput
    contractor?: ContractorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    contractor?: ContractorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    type: $Enums.UserType
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    facebookId?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientInput
    bookings?: BookingCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    messages?: MessageCreateNestedManyWithoutClientInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutClientInput
    favorites?: FavoriteContractorCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: number
    userId: number
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    messages?: MessageUncheckedCreateNestedManyWithoutClientInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutClientInput
    favorites?: FavoriteContractorUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    bookings?: BookingUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    messages?: MessageUpdateManyWithoutClientNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutClientNestedInput
    favorites?: FavoriteContractorUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClientNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutClientNestedInput
    favorites?: FavoriteContractorUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: number
    userId: number
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorCreateInput = {
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContractorInput
    services?: ContractorServiceCreateNestedManyWithoutContractorInput
    bookings?: BookingCreateNestedManyWithoutContractorInput
    reviews?: ReviewCreateNestedManyWithoutContractorInput
    messages?: MessageCreateNestedManyWithoutContractorInput
    availability?: AvailabilityCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorCreateNestedManyWithoutContractorInput
    materials?: MaterialCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionCreateNestedOneWithoutContractorInput
  }

  export type ContractorUncheckedCreateInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ContractorServiceUncheckedCreateNestedManyWithoutContractorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutContractorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractorInput
    messages?: MessageUncheckedCreateNestedManyWithoutContractorInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaUncheckedCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorUncheckedCreateNestedManyWithoutContractorInput
    materials?: MaterialUncheckedCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageUncheckedCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutContractorInput
  }

  export type ContractorUpdateInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContractorNestedInput
    services?: ContractorServiceUpdateManyWithoutContractorNestedInput
    bookings?: BookingUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUpdateManyWithoutContractorNestedInput
    messages?: MessageUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUpdateManyWithoutContractorNestedInput
    materials?: MaterialUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUpdateOneWithoutContractorNestedInput
  }

  export type ContractorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ContractorServiceUncheckedUpdateManyWithoutContractorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUncheckedUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUncheckedUpdateManyWithoutContractorNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUncheckedUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutContractorNestedInput
  }

  export type ContractorCreateManyInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractorUpdateManyMutationInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: number
    contractorId: number
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: number
    contractorId: number
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageCreateInput = {
    name: string
    code: string
    flag: string
    isActive?: boolean
    createdAt?: Date | string
    contractors?: ContractorLanguageCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    flag: string
    isActive?: boolean
    createdAt?: Date | string
    contractors?: ContractorLanguageUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractors?: ContractorLanguageUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractors?: ContractorLanguageUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageCreateManyInput = {
    id?: number
    name: string
    code: string
    flag: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type LanguageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorLanguageCreateInput = {
    createdAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutLanguagesInput
    language: LanguageCreateNestedOneWithoutContractorsInput
  }

  export type ContractorLanguageUncheckedCreateInput = {
    id?: number
    contractorId: number
    languageId: number
    createdAt?: Date | string
  }

  export type ContractorLanguageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutLanguagesNestedInput
    language?: LanguageUpdateOneRequiredWithoutContractorsNestedInput
  }

  export type ContractorLanguageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    languageId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorLanguageCreateManyInput = {
    id?: number
    contractorId: number
    languageId: number
    createdAt?: Date | string
  }

  export type ContractorLanguageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorLanguageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    languageId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    name: string
    icon: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    contractors?: ContractorServiceCreateNestedManyWithoutServiceInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: number
    name: string
    icon: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    contractors?: ContractorServiceUncheckedCreateNestedManyWithoutServiceInput
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractors?: ContractorServiceUpdateManyWithoutServiceNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractors?: ContractorServiceUncheckedUpdateManyWithoutServiceNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: number
    name: string
    icon: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorServiceCreateInput = {
    basePrice?: number | null
    createdAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutContractorsInput
  }

  export type ContractorServiceUncheckedCreateInput = {
    id?: number
    contractorId: number
    serviceId: number
    basePrice?: number | null
    createdAt?: Date | string
  }

  export type ContractorServiceUpdateInput = {
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutContractorsNestedInput
  }

  export type ContractorServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorServiceCreateManyInput = {
    id?: number
    contractorId: number
    serviceId: number
    basePrice?: number | null
    createdAt?: Date | string
  }

  export type ContractorServiceUpdateManyMutationInput = {
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutBookingsInput
    client: ClientCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    completion?: JobCompletionCreateNestedOneWithoutBookingInput
    photos?: JobPhotoCreateNestedManyWithoutBookingInput
    invoice?: InvoiceCreateNestedOneWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    reports?: ReportCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    contractorId: number
    clientId: number
    serviceId: number
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completion?: JobCompletionUncheckedCreateNestedOneWithoutBookingInput
    photos?: JobPhotoUncheckedCreateNestedManyWithoutBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    reports?: ReportUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutBookingsNestedInput
    client?: ClientUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    completion?: JobCompletionUpdateOneWithoutBookingNestedInput
    photos?: JobPhotoUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    reports?: ReportUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: JobCompletionUncheckedUpdateOneWithoutBookingNestedInput
    photos?: JobPhotoUncheckedUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: number
    contractorId: number
    clientId: number
    serviceId: number
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCompletionCreateInput = {
    startTime?: Date | string | null
    endTime?: Date | string | null
    materials?: string | null
    notes?: string | null
    audioNoteUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutCompletionInput
  }

  export type JobCompletionUncheckedCreateInput = {
    id?: number
    bookingId: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    materials?: string | null
    notes?: string | null
    audioNoteUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCompletionUpdateInput = {
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    materials?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    audioNoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutCompletionNestedInput
  }

  export type JobCompletionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    materials?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    audioNoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCompletionCreateManyInput = {
    id?: number
    bookingId: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    materials?: string | null
    notes?: string | null
    audioNoteUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCompletionUpdateManyMutationInput = {
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    materials?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    audioNoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCompletionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    materials?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    audioNoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPhotoCreateInput = {
    filename: string
    originalName: string
    photoType: $Enums.PhotoType
    fileSize: number
    url: string
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutPhotosInput
  }

  export type JobPhotoUncheckedCreateInput = {
    id?: number
    bookingId: number
    filename: string
    originalName: string
    photoType: $Enums.PhotoType
    fileSize: number
    url: string
    createdAt?: Date | string
  }

  export type JobPhotoUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    photoType?: EnumPhotoTypeFieldUpdateOperationsInput | $Enums.PhotoType
    fileSize?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type JobPhotoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    photoType?: EnumPhotoTypeFieldUpdateOperationsInput | $Enums.PhotoType
    fileSize?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPhotoCreateManyInput = {
    id?: number
    bookingId: number
    filename: string
    originalName: string
    photoType: $Enums.PhotoType
    fileSize: number
    url: string
    createdAt?: Date | string
  }

  export type JobPhotoUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    photoType?: EnumPhotoTypeFieldUpdateOperationsInput | $Enums.PhotoType
    fileSize?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPhotoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    photoType?: EnumPhotoTypeFieldUpdateOperationsInput | $Enums.PhotoType
    fileSize?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    subject?: string | null
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutMessagesInput
    client: ClientCreateNestedOneWithoutMessagesInput
    chatMessages?: ChatMessageCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    contractorId: number
    clientId: number
    subject?: string | null
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutMessagesNestedInput
    client?: ClientUpdateOneRequiredWithoutMessagesNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: number
    contractorId: number
    clientId: number
    subject?: string | null
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    sender: $Enums.SenderType
    messageText: string
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutChatMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: number
    messageId: number
    sender: $Enums.SenderType
    messageText: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateInput = {
    sender?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: IntFieldUpdateOperationsInput | number
    sender?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: number
    messageId: number
    sender: $Enums.SenderType
    messageText: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    sender?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: IntFieldUpdateOperationsInput | number
    sender?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlaggedMessageCreateInput = {
    messageId?: number | null
    messageText: string
    flaggedBy: $Enums.FlaggedByType
    flaggedById: number
    reason: string
    details?: string | null
    status?: $Enums.FlagStatus
    reviewedBy?: number | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    contractor?: ContractorCreateNestedOneWithoutFlaggedMessagesInput
    client?: ClientCreateNestedOneWithoutFlaggedMessagesInput
  }

  export type FlaggedMessageUncheckedCreateInput = {
    id?: number
    messageId?: number | null
    messageText: string
    flaggedBy: $Enums.FlaggedByType
    flaggedById: number
    contractorId?: number | null
    clientId?: number | null
    reason: string
    details?: string | null
    status?: $Enums.FlagStatus
    reviewedBy?: number | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type FlaggedMessageUpdateInput = {
    messageId?: NullableIntFieldUpdateOperationsInput | number | null
    messageText?: StringFieldUpdateOperationsInput | string
    flaggedBy?: EnumFlaggedByTypeFieldUpdateOperationsInput | $Enums.FlaggedByType
    flaggedById?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reviewedBy?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneWithoutFlaggedMessagesNestedInput
    client?: ClientUpdateOneWithoutFlaggedMessagesNestedInput
  }

  export type FlaggedMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: NullableIntFieldUpdateOperationsInput | number | null
    messageText?: StringFieldUpdateOperationsInput | string
    flaggedBy?: EnumFlaggedByTypeFieldUpdateOperationsInput | $Enums.FlaggedByType
    flaggedById?: IntFieldUpdateOperationsInput | number
    contractorId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reviewedBy?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlaggedMessageCreateManyInput = {
    id?: number
    messageId?: number | null
    messageText: string
    flaggedBy: $Enums.FlaggedByType
    flaggedById: number
    contractorId?: number | null
    clientId?: number | null
    reason: string
    details?: string | null
    status?: $Enums.FlagStatus
    reviewedBy?: number | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type FlaggedMessageUpdateManyMutationInput = {
    messageId?: NullableIntFieldUpdateOperationsInput | number | null
    messageText?: StringFieldUpdateOperationsInput | string
    flaggedBy?: EnumFlaggedByTypeFieldUpdateOperationsInput | $Enums.FlaggedByType
    flaggedById?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reviewedBy?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlaggedMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: NullableIntFieldUpdateOperationsInput | number | null
    messageText?: StringFieldUpdateOperationsInput | string
    flaggedBy?: EnumFlaggedByTypeFieldUpdateOperationsInput | $Enums.FlaggedByType
    flaggedById?: IntFieldUpdateOperationsInput | number
    contractorId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reviewedBy?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    type: $Enums.ReportType
    reporterType: $Enums.ReporterType
    reporterId: number
    reportedUserId?: number | null
    reportedUserType?: $Enums.ReporterType | null
    reason: string
    description: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    priority?: $Enums.ReportPriority
    assignedTo?: number | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: number
    type: $Enums.ReportType
    reporterType: $Enums.ReporterType
    reporterId: number
    reportedUserId?: number | null
    reportedUserType?: $Enums.ReporterType | null
    bookingId?: number | null
    reason: string
    description: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    priority?: $Enums.ReportPriority
    assignedTo?: number | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateInput = {
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reporterType?: EnumReporterTypeFieldUpdateOperationsInput | $Enums.ReporterType
    reporterId?: IntFieldUpdateOperationsInput | number
    reportedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    reportedUserType?: NullableEnumReporterTypeFieldUpdateOperationsInput | $Enums.ReporterType | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    priority?: EnumReportPriorityFieldUpdateOperationsInput | $Enums.ReportPriority
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reporterType?: EnumReporterTypeFieldUpdateOperationsInput | $Enums.ReporterType
    reporterId?: IntFieldUpdateOperationsInput | number
    reportedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    reportedUserType?: NullableEnumReporterTypeFieldUpdateOperationsInput | $Enums.ReporterType | null
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    priority?: EnumReportPriorityFieldUpdateOperationsInput | $Enums.ReportPriority
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: number
    type: $Enums.ReportType
    reporterType: $Enums.ReporterType
    reporterId: number
    reportedUserId?: number | null
    reportedUserType?: $Enums.ReporterType | null
    bookingId?: number | null
    reason: string
    description: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    priority?: $Enums.ReportPriority
    assignedTo?: number | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reporterType?: EnumReporterTypeFieldUpdateOperationsInput | $Enums.ReporterType
    reporterId?: IntFieldUpdateOperationsInput | number
    reportedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    reportedUserType?: NullableEnumReporterTypeFieldUpdateOperationsInput | $Enums.ReporterType | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    priority?: EnumReportPriorityFieldUpdateOperationsInput | $Enums.ReportPriority
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reporterType?: EnumReporterTypeFieldUpdateOperationsInput | $Enums.ReporterType
    reporterId?: IntFieldUpdateOperationsInput | number
    reportedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    reportedUserType?: NullableEnumReporterTypeFieldUpdateOperationsInput | $Enums.ReporterType | null
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    priority?: EnumReportPriorityFieldUpdateOperationsInput | $Enums.ReportPriority
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    rating: number
    reviewText?: string | null
    createdAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutReviewsInput
    client: ClientCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: number
    contractorId: number
    clientId: number
    rating: number
    reviewText?: string | null
    createdAt?: Date | string
  }

  export type ReviewUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutReviewsNestedInput
    client?: ClientUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: number
    contractorId: number
    clientId: number
    rating: number
    reviewText?: string | null
    createdAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    amount: number
    taxAmount?: number | null
    totalAmount: number
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    stripePaymentIntentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: number
    bookingId: number
    amount: number
    taxAmount?: number | null
    totalAmount: number
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    stripePaymentIntentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: number
    bookingId: number
    amount: number
    taxAmount?: number | null
    totalAmount: number
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    stripePaymentIntentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    amount: number
    paymentMethod: string
    stripePaymentId?: string | null
    stripePaymentIntent?: string | null
    platformFee?: number | null
    contractorPayout?: number | null
    stripeTransferId?: string | null
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutPaymentsInput
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    bookingId: number
    invoiceId?: number | null
    amount: number
    paymentMethod: string
    stripePaymentId?: string | null
    stripePaymentIntent?: string | null
    platformFee?: number | null
    contractorPayout?: number | null
    stripeTransferId?: string | null
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntent?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    contractorPayout?: NullableFloatFieldUpdateOperationsInput | number | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPaymentsNestedInput
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntent?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    contractorPayout?: NullableFloatFieldUpdateOperationsInput | number | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    bookingId: number
    invoiceId?: number | null
    amount: number
    paymentMethod: string
    stripePaymentId?: string | null
    stripePaymentIntent?: string | null
    platformFee?: number | null
    contractorPayout?: number | null
    stripeTransferId?: string | null
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntent?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    contractorPayout?: NullableFloatFieldUpdateOperationsInput | number | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntent?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    contractorPayout?: NullableFloatFieldUpdateOperationsInput | number | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityCreateInput = {
    dayOfWeek?: number | null
    specificDate?: Date | string | null
    startTime: string
    endTime: string
    maxBookings?: number
    isAvailable?: boolean
    isRecurring?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutAvailabilityInput
  }

  export type AvailabilityUncheckedCreateInput = {
    id?: number
    contractorId: number
    dayOfWeek?: number | null
    specificDate?: Date | string | null
    startTime: string
    endTime: string
    maxBookings?: number
    isAvailable?: boolean
    isRecurring?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityUpdateInput = {
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    specificDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxBookings?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutAvailabilityNestedInput
  }

  export type AvailabilityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    specificDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxBookings?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityCreateManyInput = {
    id?: number
    contractorId: number
    dayOfWeek?: number | null
    specificDate?: Date | string | null
    startTime: string
    endTime: string
    maxBookings?: number
    isAvailable?: boolean
    isRecurring?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityUpdateManyMutationInput = {
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    specificDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxBookings?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    specificDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxBookings?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSlotCreateInput = {
    date: Date | string
    startTime: string
    endTime: string
    slotType: $Enums.SlotType
    bookingId?: number | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutTimeSlotsInput
  }

  export type TimeSlotUncheckedCreateInput = {
    id?: number
    contractorId: number
    date: Date | string
    startTime: string
    endTime: string
    slotType: $Enums.SlotType
    bookingId?: number | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeSlotUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutTimeSlotsNestedInput
  }

  export type TimeSlotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSlotCreateManyInput = {
    id?: number
    contractorId: number
    date: Date | string
    startTime: string
    endTime: string
    slotType: $Enums.SlotType
    bookingId?: number | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeSlotUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSlotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAreaCreateInput = {
    name: string
    state?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceAreaUncheckedCreateInput = {
    id?: number
    name: string
    state?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceAreaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAreaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAreaCreateManyInput = {
    id?: number
    name: string
    state?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceAreaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAreaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorServiceAreaCreateInput = {
    dayOfWeek?: number | null
    area: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutServiceAreasInput
  }

  export type ContractorServiceAreaUncheckedCreateInput = {
    id?: number
    contractorId: number
    dayOfWeek?: number | null
    area: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractorServiceAreaUpdateInput = {
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    area?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutServiceAreasNestedInput
  }

  export type ContractorServiceAreaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    area?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorServiceAreaCreateManyInput = {
    id?: number
    contractorId: number
    dayOfWeek?: number | null
    area: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractorServiceAreaUpdateManyMutationInput = {
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    area?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorServiceAreaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    area?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteContractorCreateInput = {
    createdAt?: Date | string
    client: ClientCreateNestedOneWithoutFavoritesInput
    contractor: ContractorCreateNestedOneWithoutFavoritedByInput
  }

  export type FavoriteContractorUncheckedCreateInput = {
    id?: number
    clientId: number
    contractorId: number
    createdAt?: Date | string
  }

  export type FavoriteContractorUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutFavoritesNestedInput
    contractor?: ContractorUpdateOneRequiredWithoutFavoritedByNestedInput
  }

  export type FavoriteContractorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteContractorCreateManyInput = {
    id?: number
    clientId: number
    contractorId: number
    createdAt?: Date | string
  }

  export type FavoriteContractorUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteContractorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateInput = {
    name: string
    price: number
    unit: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutMaterialsInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: number
    contractorId: number
    name: string
    price: number
    unit: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutMaterialsNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateManyInput = {
    id?: number
    contractorId: number
    name: string
    price: number
    unit: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateInput = {
    userId?: number | null
    action: string
    details: string
    severity?: $Enums.ActivitySeverity
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: number
    userId?: number | null
    action: string
    details: string
    severity?: $Enums.ActivitySeverity
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityLogUpdateInput = {
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    severity?: EnumActivitySeverityFieldUpdateOperationsInput | $Enums.ActivitySeverity
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    severity?: EnumActivitySeverityFieldUpdateOperationsInput | $Enums.ActivitySeverity
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: number
    userId?: number | null
    action: string
    details: string
    severity?: $Enums.ActivitySeverity
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    severity?: EnumActivitySeverityFieldUpdateOperationsInput | $Enums.ActivitySeverity
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    severity?: EnumActivitySeverityFieldUpdateOperationsInput | $Enums.ActivitySeverity
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type EnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type ContractorNullableScalarRelationFilter = {
    is?: ContractorWhereInput | null
    isNot?: ContractorWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    type?: SortOrder
    authProvider?: SortOrder
    googleId?: SortOrder
    facebookId?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    type?: SortOrder
    authProvider?: SortOrder
    googleId?: SortOrder
    facebookId?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    type?: SortOrder
    authProvider?: SortOrder
    googleId?: SortOrder
    facebookId?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type EnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type FlaggedMessageListRelationFilter = {
    every?: FlaggedMessageWhereInput
    some?: FlaggedMessageWhereInput
    none?: FlaggedMessageWhereInput
  }

  export type FavoriteContractorListRelationFilter = {
    every?: FavoriteContractorWhereInput
    some?: FavoriteContractorWhereInput
    none?: FavoriteContractorWhereInput
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlaggedMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoriteContractorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    notificationEmail?: SortOrder
    notificationSms?: SortOrder
    profilePicture?: SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    suspendedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    notificationEmail?: SortOrder
    notificationSms?: SortOrder
    profilePicture?: SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    suspendedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    notificationEmail?: SortOrder
    notificationSms?: SortOrder
    profilePicture?: SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    suspendedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ContractorServiceListRelationFilter = {
    every?: ContractorServiceWhereInput
    some?: ContractorServiceWhereInput
    none?: ContractorServiceWhereInput
  }

  export type AvailabilityListRelationFilter = {
    every?: AvailabilityWhereInput
    some?: AvailabilityWhereInput
    none?: AvailabilityWhereInput
  }

  export type TimeSlotListRelationFilter = {
    every?: TimeSlotWhereInput
    some?: TimeSlotWhereInput
    none?: TimeSlotWhereInput
  }

  export type ContractorServiceAreaListRelationFilter = {
    every?: ContractorServiceAreaWhereInput
    some?: ContractorServiceAreaWhereInput
    none?: ContractorServiceAreaWhereInput
  }

  export type MaterialListRelationFilter = {
    every?: MaterialWhereInput
    some?: MaterialWhereInput
    none?: MaterialWhereInput
  }

  export type ContractorLanguageListRelationFilter = {
    every?: ContractorLanguageWhereInput
    some?: ContractorLanguageWhereInput
    none?: ContractorLanguageWhereInput
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type ContractorServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractorServiceAreaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractorLanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    description?: SortOrder
    yearsInBusiness?: SortOrder
    location?: SortOrder
    googleBusinessUrl?: SortOrder
    verified?: SortOrder
    licensed?: SortOrder
    insured?: SortOrder
    afterHoursAvailable?: SortOrder
    speaksSpanish?: SortOrder
    hourlyRate?: SortOrder
    taxRate?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    profilePicture?: SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    suspendedUntil?: SortOrder
    stripeAccountId?: SortOrder
    stripeOnboardingComplete?: SortOrder
    stripeChargesEnabled?: SortOrder
    stripePayoutsEnabled?: SortOrder
    bookingPageSlug?: SortOrder
    bookingPageEnabled?: SortOrder
    bookingPagePrimaryColor?: SortOrder
    bookingPageAccentColor?: SortOrder
    bookingPageTagline?: SortOrder
    bookingPageLogo?: SortOrder
    bookingPageShowReviews?: SortOrder
    bookingPageShowPrices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractorAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    yearsInBusiness?: SortOrder
    hourlyRate?: SortOrder
    taxRate?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
  }

  export type ContractorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    description?: SortOrder
    yearsInBusiness?: SortOrder
    location?: SortOrder
    googleBusinessUrl?: SortOrder
    verified?: SortOrder
    licensed?: SortOrder
    insured?: SortOrder
    afterHoursAvailable?: SortOrder
    speaksSpanish?: SortOrder
    hourlyRate?: SortOrder
    taxRate?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    profilePicture?: SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    suspendedUntil?: SortOrder
    stripeAccountId?: SortOrder
    stripeOnboardingComplete?: SortOrder
    stripeChargesEnabled?: SortOrder
    stripePayoutsEnabled?: SortOrder
    bookingPageSlug?: SortOrder
    bookingPageEnabled?: SortOrder
    bookingPagePrimaryColor?: SortOrder
    bookingPageAccentColor?: SortOrder
    bookingPageTagline?: SortOrder
    bookingPageLogo?: SortOrder
    bookingPageShowReviews?: SortOrder
    bookingPageShowPrices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    description?: SortOrder
    yearsInBusiness?: SortOrder
    location?: SortOrder
    googleBusinessUrl?: SortOrder
    verified?: SortOrder
    licensed?: SortOrder
    insured?: SortOrder
    afterHoursAvailable?: SortOrder
    speaksSpanish?: SortOrder
    hourlyRate?: SortOrder
    taxRate?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    profilePicture?: SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    suspendedUntil?: SortOrder
    stripeAccountId?: SortOrder
    stripeOnboardingComplete?: SortOrder
    stripeChargesEnabled?: SortOrder
    stripePayoutsEnabled?: SortOrder
    bookingPageSlug?: SortOrder
    bookingPageEnabled?: SortOrder
    bookingPagePrimaryColor?: SortOrder
    bookingPageAccentColor?: SortOrder
    bookingPageTagline?: SortOrder
    bookingPageLogo?: SortOrder
    bookingPageShowReviews?: SortOrder
    bookingPageShowPrices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractorSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    yearsInBusiness?: SortOrder
    hourlyRate?: SortOrder
    taxRate?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type ContractorScalarRelationFilter = {
    is?: ContractorWhereInput
    isNot?: ContractorWhereInput
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
  }

  export type EnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    flag?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type LanguageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    flag?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    flag?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type LanguageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LanguageScalarRelationFilter = {
    is?: LanguageWhereInput
    isNot?: LanguageWhereInput
  }

  export type ContractorLanguageContractorIdLanguageIdCompoundUniqueInput = {
    contractorId: number
    languageId: number
  }

  export type ContractorLanguageCountOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    languageId?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractorLanguageAvgOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    languageId?: SortOrder
  }

  export type ContractorLanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    languageId?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractorLanguageMinOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    languageId?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractorLanguageSumOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    languageId?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ContractorServiceContractorIdServiceIdCompoundUniqueInput = {
    contractorId: number
    serviceId: number
  }

  export type ContractorServiceCountOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    serviceId?: SortOrder
    basePrice?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractorServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    serviceId?: SortOrder
    basePrice?: SortOrder
  }

  export type ContractorServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    serviceId?: SortOrder
    basePrice?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractorServiceMinOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    serviceId?: SortOrder
    basePrice?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractorServiceSumOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    serviceId?: SortOrder
    basePrice?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type JobCompletionNullableScalarRelationFilter = {
    is?: JobCompletionWhereInput | null
    isNot?: JobCompletionWhereInput | null
  }

  export type JobPhotoListRelationFilter = {
    every?: JobPhotoWhereInput
    some?: JobPhotoWhereInput
    none?: JobPhotoWhereInput
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type JobPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    serviceAddress?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    estimatedDuration?: SortOrder
    status?: SortOrder
    price?: SortOrder
    paymentReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    estimatedDuration?: SortOrder
    price?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    serviceAddress?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    estimatedDuration?: SortOrder
    status?: SortOrder
    price?: SortOrder
    paymentReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    serviceAddress?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    estimatedDuration?: SortOrder
    status?: SortOrder
    price?: SortOrder
    paymentReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    estimatedDuration?: SortOrder
    price?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type JobCompletionCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    materials?: SortOrder
    notes?: SortOrder
    audioNoteUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobCompletionAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
  }

  export type JobCompletionMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    materials?: SortOrder
    notes?: SortOrder
    audioNoteUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobCompletionMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    materials?: SortOrder
    notes?: SortOrder
    audioNoteUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobCompletionSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
  }

  export type EnumPhotoTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PhotoType | EnumPhotoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PhotoType[] | ListEnumPhotoTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhotoType[] | ListEnumPhotoTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPhotoTypeFilter<$PrismaModel> | $Enums.PhotoType
  }

  export type JobPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    photoType?: SortOrder
    fileSize?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type JobPhotoAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    fileSize?: SortOrder
  }

  export type JobPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    photoType?: SortOrder
    fileSize?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type JobPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    photoType?: SortOrder
    fileSize?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type JobPhotoSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    fileSize?: SortOrder
  }

  export type EnumPhotoTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PhotoType | EnumPhotoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PhotoType[] | ListEnumPhotoTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhotoType[] | ListEnumPhotoTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPhotoTypeWithAggregatesFilter<$PrismaModel> | $Enums.PhotoType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPhotoTypeFilter<$PrismaModel>
    _max?: NestedEnumPhotoTypeFilter<$PrismaModel>
  }

  export type EnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
  }

  export type EnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type EnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    sender?: SortOrder
    messageText?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    sender?: SortOrder
    messageText?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    sender?: SortOrder
    messageText?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageSumOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
  }

  export type EnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type EnumFlaggedByTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FlaggedByType | EnumFlaggedByTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FlaggedByType[] | ListEnumFlaggedByTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlaggedByType[] | ListEnumFlaggedByTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFlaggedByTypeFilter<$PrismaModel> | $Enums.FlaggedByType
  }

  export type EnumFlagStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagStatus | EnumFlagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagStatusFilter<$PrismaModel> | $Enums.FlagStatus
  }

  export type FlaggedMessageCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    messageText?: SortOrder
    flaggedBy?: SortOrder
    flaggedById?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    reason?: SortOrder
    details?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FlaggedMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    flaggedById?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    reviewedBy?: SortOrder
  }

  export type FlaggedMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    messageText?: SortOrder
    flaggedBy?: SortOrder
    flaggedById?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    reason?: SortOrder
    details?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FlaggedMessageMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    messageText?: SortOrder
    flaggedBy?: SortOrder
    flaggedById?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    reason?: SortOrder
    details?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FlaggedMessageSumOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    flaggedById?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    reviewedBy?: SortOrder
  }

  export type EnumFlaggedByTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlaggedByType | EnumFlaggedByTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FlaggedByType[] | ListEnumFlaggedByTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlaggedByType[] | ListEnumFlaggedByTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFlaggedByTypeWithAggregatesFilter<$PrismaModel> | $Enums.FlaggedByType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlaggedByTypeFilter<$PrismaModel>
    _max?: NestedEnumFlaggedByTypeFilter<$PrismaModel>
  }

  export type EnumFlagStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagStatus | EnumFlagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagStatusWithAggregatesFilter<$PrismaModel> | $Enums.FlagStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlagStatusFilter<$PrismaModel>
    _max?: NestedEnumFlagStatusFilter<$PrismaModel>
  }

  export type EnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type EnumReporterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReporterType | EnumReporterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReporterTypeFilter<$PrismaModel> | $Enums.ReporterType
  }

  export type EnumReporterTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReporterType | EnumReporterTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReporterTypeNullableFilter<$PrismaModel> | $Enums.ReporterType | null
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type EnumReportPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportPriority | EnumReportPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ReportPriority[] | ListEnumReportPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportPriority[] | ListEnumReportPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumReportPriorityFilter<$PrismaModel> | $Enums.ReportPriority
  }

  export type BookingNullableScalarRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    reporterType?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    reportedUserType?: SortOrder
    bookingId?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    evidence?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    bookingId?: SortOrder
    assignedTo?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    reporterType?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    reportedUserType?: SortOrder
    bookingId?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    evidence?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    reporterType?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    reportedUserType?: SortOrder
    bookingId?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    evidence?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    bookingId?: SortOrder
    assignedTo?: SortOrder
  }

  export type EnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type EnumReporterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReporterType | EnumReporterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReporterTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReporterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReporterTypeFilter<$PrismaModel>
    _max?: NestedEnumReporterTypeFilter<$PrismaModel>
  }

  export type EnumReporterTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReporterType | EnumReporterTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReporterTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReporterType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReporterTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumReporterTypeNullableFilter<$PrismaModel>
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type EnumReportPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportPriority | EnumReportPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ReportPriority[] | ListEnumReportPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportPriority[] | ListEnumReportPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumReportPriorityWithAggregatesFilter<$PrismaModel> | $Enums.ReportPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportPriorityFilter<$PrismaModel>
    _max?: NestedEnumReportPriorityFilter<$PrismaModel>
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    reviewText?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    reviewText?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    reviewText?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    stripePaymentIntentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    stripePaymentIntentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    stripePaymentIntentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    stripePaymentId?: SortOrder
    stripePaymentIntent?: SortOrder
    platformFee?: SortOrder
    contractorPayout?: SortOrder
    stripeTransferId?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    platformFee?: SortOrder
    contractorPayout?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    stripePaymentId?: SortOrder
    stripePaymentIntent?: SortOrder
    platformFee?: SortOrder
    contractorPayout?: SortOrder
    stripeTransferId?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    stripePaymentId?: SortOrder
    stripePaymentIntent?: SortOrder
    platformFee?: SortOrder
    contractorPayout?: SortOrder
    stripeTransferId?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    platformFee?: SortOrder
    contractorPayout?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type AvailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    dayOfWeek?: SortOrder
    specificDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxBookings?: SortOrder
    isAvailable?: SortOrder
    isRecurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvailabilityAvgOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    dayOfWeek?: SortOrder
    maxBookings?: SortOrder
  }

  export type AvailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    dayOfWeek?: SortOrder
    specificDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxBookings?: SortOrder
    isAvailable?: SortOrder
    isRecurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    dayOfWeek?: SortOrder
    specificDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxBookings?: SortOrder
    isAvailable?: SortOrder
    isRecurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvailabilitySumOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    dayOfWeek?: SortOrder
    maxBookings?: SortOrder
  }

  export type EnumSlotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeFilter<$PrismaModel> | $Enums.SlotType
  }

  export type TimeSlotCountOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotType?: SortOrder
    bookingId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeSlotAvgOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    bookingId?: SortOrder
  }

  export type TimeSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotType?: SortOrder
    bookingId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeSlotMinOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    slotType?: SortOrder
    bookingId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeSlotSumOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    bookingId?: SortOrder
  }

  export type EnumSlotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel> | $Enums.SlotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSlotTypeFilter<$PrismaModel>
    _max?: NestedEnumSlotTypeFilter<$PrismaModel>
  }

  export type ServiceAreaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAreaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceAreaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAreaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAreaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContractorServiceAreaCountOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    dayOfWeek?: SortOrder
    area?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractorServiceAreaAvgOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    dayOfWeek?: SortOrder
  }

  export type ContractorServiceAreaMaxOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    dayOfWeek?: SortOrder
    area?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractorServiceAreaMinOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    dayOfWeek?: SortOrder
    area?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractorServiceAreaSumOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    dayOfWeek?: SortOrder
  }

  export type FavoriteContractorClientIdContractorIdCompoundUniqueInput = {
    clientId: number
    contractorId: number
  }

  export type FavoriteContractorCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    contractorId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteContractorAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    contractorId?: SortOrder
  }

  export type FavoriteContractorMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    contractorId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteContractorMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    contractorId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteContractorSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    contractorId?: SortOrder
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    price?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    id?: SortOrder
    contractorId?: SortOrder
    price?: SortOrder
  }

  export type EnumActivitySeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivitySeverity | EnumActivitySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ActivitySeverity[] | ListEnumActivitySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivitySeverity[] | ListEnumActivitySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumActivitySeverityFilter<$PrismaModel> | $Enums.ActivitySeverity
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    severity?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumActivitySeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivitySeverity | EnumActivitySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ActivitySeverity[] | ListEnumActivitySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivitySeverity[] | ListEnumActivitySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumActivitySeverityWithAggregatesFilter<$PrismaModel> | $Enums.ActivitySeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivitySeverityFilter<$PrismaModel>
    _max?: NestedEnumActivitySeverityFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ClientCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type ContractorCreateNestedOneWithoutUserInput = {
    create?: XOR<ContractorCreateWithoutUserInput, ContractorUncheckedCreateWithoutUserInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutUserInput
    connect?: ContractorWhereUniqueInput
  }

  export type ClientUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type ContractorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ContractorCreateWithoutUserInput, ContractorUncheckedCreateWithoutUserInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutUserInput
    connect?: ContractorWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type EnumAuthProviderFieldUpdateOperationsInput = {
    set?: $Enums.AuthProvider
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClientUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ContractorUpdateOneWithoutUserNestedInput = {
    create?: XOR<ContractorCreateWithoutUserInput, ContractorUncheckedCreateWithoutUserInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutUserInput
    upsert?: ContractorUpsertWithoutUserInput
    disconnect?: ContractorWhereInput | boolean
    delete?: ContractorWhereInput | boolean
    connect?: ContractorWhereUniqueInput
    update?: XOR<XOR<ContractorUpdateToOneWithWhereWithoutUserInput, ContractorUpdateWithoutUserInput>, ContractorUncheckedUpdateWithoutUserInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ContractorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ContractorCreateWithoutUserInput, ContractorUncheckedCreateWithoutUserInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutUserInput
    upsert?: ContractorUpsertWithoutUserInput
    disconnect?: ContractorWhereInput | boolean
    delete?: ContractorWhereInput | boolean
    connect?: ContractorWhereUniqueInput
    update?: XOR<XOR<ContractorUpdateToOneWithWhereWithoutUserInput, ContractorUpdateWithoutUserInput>, ContractorUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    connect?: UserWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutClientInput = {
    create?: XOR<BookingCreateWithoutClientInput, BookingUncheckedCreateWithoutClientInput> | BookingCreateWithoutClientInput[] | BookingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutClientInput | BookingCreateOrConnectWithoutClientInput[]
    createMany?: BookingCreateManyClientInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutClientInput = {
    create?: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput> | ReviewCreateWithoutClientInput[] | ReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutClientInput | ReviewCreateOrConnectWithoutClientInput[]
    createMany?: ReviewCreateManyClientInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutClientInput = {
    create?: XOR<MessageCreateWithoutClientInput, MessageUncheckedCreateWithoutClientInput> | MessageCreateWithoutClientInput[] | MessageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClientInput | MessageCreateOrConnectWithoutClientInput[]
    createMany?: MessageCreateManyClientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type FlaggedMessageCreateNestedManyWithoutClientInput = {
    create?: XOR<FlaggedMessageCreateWithoutClientInput, FlaggedMessageUncheckedCreateWithoutClientInput> | FlaggedMessageCreateWithoutClientInput[] | FlaggedMessageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FlaggedMessageCreateOrConnectWithoutClientInput | FlaggedMessageCreateOrConnectWithoutClientInput[]
    createMany?: FlaggedMessageCreateManyClientInputEnvelope
    connect?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
  }

  export type FavoriteContractorCreateNestedManyWithoutClientInput = {
    create?: XOR<FavoriteContractorCreateWithoutClientInput, FavoriteContractorUncheckedCreateWithoutClientInput> | FavoriteContractorCreateWithoutClientInput[] | FavoriteContractorUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FavoriteContractorCreateOrConnectWithoutClientInput | FavoriteContractorCreateOrConnectWithoutClientInput[]
    createMany?: FavoriteContractorCreateManyClientInputEnvelope
    connect?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<BookingCreateWithoutClientInput, BookingUncheckedCreateWithoutClientInput> | BookingCreateWithoutClientInput[] | BookingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutClientInput | BookingCreateOrConnectWithoutClientInput[]
    createMany?: BookingCreateManyClientInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput> | ReviewCreateWithoutClientInput[] | ReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutClientInput | ReviewCreateOrConnectWithoutClientInput[]
    createMany?: ReviewCreateManyClientInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<MessageCreateWithoutClientInput, MessageUncheckedCreateWithoutClientInput> | MessageCreateWithoutClientInput[] | MessageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClientInput | MessageCreateOrConnectWithoutClientInput[]
    createMany?: MessageCreateManyClientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type FlaggedMessageUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<FlaggedMessageCreateWithoutClientInput, FlaggedMessageUncheckedCreateWithoutClientInput> | FlaggedMessageCreateWithoutClientInput[] | FlaggedMessageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FlaggedMessageCreateOrConnectWithoutClientInput | FlaggedMessageCreateOrConnectWithoutClientInput[]
    createMany?: FlaggedMessageCreateManyClientInputEnvelope
    connect?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
  }

  export type FavoriteContractorUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<FavoriteContractorCreateWithoutClientInput, FavoriteContractorUncheckedCreateWithoutClientInput> | FavoriteContractorCreateWithoutClientInput[] | FavoriteContractorUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FavoriteContractorCreateOrConnectWithoutClientInput | FavoriteContractorCreateOrConnectWithoutClientInput[]
    createMany?: FavoriteContractorCreateManyClientInputEnvelope
    connect?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    upsert?: UserUpsertWithoutClientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientInput, UserUpdateWithoutClientInput>, UserUncheckedUpdateWithoutClientInput>
  }

  export type BookingUpdateManyWithoutClientNestedInput = {
    create?: XOR<BookingCreateWithoutClientInput, BookingUncheckedCreateWithoutClientInput> | BookingCreateWithoutClientInput[] | BookingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutClientInput | BookingCreateOrConnectWithoutClientInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutClientInput | BookingUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: BookingCreateManyClientInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutClientInput | BookingUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutClientInput | BookingUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput> | ReviewCreateWithoutClientInput[] | ReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutClientInput | ReviewCreateOrConnectWithoutClientInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutClientInput | ReviewUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReviewCreateManyClientInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutClientInput | ReviewUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutClientInput | ReviewUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutClientNestedInput = {
    create?: XOR<MessageCreateWithoutClientInput, MessageUncheckedCreateWithoutClientInput> | MessageCreateWithoutClientInput[] | MessageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClientInput | MessageCreateOrConnectWithoutClientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutClientInput | MessageUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MessageCreateManyClientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutClientInput | MessageUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutClientInput | MessageUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type FlaggedMessageUpdateManyWithoutClientNestedInput = {
    create?: XOR<FlaggedMessageCreateWithoutClientInput, FlaggedMessageUncheckedCreateWithoutClientInput> | FlaggedMessageCreateWithoutClientInput[] | FlaggedMessageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FlaggedMessageCreateOrConnectWithoutClientInput | FlaggedMessageCreateOrConnectWithoutClientInput[]
    upsert?: FlaggedMessageUpsertWithWhereUniqueWithoutClientInput | FlaggedMessageUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: FlaggedMessageCreateManyClientInputEnvelope
    set?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    disconnect?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    delete?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    connect?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    update?: FlaggedMessageUpdateWithWhereUniqueWithoutClientInput | FlaggedMessageUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: FlaggedMessageUpdateManyWithWhereWithoutClientInput | FlaggedMessageUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: FlaggedMessageScalarWhereInput | FlaggedMessageScalarWhereInput[]
  }

  export type FavoriteContractorUpdateManyWithoutClientNestedInput = {
    create?: XOR<FavoriteContractorCreateWithoutClientInput, FavoriteContractorUncheckedCreateWithoutClientInput> | FavoriteContractorCreateWithoutClientInput[] | FavoriteContractorUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FavoriteContractorCreateOrConnectWithoutClientInput | FavoriteContractorCreateOrConnectWithoutClientInput[]
    upsert?: FavoriteContractorUpsertWithWhereUniqueWithoutClientInput | FavoriteContractorUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: FavoriteContractorCreateManyClientInputEnvelope
    set?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    disconnect?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    delete?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    connect?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    update?: FavoriteContractorUpdateWithWhereUniqueWithoutClientInput | FavoriteContractorUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: FavoriteContractorUpdateManyWithWhereWithoutClientInput | FavoriteContractorUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: FavoriteContractorScalarWhereInput | FavoriteContractorScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<BookingCreateWithoutClientInput, BookingUncheckedCreateWithoutClientInput> | BookingCreateWithoutClientInput[] | BookingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutClientInput | BookingCreateOrConnectWithoutClientInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutClientInput | BookingUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: BookingCreateManyClientInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutClientInput | BookingUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutClientInput | BookingUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput> | ReviewCreateWithoutClientInput[] | ReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutClientInput | ReviewCreateOrConnectWithoutClientInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutClientInput | ReviewUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReviewCreateManyClientInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutClientInput | ReviewUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutClientInput | ReviewUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<MessageCreateWithoutClientInput, MessageUncheckedCreateWithoutClientInput> | MessageCreateWithoutClientInput[] | MessageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClientInput | MessageCreateOrConnectWithoutClientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutClientInput | MessageUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MessageCreateManyClientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutClientInput | MessageUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutClientInput | MessageUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type FlaggedMessageUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<FlaggedMessageCreateWithoutClientInput, FlaggedMessageUncheckedCreateWithoutClientInput> | FlaggedMessageCreateWithoutClientInput[] | FlaggedMessageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FlaggedMessageCreateOrConnectWithoutClientInput | FlaggedMessageCreateOrConnectWithoutClientInput[]
    upsert?: FlaggedMessageUpsertWithWhereUniqueWithoutClientInput | FlaggedMessageUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: FlaggedMessageCreateManyClientInputEnvelope
    set?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    disconnect?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    delete?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    connect?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    update?: FlaggedMessageUpdateWithWhereUniqueWithoutClientInput | FlaggedMessageUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: FlaggedMessageUpdateManyWithWhereWithoutClientInput | FlaggedMessageUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: FlaggedMessageScalarWhereInput | FlaggedMessageScalarWhereInput[]
  }

  export type FavoriteContractorUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<FavoriteContractorCreateWithoutClientInput, FavoriteContractorUncheckedCreateWithoutClientInput> | FavoriteContractorCreateWithoutClientInput[] | FavoriteContractorUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FavoriteContractorCreateOrConnectWithoutClientInput | FavoriteContractorCreateOrConnectWithoutClientInput[]
    upsert?: FavoriteContractorUpsertWithWhereUniqueWithoutClientInput | FavoriteContractorUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: FavoriteContractorCreateManyClientInputEnvelope
    set?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    disconnect?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    delete?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    connect?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    update?: FavoriteContractorUpdateWithWhereUniqueWithoutClientInput | FavoriteContractorUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: FavoriteContractorUpdateManyWithWhereWithoutClientInput | FavoriteContractorUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: FavoriteContractorScalarWhereInput | FavoriteContractorScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutContractorInput = {
    create?: XOR<UserCreateWithoutContractorInput, UserUncheckedCreateWithoutContractorInput>
    connectOrCreate?: UserCreateOrConnectWithoutContractorInput
    connect?: UserWhereUniqueInput
  }

  export type ContractorServiceCreateNestedManyWithoutContractorInput = {
    create?: XOR<ContractorServiceCreateWithoutContractorInput, ContractorServiceUncheckedCreateWithoutContractorInput> | ContractorServiceCreateWithoutContractorInput[] | ContractorServiceUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ContractorServiceCreateOrConnectWithoutContractorInput | ContractorServiceCreateOrConnectWithoutContractorInput[]
    createMany?: ContractorServiceCreateManyContractorInputEnvelope
    connect?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutContractorInput = {
    create?: XOR<BookingCreateWithoutContractorInput, BookingUncheckedCreateWithoutContractorInput> | BookingCreateWithoutContractorInput[] | BookingUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutContractorInput | BookingCreateOrConnectWithoutContractorInput[]
    createMany?: BookingCreateManyContractorInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutContractorInput = {
    create?: XOR<ReviewCreateWithoutContractorInput, ReviewUncheckedCreateWithoutContractorInput> | ReviewCreateWithoutContractorInput[] | ReviewUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutContractorInput | ReviewCreateOrConnectWithoutContractorInput[]
    createMany?: ReviewCreateManyContractorInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutContractorInput = {
    create?: XOR<MessageCreateWithoutContractorInput, MessageUncheckedCreateWithoutContractorInput> | MessageCreateWithoutContractorInput[] | MessageUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContractorInput | MessageCreateOrConnectWithoutContractorInput[]
    createMany?: MessageCreateManyContractorInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type AvailabilityCreateNestedManyWithoutContractorInput = {
    create?: XOR<AvailabilityCreateWithoutContractorInput, AvailabilityUncheckedCreateWithoutContractorInput> | AvailabilityCreateWithoutContractorInput[] | AvailabilityUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutContractorInput | AvailabilityCreateOrConnectWithoutContractorInput[]
    createMany?: AvailabilityCreateManyContractorInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type TimeSlotCreateNestedManyWithoutContractorInput = {
    create?: XOR<TimeSlotCreateWithoutContractorInput, TimeSlotUncheckedCreateWithoutContractorInput> | TimeSlotCreateWithoutContractorInput[] | TimeSlotUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutContractorInput | TimeSlotCreateOrConnectWithoutContractorInput[]
    createMany?: TimeSlotCreateManyContractorInputEnvelope
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
  }

  export type ContractorServiceAreaCreateNestedManyWithoutContractorInput = {
    create?: XOR<ContractorServiceAreaCreateWithoutContractorInput, ContractorServiceAreaUncheckedCreateWithoutContractorInput> | ContractorServiceAreaCreateWithoutContractorInput[] | ContractorServiceAreaUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ContractorServiceAreaCreateOrConnectWithoutContractorInput | ContractorServiceAreaCreateOrConnectWithoutContractorInput[]
    createMany?: ContractorServiceAreaCreateManyContractorInputEnvelope
    connect?: ContractorServiceAreaWhereUniqueInput | ContractorServiceAreaWhereUniqueInput[]
  }

  export type FlaggedMessageCreateNestedManyWithoutContractorInput = {
    create?: XOR<FlaggedMessageCreateWithoutContractorInput, FlaggedMessageUncheckedCreateWithoutContractorInput> | FlaggedMessageCreateWithoutContractorInput[] | FlaggedMessageUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: FlaggedMessageCreateOrConnectWithoutContractorInput | FlaggedMessageCreateOrConnectWithoutContractorInput[]
    createMany?: FlaggedMessageCreateManyContractorInputEnvelope
    connect?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
  }

  export type FavoriteContractorCreateNestedManyWithoutContractorInput = {
    create?: XOR<FavoriteContractorCreateWithoutContractorInput, FavoriteContractorUncheckedCreateWithoutContractorInput> | FavoriteContractorCreateWithoutContractorInput[] | FavoriteContractorUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: FavoriteContractorCreateOrConnectWithoutContractorInput | FavoriteContractorCreateOrConnectWithoutContractorInput[]
    createMany?: FavoriteContractorCreateManyContractorInputEnvelope
    connect?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
  }

  export type MaterialCreateNestedManyWithoutContractorInput = {
    create?: XOR<MaterialCreateWithoutContractorInput, MaterialUncheckedCreateWithoutContractorInput> | MaterialCreateWithoutContractorInput[] | MaterialUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutContractorInput | MaterialCreateOrConnectWithoutContractorInput[]
    createMany?: MaterialCreateManyContractorInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type ContractorLanguageCreateNestedManyWithoutContractorInput = {
    create?: XOR<ContractorLanguageCreateWithoutContractorInput, ContractorLanguageUncheckedCreateWithoutContractorInput> | ContractorLanguageCreateWithoutContractorInput[] | ContractorLanguageUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ContractorLanguageCreateOrConnectWithoutContractorInput | ContractorLanguageCreateOrConnectWithoutContractorInput[]
    createMany?: ContractorLanguageCreateManyContractorInputEnvelope
    connect?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutContractorInput = {
    create?: XOR<SubscriptionCreateWithoutContractorInput, SubscriptionUncheckedCreateWithoutContractorInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutContractorInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type ContractorServiceUncheckedCreateNestedManyWithoutContractorInput = {
    create?: XOR<ContractorServiceCreateWithoutContractorInput, ContractorServiceUncheckedCreateWithoutContractorInput> | ContractorServiceCreateWithoutContractorInput[] | ContractorServiceUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ContractorServiceCreateOrConnectWithoutContractorInput | ContractorServiceCreateOrConnectWithoutContractorInput[]
    createMany?: ContractorServiceCreateManyContractorInputEnvelope
    connect?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutContractorInput = {
    create?: XOR<BookingCreateWithoutContractorInput, BookingUncheckedCreateWithoutContractorInput> | BookingCreateWithoutContractorInput[] | BookingUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutContractorInput | BookingCreateOrConnectWithoutContractorInput[]
    createMany?: BookingCreateManyContractorInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutContractorInput = {
    create?: XOR<ReviewCreateWithoutContractorInput, ReviewUncheckedCreateWithoutContractorInput> | ReviewCreateWithoutContractorInput[] | ReviewUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutContractorInput | ReviewCreateOrConnectWithoutContractorInput[]
    createMany?: ReviewCreateManyContractorInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutContractorInput = {
    create?: XOR<MessageCreateWithoutContractorInput, MessageUncheckedCreateWithoutContractorInput> | MessageCreateWithoutContractorInput[] | MessageUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContractorInput | MessageCreateOrConnectWithoutContractorInput[]
    createMany?: MessageCreateManyContractorInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type AvailabilityUncheckedCreateNestedManyWithoutContractorInput = {
    create?: XOR<AvailabilityCreateWithoutContractorInput, AvailabilityUncheckedCreateWithoutContractorInput> | AvailabilityCreateWithoutContractorInput[] | AvailabilityUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutContractorInput | AvailabilityCreateOrConnectWithoutContractorInput[]
    createMany?: AvailabilityCreateManyContractorInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type TimeSlotUncheckedCreateNestedManyWithoutContractorInput = {
    create?: XOR<TimeSlotCreateWithoutContractorInput, TimeSlotUncheckedCreateWithoutContractorInput> | TimeSlotCreateWithoutContractorInput[] | TimeSlotUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutContractorInput | TimeSlotCreateOrConnectWithoutContractorInput[]
    createMany?: TimeSlotCreateManyContractorInputEnvelope
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
  }

  export type ContractorServiceAreaUncheckedCreateNestedManyWithoutContractorInput = {
    create?: XOR<ContractorServiceAreaCreateWithoutContractorInput, ContractorServiceAreaUncheckedCreateWithoutContractorInput> | ContractorServiceAreaCreateWithoutContractorInput[] | ContractorServiceAreaUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ContractorServiceAreaCreateOrConnectWithoutContractorInput | ContractorServiceAreaCreateOrConnectWithoutContractorInput[]
    createMany?: ContractorServiceAreaCreateManyContractorInputEnvelope
    connect?: ContractorServiceAreaWhereUniqueInput | ContractorServiceAreaWhereUniqueInput[]
  }

  export type FlaggedMessageUncheckedCreateNestedManyWithoutContractorInput = {
    create?: XOR<FlaggedMessageCreateWithoutContractorInput, FlaggedMessageUncheckedCreateWithoutContractorInput> | FlaggedMessageCreateWithoutContractorInput[] | FlaggedMessageUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: FlaggedMessageCreateOrConnectWithoutContractorInput | FlaggedMessageCreateOrConnectWithoutContractorInput[]
    createMany?: FlaggedMessageCreateManyContractorInputEnvelope
    connect?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
  }

  export type FavoriteContractorUncheckedCreateNestedManyWithoutContractorInput = {
    create?: XOR<FavoriteContractorCreateWithoutContractorInput, FavoriteContractorUncheckedCreateWithoutContractorInput> | FavoriteContractorCreateWithoutContractorInput[] | FavoriteContractorUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: FavoriteContractorCreateOrConnectWithoutContractorInput | FavoriteContractorCreateOrConnectWithoutContractorInput[]
    createMany?: FavoriteContractorCreateManyContractorInputEnvelope
    connect?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutContractorInput = {
    create?: XOR<MaterialCreateWithoutContractorInput, MaterialUncheckedCreateWithoutContractorInput> | MaterialCreateWithoutContractorInput[] | MaterialUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutContractorInput | MaterialCreateOrConnectWithoutContractorInput[]
    createMany?: MaterialCreateManyContractorInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type ContractorLanguageUncheckedCreateNestedManyWithoutContractorInput = {
    create?: XOR<ContractorLanguageCreateWithoutContractorInput, ContractorLanguageUncheckedCreateWithoutContractorInput> | ContractorLanguageCreateWithoutContractorInput[] | ContractorLanguageUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ContractorLanguageCreateOrConnectWithoutContractorInput | ContractorLanguageCreateOrConnectWithoutContractorInput[]
    createMany?: ContractorLanguageCreateManyContractorInputEnvelope
    connect?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutContractorInput = {
    create?: XOR<SubscriptionCreateWithoutContractorInput, SubscriptionUncheckedCreateWithoutContractorInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutContractorInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutContractorNestedInput = {
    create?: XOR<UserCreateWithoutContractorInput, UserUncheckedCreateWithoutContractorInput>
    connectOrCreate?: UserCreateOrConnectWithoutContractorInput
    upsert?: UserUpsertWithoutContractorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContractorInput, UserUpdateWithoutContractorInput>, UserUncheckedUpdateWithoutContractorInput>
  }

  export type ContractorServiceUpdateManyWithoutContractorNestedInput = {
    create?: XOR<ContractorServiceCreateWithoutContractorInput, ContractorServiceUncheckedCreateWithoutContractorInput> | ContractorServiceCreateWithoutContractorInput[] | ContractorServiceUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ContractorServiceCreateOrConnectWithoutContractorInput | ContractorServiceCreateOrConnectWithoutContractorInput[]
    upsert?: ContractorServiceUpsertWithWhereUniqueWithoutContractorInput | ContractorServiceUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: ContractorServiceCreateManyContractorInputEnvelope
    set?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    disconnect?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    delete?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    connect?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    update?: ContractorServiceUpdateWithWhereUniqueWithoutContractorInput | ContractorServiceUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: ContractorServiceUpdateManyWithWhereWithoutContractorInput | ContractorServiceUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: ContractorServiceScalarWhereInput | ContractorServiceScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutContractorNestedInput = {
    create?: XOR<BookingCreateWithoutContractorInput, BookingUncheckedCreateWithoutContractorInput> | BookingCreateWithoutContractorInput[] | BookingUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutContractorInput | BookingCreateOrConnectWithoutContractorInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutContractorInput | BookingUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: BookingCreateManyContractorInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutContractorInput | BookingUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutContractorInput | BookingUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutContractorNestedInput = {
    create?: XOR<ReviewCreateWithoutContractorInput, ReviewUncheckedCreateWithoutContractorInput> | ReviewCreateWithoutContractorInput[] | ReviewUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutContractorInput | ReviewCreateOrConnectWithoutContractorInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutContractorInput | ReviewUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: ReviewCreateManyContractorInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutContractorInput | ReviewUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutContractorInput | ReviewUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutContractorNestedInput = {
    create?: XOR<MessageCreateWithoutContractorInput, MessageUncheckedCreateWithoutContractorInput> | MessageCreateWithoutContractorInput[] | MessageUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContractorInput | MessageCreateOrConnectWithoutContractorInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutContractorInput | MessageUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: MessageCreateManyContractorInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutContractorInput | MessageUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutContractorInput | MessageUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type AvailabilityUpdateManyWithoutContractorNestedInput = {
    create?: XOR<AvailabilityCreateWithoutContractorInput, AvailabilityUncheckedCreateWithoutContractorInput> | AvailabilityCreateWithoutContractorInput[] | AvailabilityUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutContractorInput | AvailabilityCreateOrConnectWithoutContractorInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutContractorInput | AvailabilityUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: AvailabilityCreateManyContractorInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutContractorInput | AvailabilityUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutContractorInput | AvailabilityUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type TimeSlotUpdateManyWithoutContractorNestedInput = {
    create?: XOR<TimeSlotCreateWithoutContractorInput, TimeSlotUncheckedCreateWithoutContractorInput> | TimeSlotCreateWithoutContractorInput[] | TimeSlotUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutContractorInput | TimeSlotCreateOrConnectWithoutContractorInput[]
    upsert?: TimeSlotUpsertWithWhereUniqueWithoutContractorInput | TimeSlotUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: TimeSlotCreateManyContractorInputEnvelope
    set?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    disconnect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    delete?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    update?: TimeSlotUpdateWithWhereUniqueWithoutContractorInput | TimeSlotUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: TimeSlotUpdateManyWithWhereWithoutContractorInput | TimeSlotUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
  }

  export type ContractorServiceAreaUpdateManyWithoutContractorNestedInput = {
    create?: XOR<ContractorServiceAreaCreateWithoutContractorInput, ContractorServiceAreaUncheckedCreateWithoutContractorInput> | ContractorServiceAreaCreateWithoutContractorInput[] | ContractorServiceAreaUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ContractorServiceAreaCreateOrConnectWithoutContractorInput | ContractorServiceAreaCreateOrConnectWithoutContractorInput[]
    upsert?: ContractorServiceAreaUpsertWithWhereUniqueWithoutContractorInput | ContractorServiceAreaUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: ContractorServiceAreaCreateManyContractorInputEnvelope
    set?: ContractorServiceAreaWhereUniqueInput | ContractorServiceAreaWhereUniqueInput[]
    disconnect?: ContractorServiceAreaWhereUniqueInput | ContractorServiceAreaWhereUniqueInput[]
    delete?: ContractorServiceAreaWhereUniqueInput | ContractorServiceAreaWhereUniqueInput[]
    connect?: ContractorServiceAreaWhereUniqueInput | ContractorServiceAreaWhereUniqueInput[]
    update?: ContractorServiceAreaUpdateWithWhereUniqueWithoutContractorInput | ContractorServiceAreaUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: ContractorServiceAreaUpdateManyWithWhereWithoutContractorInput | ContractorServiceAreaUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: ContractorServiceAreaScalarWhereInput | ContractorServiceAreaScalarWhereInput[]
  }

  export type FlaggedMessageUpdateManyWithoutContractorNestedInput = {
    create?: XOR<FlaggedMessageCreateWithoutContractorInput, FlaggedMessageUncheckedCreateWithoutContractorInput> | FlaggedMessageCreateWithoutContractorInput[] | FlaggedMessageUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: FlaggedMessageCreateOrConnectWithoutContractorInput | FlaggedMessageCreateOrConnectWithoutContractorInput[]
    upsert?: FlaggedMessageUpsertWithWhereUniqueWithoutContractorInput | FlaggedMessageUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: FlaggedMessageCreateManyContractorInputEnvelope
    set?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    disconnect?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    delete?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    connect?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    update?: FlaggedMessageUpdateWithWhereUniqueWithoutContractorInput | FlaggedMessageUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: FlaggedMessageUpdateManyWithWhereWithoutContractorInput | FlaggedMessageUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: FlaggedMessageScalarWhereInput | FlaggedMessageScalarWhereInput[]
  }

  export type FavoriteContractorUpdateManyWithoutContractorNestedInput = {
    create?: XOR<FavoriteContractorCreateWithoutContractorInput, FavoriteContractorUncheckedCreateWithoutContractorInput> | FavoriteContractorCreateWithoutContractorInput[] | FavoriteContractorUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: FavoriteContractorCreateOrConnectWithoutContractorInput | FavoriteContractorCreateOrConnectWithoutContractorInput[]
    upsert?: FavoriteContractorUpsertWithWhereUniqueWithoutContractorInput | FavoriteContractorUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: FavoriteContractorCreateManyContractorInputEnvelope
    set?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    disconnect?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    delete?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    connect?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    update?: FavoriteContractorUpdateWithWhereUniqueWithoutContractorInput | FavoriteContractorUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: FavoriteContractorUpdateManyWithWhereWithoutContractorInput | FavoriteContractorUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: FavoriteContractorScalarWhereInput | FavoriteContractorScalarWhereInput[]
  }

  export type MaterialUpdateManyWithoutContractorNestedInput = {
    create?: XOR<MaterialCreateWithoutContractorInput, MaterialUncheckedCreateWithoutContractorInput> | MaterialCreateWithoutContractorInput[] | MaterialUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutContractorInput | MaterialCreateOrConnectWithoutContractorInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutContractorInput | MaterialUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: MaterialCreateManyContractorInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutContractorInput | MaterialUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutContractorInput | MaterialUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type ContractorLanguageUpdateManyWithoutContractorNestedInput = {
    create?: XOR<ContractorLanguageCreateWithoutContractorInput, ContractorLanguageUncheckedCreateWithoutContractorInput> | ContractorLanguageCreateWithoutContractorInput[] | ContractorLanguageUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ContractorLanguageCreateOrConnectWithoutContractorInput | ContractorLanguageCreateOrConnectWithoutContractorInput[]
    upsert?: ContractorLanguageUpsertWithWhereUniqueWithoutContractorInput | ContractorLanguageUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: ContractorLanguageCreateManyContractorInputEnvelope
    set?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    disconnect?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    delete?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    connect?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    update?: ContractorLanguageUpdateWithWhereUniqueWithoutContractorInput | ContractorLanguageUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: ContractorLanguageUpdateManyWithWhereWithoutContractorInput | ContractorLanguageUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: ContractorLanguageScalarWhereInput | ContractorLanguageScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutContractorNestedInput = {
    create?: XOR<SubscriptionCreateWithoutContractorInput, SubscriptionUncheckedCreateWithoutContractorInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutContractorInput
    upsert?: SubscriptionUpsertWithoutContractorInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutContractorInput, SubscriptionUpdateWithoutContractorInput>, SubscriptionUncheckedUpdateWithoutContractorInput>
  }

  export type ContractorServiceUncheckedUpdateManyWithoutContractorNestedInput = {
    create?: XOR<ContractorServiceCreateWithoutContractorInput, ContractorServiceUncheckedCreateWithoutContractorInput> | ContractorServiceCreateWithoutContractorInput[] | ContractorServiceUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ContractorServiceCreateOrConnectWithoutContractorInput | ContractorServiceCreateOrConnectWithoutContractorInput[]
    upsert?: ContractorServiceUpsertWithWhereUniqueWithoutContractorInput | ContractorServiceUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: ContractorServiceCreateManyContractorInputEnvelope
    set?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    disconnect?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    delete?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    connect?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    update?: ContractorServiceUpdateWithWhereUniqueWithoutContractorInput | ContractorServiceUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: ContractorServiceUpdateManyWithWhereWithoutContractorInput | ContractorServiceUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: ContractorServiceScalarWhereInput | ContractorServiceScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutContractorNestedInput = {
    create?: XOR<BookingCreateWithoutContractorInput, BookingUncheckedCreateWithoutContractorInput> | BookingCreateWithoutContractorInput[] | BookingUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutContractorInput | BookingCreateOrConnectWithoutContractorInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutContractorInput | BookingUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: BookingCreateManyContractorInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutContractorInput | BookingUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutContractorInput | BookingUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutContractorNestedInput = {
    create?: XOR<ReviewCreateWithoutContractorInput, ReviewUncheckedCreateWithoutContractorInput> | ReviewCreateWithoutContractorInput[] | ReviewUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutContractorInput | ReviewCreateOrConnectWithoutContractorInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutContractorInput | ReviewUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: ReviewCreateManyContractorInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutContractorInput | ReviewUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutContractorInput | ReviewUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutContractorNestedInput = {
    create?: XOR<MessageCreateWithoutContractorInput, MessageUncheckedCreateWithoutContractorInput> | MessageCreateWithoutContractorInput[] | MessageUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContractorInput | MessageCreateOrConnectWithoutContractorInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutContractorInput | MessageUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: MessageCreateManyContractorInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutContractorInput | MessageUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutContractorInput | MessageUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type AvailabilityUncheckedUpdateManyWithoutContractorNestedInput = {
    create?: XOR<AvailabilityCreateWithoutContractorInput, AvailabilityUncheckedCreateWithoutContractorInput> | AvailabilityCreateWithoutContractorInput[] | AvailabilityUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutContractorInput | AvailabilityCreateOrConnectWithoutContractorInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutContractorInput | AvailabilityUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: AvailabilityCreateManyContractorInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutContractorInput | AvailabilityUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutContractorInput | AvailabilityUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type TimeSlotUncheckedUpdateManyWithoutContractorNestedInput = {
    create?: XOR<TimeSlotCreateWithoutContractorInput, TimeSlotUncheckedCreateWithoutContractorInput> | TimeSlotCreateWithoutContractorInput[] | TimeSlotUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutContractorInput | TimeSlotCreateOrConnectWithoutContractorInput[]
    upsert?: TimeSlotUpsertWithWhereUniqueWithoutContractorInput | TimeSlotUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: TimeSlotCreateManyContractorInputEnvelope
    set?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    disconnect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    delete?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    update?: TimeSlotUpdateWithWhereUniqueWithoutContractorInput | TimeSlotUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: TimeSlotUpdateManyWithWhereWithoutContractorInput | TimeSlotUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
  }

  export type ContractorServiceAreaUncheckedUpdateManyWithoutContractorNestedInput = {
    create?: XOR<ContractorServiceAreaCreateWithoutContractorInput, ContractorServiceAreaUncheckedCreateWithoutContractorInput> | ContractorServiceAreaCreateWithoutContractorInput[] | ContractorServiceAreaUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ContractorServiceAreaCreateOrConnectWithoutContractorInput | ContractorServiceAreaCreateOrConnectWithoutContractorInput[]
    upsert?: ContractorServiceAreaUpsertWithWhereUniqueWithoutContractorInput | ContractorServiceAreaUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: ContractorServiceAreaCreateManyContractorInputEnvelope
    set?: ContractorServiceAreaWhereUniqueInput | ContractorServiceAreaWhereUniqueInput[]
    disconnect?: ContractorServiceAreaWhereUniqueInput | ContractorServiceAreaWhereUniqueInput[]
    delete?: ContractorServiceAreaWhereUniqueInput | ContractorServiceAreaWhereUniqueInput[]
    connect?: ContractorServiceAreaWhereUniqueInput | ContractorServiceAreaWhereUniqueInput[]
    update?: ContractorServiceAreaUpdateWithWhereUniqueWithoutContractorInput | ContractorServiceAreaUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: ContractorServiceAreaUpdateManyWithWhereWithoutContractorInput | ContractorServiceAreaUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: ContractorServiceAreaScalarWhereInput | ContractorServiceAreaScalarWhereInput[]
  }

  export type FlaggedMessageUncheckedUpdateManyWithoutContractorNestedInput = {
    create?: XOR<FlaggedMessageCreateWithoutContractorInput, FlaggedMessageUncheckedCreateWithoutContractorInput> | FlaggedMessageCreateWithoutContractorInput[] | FlaggedMessageUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: FlaggedMessageCreateOrConnectWithoutContractorInput | FlaggedMessageCreateOrConnectWithoutContractorInput[]
    upsert?: FlaggedMessageUpsertWithWhereUniqueWithoutContractorInput | FlaggedMessageUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: FlaggedMessageCreateManyContractorInputEnvelope
    set?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    disconnect?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    delete?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    connect?: FlaggedMessageWhereUniqueInput | FlaggedMessageWhereUniqueInput[]
    update?: FlaggedMessageUpdateWithWhereUniqueWithoutContractorInput | FlaggedMessageUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: FlaggedMessageUpdateManyWithWhereWithoutContractorInput | FlaggedMessageUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: FlaggedMessageScalarWhereInput | FlaggedMessageScalarWhereInput[]
  }

  export type FavoriteContractorUncheckedUpdateManyWithoutContractorNestedInput = {
    create?: XOR<FavoriteContractorCreateWithoutContractorInput, FavoriteContractorUncheckedCreateWithoutContractorInput> | FavoriteContractorCreateWithoutContractorInput[] | FavoriteContractorUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: FavoriteContractorCreateOrConnectWithoutContractorInput | FavoriteContractorCreateOrConnectWithoutContractorInput[]
    upsert?: FavoriteContractorUpsertWithWhereUniqueWithoutContractorInput | FavoriteContractorUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: FavoriteContractorCreateManyContractorInputEnvelope
    set?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    disconnect?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    delete?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    connect?: FavoriteContractorWhereUniqueInput | FavoriteContractorWhereUniqueInput[]
    update?: FavoriteContractorUpdateWithWhereUniqueWithoutContractorInput | FavoriteContractorUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: FavoriteContractorUpdateManyWithWhereWithoutContractorInput | FavoriteContractorUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: FavoriteContractorScalarWhereInput | FavoriteContractorScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutContractorNestedInput = {
    create?: XOR<MaterialCreateWithoutContractorInput, MaterialUncheckedCreateWithoutContractorInput> | MaterialCreateWithoutContractorInput[] | MaterialUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutContractorInput | MaterialCreateOrConnectWithoutContractorInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutContractorInput | MaterialUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: MaterialCreateManyContractorInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutContractorInput | MaterialUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutContractorInput | MaterialUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type ContractorLanguageUncheckedUpdateManyWithoutContractorNestedInput = {
    create?: XOR<ContractorLanguageCreateWithoutContractorInput, ContractorLanguageUncheckedCreateWithoutContractorInput> | ContractorLanguageCreateWithoutContractorInput[] | ContractorLanguageUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: ContractorLanguageCreateOrConnectWithoutContractorInput | ContractorLanguageCreateOrConnectWithoutContractorInput[]
    upsert?: ContractorLanguageUpsertWithWhereUniqueWithoutContractorInput | ContractorLanguageUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: ContractorLanguageCreateManyContractorInputEnvelope
    set?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    disconnect?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    delete?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    connect?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    update?: ContractorLanguageUpdateWithWhereUniqueWithoutContractorInput | ContractorLanguageUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: ContractorLanguageUpdateManyWithWhereWithoutContractorInput | ContractorLanguageUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: ContractorLanguageScalarWhereInput | ContractorLanguageScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutContractorNestedInput = {
    create?: XOR<SubscriptionCreateWithoutContractorInput, SubscriptionUncheckedCreateWithoutContractorInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutContractorInput
    upsert?: SubscriptionUpsertWithoutContractorInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutContractorInput, SubscriptionUpdateWithoutContractorInput>, SubscriptionUncheckedUpdateWithoutContractorInput>
  }

  export type ContractorCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<ContractorCreateWithoutSubscriptionInput, ContractorUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutSubscriptionInput
    connect?: ContractorWhereUniqueInput
  }

  export type EnumSubscriptionTierFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionTier
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type ContractorUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<ContractorCreateWithoutSubscriptionInput, ContractorUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutSubscriptionInput
    upsert?: ContractorUpsertWithoutSubscriptionInput
    connect?: ContractorWhereUniqueInput
    update?: XOR<XOR<ContractorUpdateToOneWithWhereWithoutSubscriptionInput, ContractorUpdateWithoutSubscriptionInput>, ContractorUncheckedUpdateWithoutSubscriptionInput>
  }

  export type ContractorLanguageCreateNestedManyWithoutLanguageInput = {
    create?: XOR<ContractorLanguageCreateWithoutLanguageInput, ContractorLanguageUncheckedCreateWithoutLanguageInput> | ContractorLanguageCreateWithoutLanguageInput[] | ContractorLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ContractorLanguageCreateOrConnectWithoutLanguageInput | ContractorLanguageCreateOrConnectWithoutLanguageInput[]
    createMany?: ContractorLanguageCreateManyLanguageInputEnvelope
    connect?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
  }

  export type ContractorLanguageUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<ContractorLanguageCreateWithoutLanguageInput, ContractorLanguageUncheckedCreateWithoutLanguageInput> | ContractorLanguageCreateWithoutLanguageInput[] | ContractorLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ContractorLanguageCreateOrConnectWithoutLanguageInput | ContractorLanguageCreateOrConnectWithoutLanguageInput[]
    createMany?: ContractorLanguageCreateManyLanguageInputEnvelope
    connect?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
  }

  export type ContractorLanguageUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<ContractorLanguageCreateWithoutLanguageInput, ContractorLanguageUncheckedCreateWithoutLanguageInput> | ContractorLanguageCreateWithoutLanguageInput[] | ContractorLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ContractorLanguageCreateOrConnectWithoutLanguageInput | ContractorLanguageCreateOrConnectWithoutLanguageInput[]
    upsert?: ContractorLanguageUpsertWithWhereUniqueWithoutLanguageInput | ContractorLanguageUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: ContractorLanguageCreateManyLanguageInputEnvelope
    set?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    disconnect?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    delete?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    connect?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    update?: ContractorLanguageUpdateWithWhereUniqueWithoutLanguageInput | ContractorLanguageUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: ContractorLanguageUpdateManyWithWhereWithoutLanguageInput | ContractorLanguageUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: ContractorLanguageScalarWhereInput | ContractorLanguageScalarWhereInput[]
  }

  export type ContractorLanguageUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<ContractorLanguageCreateWithoutLanguageInput, ContractorLanguageUncheckedCreateWithoutLanguageInput> | ContractorLanguageCreateWithoutLanguageInput[] | ContractorLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ContractorLanguageCreateOrConnectWithoutLanguageInput | ContractorLanguageCreateOrConnectWithoutLanguageInput[]
    upsert?: ContractorLanguageUpsertWithWhereUniqueWithoutLanguageInput | ContractorLanguageUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: ContractorLanguageCreateManyLanguageInputEnvelope
    set?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    disconnect?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    delete?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    connect?: ContractorLanguageWhereUniqueInput | ContractorLanguageWhereUniqueInput[]
    update?: ContractorLanguageUpdateWithWhereUniqueWithoutLanguageInput | ContractorLanguageUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: ContractorLanguageUpdateManyWithWhereWithoutLanguageInput | ContractorLanguageUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: ContractorLanguageScalarWhereInput | ContractorLanguageScalarWhereInput[]
  }

  export type ContractorCreateNestedOneWithoutLanguagesInput = {
    create?: XOR<ContractorCreateWithoutLanguagesInput, ContractorUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutLanguagesInput
    connect?: ContractorWhereUniqueInput
  }

  export type LanguageCreateNestedOneWithoutContractorsInput = {
    create?: XOR<LanguageCreateWithoutContractorsInput, LanguageUncheckedCreateWithoutContractorsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutContractorsInput
    connect?: LanguageWhereUniqueInput
  }

  export type ContractorUpdateOneRequiredWithoutLanguagesNestedInput = {
    create?: XOR<ContractorCreateWithoutLanguagesInput, ContractorUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutLanguagesInput
    upsert?: ContractorUpsertWithoutLanguagesInput
    connect?: ContractorWhereUniqueInput
    update?: XOR<XOR<ContractorUpdateToOneWithWhereWithoutLanguagesInput, ContractorUpdateWithoutLanguagesInput>, ContractorUncheckedUpdateWithoutLanguagesInput>
  }

  export type LanguageUpdateOneRequiredWithoutContractorsNestedInput = {
    create?: XOR<LanguageCreateWithoutContractorsInput, LanguageUncheckedCreateWithoutContractorsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutContractorsInput
    upsert?: LanguageUpsertWithoutContractorsInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutContractorsInput, LanguageUpdateWithoutContractorsInput>, LanguageUncheckedUpdateWithoutContractorsInput>
  }

  export type ContractorServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<ContractorServiceCreateWithoutServiceInput, ContractorServiceUncheckedCreateWithoutServiceInput> | ContractorServiceCreateWithoutServiceInput[] | ContractorServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ContractorServiceCreateOrConnectWithoutServiceInput | ContractorServiceCreateOrConnectWithoutServiceInput[]
    createMany?: ContractorServiceCreateManyServiceInputEnvelope
    connect?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ContractorServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ContractorServiceCreateWithoutServiceInput, ContractorServiceUncheckedCreateWithoutServiceInput> | ContractorServiceCreateWithoutServiceInput[] | ContractorServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ContractorServiceCreateOrConnectWithoutServiceInput | ContractorServiceCreateOrConnectWithoutServiceInput[]
    createMany?: ContractorServiceCreateManyServiceInputEnvelope
    connect?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ContractorServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ContractorServiceCreateWithoutServiceInput, ContractorServiceUncheckedCreateWithoutServiceInput> | ContractorServiceCreateWithoutServiceInput[] | ContractorServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ContractorServiceCreateOrConnectWithoutServiceInput | ContractorServiceCreateOrConnectWithoutServiceInput[]
    upsert?: ContractorServiceUpsertWithWhereUniqueWithoutServiceInput | ContractorServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ContractorServiceCreateManyServiceInputEnvelope
    set?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    disconnect?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    delete?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    connect?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    update?: ContractorServiceUpdateWithWhereUniqueWithoutServiceInput | ContractorServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ContractorServiceUpdateManyWithWhereWithoutServiceInput | ContractorServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ContractorServiceScalarWhereInput | ContractorServiceScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceInput | BookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceInput | BookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceInput | BookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ContractorServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ContractorServiceCreateWithoutServiceInput, ContractorServiceUncheckedCreateWithoutServiceInput> | ContractorServiceCreateWithoutServiceInput[] | ContractorServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ContractorServiceCreateOrConnectWithoutServiceInput | ContractorServiceCreateOrConnectWithoutServiceInput[]
    upsert?: ContractorServiceUpsertWithWhereUniqueWithoutServiceInput | ContractorServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ContractorServiceCreateManyServiceInputEnvelope
    set?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    disconnect?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    delete?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    connect?: ContractorServiceWhereUniqueInput | ContractorServiceWhereUniqueInput[]
    update?: ContractorServiceUpdateWithWhereUniqueWithoutServiceInput | ContractorServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ContractorServiceUpdateManyWithWhereWithoutServiceInput | ContractorServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ContractorServiceScalarWhereInput | ContractorServiceScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceInput | BookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceInput | BookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceInput | BookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ContractorCreateNestedOneWithoutServicesInput = {
    create?: XOR<ContractorCreateWithoutServicesInput, ContractorUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutServicesInput
    connect?: ContractorWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutContractorsInput = {
    create?: XOR<ServiceCreateWithoutContractorsInput, ServiceUncheckedCreateWithoutContractorsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutContractorsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ContractorUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<ContractorCreateWithoutServicesInput, ContractorUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutServicesInput
    upsert?: ContractorUpsertWithoutServicesInput
    connect?: ContractorWhereUniqueInput
    update?: XOR<XOR<ContractorUpdateToOneWithWhereWithoutServicesInput, ContractorUpdateWithoutServicesInput>, ContractorUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutContractorsNestedInput = {
    create?: XOR<ServiceCreateWithoutContractorsInput, ServiceUncheckedCreateWithoutContractorsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutContractorsInput
    upsert?: ServiceUpsertWithoutContractorsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutContractorsInput, ServiceUpdateWithoutContractorsInput>, ServiceUncheckedUpdateWithoutContractorsInput>
  }

  export type ContractorCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ContractorCreateWithoutBookingsInput, ContractorUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutBookingsInput
    connect?: ContractorWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ClientCreateWithoutBookingsInput, ClientUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutBookingsInput
    connect?: ClientWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
  }

  export type JobCompletionCreateNestedOneWithoutBookingInput = {
    create?: XOR<JobCompletionCreateWithoutBookingInput, JobCompletionUncheckedCreateWithoutBookingInput>
    connectOrCreate?: JobCompletionCreateOrConnectWithoutBookingInput
    connect?: JobCompletionWhereUniqueInput
  }

  export type JobPhotoCreateNestedManyWithoutBookingInput = {
    create?: XOR<JobPhotoCreateWithoutBookingInput, JobPhotoUncheckedCreateWithoutBookingInput> | JobPhotoCreateWithoutBookingInput[] | JobPhotoUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: JobPhotoCreateOrConnectWithoutBookingInput | JobPhotoCreateOrConnectWithoutBookingInput[]
    createMany?: JobPhotoCreateManyBookingInputEnvelope
    connect?: JobPhotoWhereUniqueInput | JobPhotoWhereUniqueInput[]
  }

  export type InvoiceCreateNestedOneWithoutBookingInput = {
    create?: XOR<InvoiceCreateWithoutBookingInput, InvoiceUncheckedCreateWithoutBookingInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutBookingInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutBookingInput = {
    create?: XOR<ReportCreateWithoutBookingInput, ReportUncheckedCreateWithoutBookingInput> | ReportCreateWithoutBookingInput[] | ReportUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutBookingInput | ReportCreateOrConnectWithoutBookingInput[]
    createMany?: ReportCreateManyBookingInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type JobCompletionUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<JobCompletionCreateWithoutBookingInput, JobCompletionUncheckedCreateWithoutBookingInput>
    connectOrCreate?: JobCompletionCreateOrConnectWithoutBookingInput
    connect?: JobCompletionWhereUniqueInput
  }

  export type JobPhotoUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<JobPhotoCreateWithoutBookingInput, JobPhotoUncheckedCreateWithoutBookingInput> | JobPhotoCreateWithoutBookingInput[] | JobPhotoUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: JobPhotoCreateOrConnectWithoutBookingInput | JobPhotoCreateOrConnectWithoutBookingInput[]
    createMany?: JobPhotoCreateManyBookingInputEnvelope
    connect?: JobPhotoWhereUniqueInput | JobPhotoWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<InvoiceCreateWithoutBookingInput, InvoiceUncheckedCreateWithoutBookingInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutBookingInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<ReportCreateWithoutBookingInput, ReportUncheckedCreateWithoutBookingInput> | ReportCreateWithoutBookingInput[] | ReportUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutBookingInput | ReportCreateOrConnectWithoutBookingInput[]
    createMany?: ReportCreateManyBookingInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type ContractorUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ContractorCreateWithoutBookingsInput, ContractorUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutBookingsInput
    upsert?: ContractorUpsertWithoutBookingsInput
    connect?: ContractorWhereUniqueInput
    update?: XOR<XOR<ContractorUpdateToOneWithWhereWithoutBookingsInput, ContractorUpdateWithoutBookingsInput>, ContractorUncheckedUpdateWithoutBookingsInput>
  }

  export type ClientUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ClientCreateWithoutBookingsInput, ClientUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutBookingsInput
    upsert?: ClientUpsertWithoutBookingsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutBookingsInput, ClientUpdateWithoutBookingsInput>, ClientUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    upsert?: ServiceUpsertWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBookingsInput, ServiceUpdateWithoutBookingsInput>, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type JobCompletionUpdateOneWithoutBookingNestedInput = {
    create?: XOR<JobCompletionCreateWithoutBookingInput, JobCompletionUncheckedCreateWithoutBookingInput>
    connectOrCreate?: JobCompletionCreateOrConnectWithoutBookingInput
    upsert?: JobCompletionUpsertWithoutBookingInput
    disconnect?: JobCompletionWhereInput | boolean
    delete?: JobCompletionWhereInput | boolean
    connect?: JobCompletionWhereUniqueInput
    update?: XOR<XOR<JobCompletionUpdateToOneWithWhereWithoutBookingInput, JobCompletionUpdateWithoutBookingInput>, JobCompletionUncheckedUpdateWithoutBookingInput>
  }

  export type JobPhotoUpdateManyWithoutBookingNestedInput = {
    create?: XOR<JobPhotoCreateWithoutBookingInput, JobPhotoUncheckedCreateWithoutBookingInput> | JobPhotoCreateWithoutBookingInput[] | JobPhotoUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: JobPhotoCreateOrConnectWithoutBookingInput | JobPhotoCreateOrConnectWithoutBookingInput[]
    upsert?: JobPhotoUpsertWithWhereUniqueWithoutBookingInput | JobPhotoUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: JobPhotoCreateManyBookingInputEnvelope
    set?: JobPhotoWhereUniqueInput | JobPhotoWhereUniqueInput[]
    disconnect?: JobPhotoWhereUniqueInput | JobPhotoWhereUniqueInput[]
    delete?: JobPhotoWhereUniqueInput | JobPhotoWhereUniqueInput[]
    connect?: JobPhotoWhereUniqueInput | JobPhotoWhereUniqueInput[]
    update?: JobPhotoUpdateWithWhereUniqueWithoutBookingInput | JobPhotoUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: JobPhotoUpdateManyWithWhereWithoutBookingInput | JobPhotoUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: JobPhotoScalarWhereInput | JobPhotoScalarWhereInput[]
  }

  export type InvoiceUpdateOneWithoutBookingNestedInput = {
    create?: XOR<InvoiceCreateWithoutBookingInput, InvoiceUncheckedCreateWithoutBookingInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutBookingInput
    upsert?: InvoiceUpsertWithoutBookingInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutBookingInput, InvoiceUpdateWithoutBookingInput>, InvoiceUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ReportCreateWithoutBookingInput, ReportUncheckedCreateWithoutBookingInput> | ReportCreateWithoutBookingInput[] | ReportUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutBookingInput | ReportCreateOrConnectWithoutBookingInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutBookingInput | ReportUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ReportCreateManyBookingInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutBookingInput | ReportUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutBookingInput | ReportUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type JobCompletionUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<JobCompletionCreateWithoutBookingInput, JobCompletionUncheckedCreateWithoutBookingInput>
    connectOrCreate?: JobCompletionCreateOrConnectWithoutBookingInput
    upsert?: JobCompletionUpsertWithoutBookingInput
    disconnect?: JobCompletionWhereInput | boolean
    delete?: JobCompletionWhereInput | boolean
    connect?: JobCompletionWhereUniqueInput
    update?: XOR<XOR<JobCompletionUpdateToOneWithWhereWithoutBookingInput, JobCompletionUpdateWithoutBookingInput>, JobCompletionUncheckedUpdateWithoutBookingInput>
  }

  export type JobPhotoUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<JobPhotoCreateWithoutBookingInput, JobPhotoUncheckedCreateWithoutBookingInput> | JobPhotoCreateWithoutBookingInput[] | JobPhotoUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: JobPhotoCreateOrConnectWithoutBookingInput | JobPhotoCreateOrConnectWithoutBookingInput[]
    upsert?: JobPhotoUpsertWithWhereUniqueWithoutBookingInput | JobPhotoUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: JobPhotoCreateManyBookingInputEnvelope
    set?: JobPhotoWhereUniqueInput | JobPhotoWhereUniqueInput[]
    disconnect?: JobPhotoWhereUniqueInput | JobPhotoWhereUniqueInput[]
    delete?: JobPhotoWhereUniqueInput | JobPhotoWhereUniqueInput[]
    connect?: JobPhotoWhereUniqueInput | JobPhotoWhereUniqueInput[]
    update?: JobPhotoUpdateWithWhereUniqueWithoutBookingInput | JobPhotoUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: JobPhotoUpdateManyWithWhereWithoutBookingInput | JobPhotoUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: JobPhotoScalarWhereInput | JobPhotoScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<InvoiceCreateWithoutBookingInput, InvoiceUncheckedCreateWithoutBookingInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutBookingInput
    upsert?: InvoiceUpsertWithoutBookingInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutBookingInput, InvoiceUpdateWithoutBookingInput>, InvoiceUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ReportCreateWithoutBookingInput, ReportUncheckedCreateWithoutBookingInput> | ReportCreateWithoutBookingInput[] | ReportUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutBookingInput | ReportCreateOrConnectWithoutBookingInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutBookingInput | ReportUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ReportCreateManyBookingInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutBookingInput | ReportUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutBookingInput | ReportUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutCompletionInput = {
    create?: XOR<BookingCreateWithoutCompletionInput, BookingUncheckedCreateWithoutCompletionInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCompletionInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutCompletionNestedInput = {
    create?: XOR<BookingCreateWithoutCompletionInput, BookingUncheckedCreateWithoutCompletionInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCompletionInput
    upsert?: BookingUpsertWithoutCompletionInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutCompletionInput, BookingUpdateWithoutCompletionInput>, BookingUncheckedUpdateWithoutCompletionInput>
  }

  export type BookingCreateNestedOneWithoutPhotosInput = {
    create?: XOR<BookingCreateWithoutPhotosInput, BookingUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPhotosInput
    connect?: BookingWhereUniqueInput
  }

  export type EnumPhotoTypeFieldUpdateOperationsInput = {
    set?: $Enums.PhotoType
  }

  export type BookingUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<BookingCreateWithoutPhotosInput, BookingUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPhotosInput
    upsert?: BookingUpsertWithoutPhotosInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPhotosInput, BookingUpdateWithoutPhotosInput>, BookingUncheckedUpdateWithoutPhotosInput>
  }

  export type ContractorCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ContractorCreateWithoutMessagesInput, ContractorUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutMessagesInput
    connect?: ContractorWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ClientCreateWithoutMessagesInput, ClientUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutMessagesInput
    connect?: ClientWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutMessageInput = {
    create?: XOR<ChatMessageCreateWithoutMessageInput, ChatMessageUncheckedCreateWithoutMessageInput> | ChatMessageCreateWithoutMessageInput[] | ChatMessageUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutMessageInput | ChatMessageCreateOrConnectWithoutMessageInput[]
    createMany?: ChatMessageCreateManyMessageInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<ChatMessageCreateWithoutMessageInput, ChatMessageUncheckedCreateWithoutMessageInput> | ChatMessageCreateWithoutMessageInput[] | ChatMessageUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutMessageInput | ChatMessageCreateOrConnectWithoutMessageInput[]
    createMany?: ChatMessageCreateManyMessageInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type EnumMessageStatusFieldUpdateOperationsInput = {
    set?: $Enums.MessageStatus
  }

  export type ContractorUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ContractorCreateWithoutMessagesInput, ContractorUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutMessagesInput
    upsert?: ContractorUpsertWithoutMessagesInput
    connect?: ContractorWhereUniqueInput
    update?: XOR<XOR<ContractorUpdateToOneWithWhereWithoutMessagesInput, ContractorUpdateWithoutMessagesInput>, ContractorUncheckedUpdateWithoutMessagesInput>
  }

  export type ClientUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ClientCreateWithoutMessagesInput, ClientUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutMessagesInput
    upsert?: ClientUpsertWithoutMessagesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutMessagesInput, ClientUpdateWithoutMessagesInput>, ClientUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatMessageUpdateManyWithoutMessageNestedInput = {
    create?: XOR<ChatMessageCreateWithoutMessageInput, ChatMessageUncheckedCreateWithoutMessageInput> | ChatMessageCreateWithoutMessageInput[] | ChatMessageUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutMessageInput | ChatMessageCreateOrConnectWithoutMessageInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutMessageInput | ChatMessageUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: ChatMessageCreateManyMessageInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutMessageInput | ChatMessageUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutMessageInput | ChatMessageUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<ChatMessageCreateWithoutMessageInput, ChatMessageUncheckedCreateWithoutMessageInput> | ChatMessageCreateWithoutMessageInput[] | ChatMessageUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutMessageInput | ChatMessageCreateOrConnectWithoutMessageInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutMessageInput | ChatMessageUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: ChatMessageCreateManyMessageInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutMessageInput | ChatMessageUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutMessageInput | ChatMessageUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutChatMessagesInput = {
    create?: XOR<MessageCreateWithoutChatMessagesInput, MessageUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutChatMessagesInput
    connect?: MessageWhereUniqueInput
  }

  export type EnumSenderTypeFieldUpdateOperationsInput = {
    set?: $Enums.SenderType
  }

  export type MessageUpdateOneRequiredWithoutChatMessagesNestedInput = {
    create?: XOR<MessageCreateWithoutChatMessagesInput, MessageUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutChatMessagesInput
    upsert?: MessageUpsertWithoutChatMessagesInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutChatMessagesInput, MessageUpdateWithoutChatMessagesInput>, MessageUncheckedUpdateWithoutChatMessagesInput>
  }

  export type ContractorCreateNestedOneWithoutFlaggedMessagesInput = {
    create?: XOR<ContractorCreateWithoutFlaggedMessagesInput, ContractorUncheckedCreateWithoutFlaggedMessagesInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutFlaggedMessagesInput
    connect?: ContractorWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutFlaggedMessagesInput = {
    create?: XOR<ClientCreateWithoutFlaggedMessagesInput, ClientUncheckedCreateWithoutFlaggedMessagesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutFlaggedMessagesInput
    connect?: ClientWhereUniqueInput
  }

  export type EnumFlaggedByTypeFieldUpdateOperationsInput = {
    set?: $Enums.FlaggedByType
  }

  export type EnumFlagStatusFieldUpdateOperationsInput = {
    set?: $Enums.FlagStatus
  }

  export type ContractorUpdateOneWithoutFlaggedMessagesNestedInput = {
    create?: XOR<ContractorCreateWithoutFlaggedMessagesInput, ContractorUncheckedCreateWithoutFlaggedMessagesInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutFlaggedMessagesInput
    upsert?: ContractorUpsertWithoutFlaggedMessagesInput
    disconnect?: ContractorWhereInput | boolean
    delete?: ContractorWhereInput | boolean
    connect?: ContractorWhereUniqueInput
    update?: XOR<XOR<ContractorUpdateToOneWithWhereWithoutFlaggedMessagesInput, ContractorUpdateWithoutFlaggedMessagesInput>, ContractorUncheckedUpdateWithoutFlaggedMessagesInput>
  }

  export type ClientUpdateOneWithoutFlaggedMessagesNestedInput = {
    create?: XOR<ClientCreateWithoutFlaggedMessagesInput, ClientUncheckedCreateWithoutFlaggedMessagesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutFlaggedMessagesInput
    upsert?: ClientUpsertWithoutFlaggedMessagesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutFlaggedMessagesInput, ClientUpdateWithoutFlaggedMessagesInput>, ClientUncheckedUpdateWithoutFlaggedMessagesInput>
  }

  export type BookingCreateNestedOneWithoutReportsInput = {
    create?: XOR<BookingCreateWithoutReportsInput, BookingUncheckedCreateWithoutReportsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutReportsInput
    connect?: BookingWhereUniqueInput
  }

  export type EnumReportTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReportType
  }

  export type EnumReporterTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReporterType
  }

  export type NullableEnumReporterTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReporterType | null
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type EnumReportPriorityFieldUpdateOperationsInput = {
    set?: $Enums.ReportPriority
  }

  export type BookingUpdateOneWithoutReportsNestedInput = {
    create?: XOR<BookingCreateWithoutReportsInput, BookingUncheckedCreateWithoutReportsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutReportsInput
    upsert?: BookingUpsertWithoutReportsInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutReportsInput, BookingUpdateWithoutReportsInput>, BookingUncheckedUpdateWithoutReportsInput>
  }

  export type ContractorCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ContractorCreateWithoutReviewsInput, ContractorUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutReviewsInput
    connect?: ContractorWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReviewsInput
    connect?: ClientWhereUniqueInput
  }

  export type ContractorUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ContractorCreateWithoutReviewsInput, ContractorUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutReviewsInput
    upsert?: ContractorUpsertWithoutReviewsInput
    connect?: ContractorWhereUniqueInput
    update?: XOR<XOR<ContractorUpdateToOneWithWhereWithoutReviewsInput, ContractorUpdateWithoutReviewsInput>, ContractorUncheckedUpdateWithoutReviewsInput>
  }

  export type ClientUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReviewsInput
    upsert?: ClientUpsertWithoutReviewsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutReviewsInput, ClientUpdateWithoutReviewsInput>, ClientUncheckedUpdateWithoutReviewsInput>
  }

  export type BookingCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<BookingCreateWithoutInvoiceInput, BookingUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: BookingCreateOrConnectWithoutInvoiceInput
    connect?: BookingWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type BookingUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<BookingCreateWithoutInvoiceInput, BookingUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: BookingCreateOrConnectWithoutInvoiceInput
    upsert?: BookingUpsertWithoutInvoiceInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutInvoiceInput, BookingUpdateWithoutInvoiceInput>, BookingUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type BookingUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    upsert?: BookingUpsertWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentsInput, BookingUpdateWithoutPaymentsInput>, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type ContractorCreateNestedOneWithoutAvailabilityInput = {
    create?: XOR<ContractorCreateWithoutAvailabilityInput, ContractorUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutAvailabilityInput
    connect?: ContractorWhereUniqueInput
  }

  export type ContractorUpdateOneRequiredWithoutAvailabilityNestedInput = {
    create?: XOR<ContractorCreateWithoutAvailabilityInput, ContractorUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutAvailabilityInput
    upsert?: ContractorUpsertWithoutAvailabilityInput
    connect?: ContractorWhereUniqueInput
    update?: XOR<XOR<ContractorUpdateToOneWithWhereWithoutAvailabilityInput, ContractorUpdateWithoutAvailabilityInput>, ContractorUncheckedUpdateWithoutAvailabilityInput>
  }

  export type ContractorCreateNestedOneWithoutTimeSlotsInput = {
    create?: XOR<ContractorCreateWithoutTimeSlotsInput, ContractorUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutTimeSlotsInput
    connect?: ContractorWhereUniqueInput
  }

  export type EnumSlotTypeFieldUpdateOperationsInput = {
    set?: $Enums.SlotType
  }

  export type ContractorUpdateOneRequiredWithoutTimeSlotsNestedInput = {
    create?: XOR<ContractorCreateWithoutTimeSlotsInput, ContractorUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutTimeSlotsInput
    upsert?: ContractorUpsertWithoutTimeSlotsInput
    connect?: ContractorWhereUniqueInput
    update?: XOR<XOR<ContractorUpdateToOneWithWhereWithoutTimeSlotsInput, ContractorUpdateWithoutTimeSlotsInput>, ContractorUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type ContractorCreateNestedOneWithoutServiceAreasInput = {
    create?: XOR<ContractorCreateWithoutServiceAreasInput, ContractorUncheckedCreateWithoutServiceAreasInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutServiceAreasInput
    connect?: ContractorWhereUniqueInput
  }

  export type ContractorUpdateOneRequiredWithoutServiceAreasNestedInput = {
    create?: XOR<ContractorCreateWithoutServiceAreasInput, ContractorUncheckedCreateWithoutServiceAreasInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutServiceAreasInput
    upsert?: ContractorUpsertWithoutServiceAreasInput
    connect?: ContractorWhereUniqueInput
    update?: XOR<XOR<ContractorUpdateToOneWithWhereWithoutServiceAreasInput, ContractorUpdateWithoutServiceAreasInput>, ContractorUncheckedUpdateWithoutServiceAreasInput>
  }

  export type ClientCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<ClientCreateWithoutFavoritesInput, ClientUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutFavoritesInput
    connect?: ClientWhereUniqueInput
  }

  export type ContractorCreateNestedOneWithoutFavoritedByInput = {
    create?: XOR<ContractorCreateWithoutFavoritedByInput, ContractorUncheckedCreateWithoutFavoritedByInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutFavoritedByInput
    connect?: ContractorWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<ClientCreateWithoutFavoritesInput, ClientUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutFavoritesInput
    upsert?: ClientUpsertWithoutFavoritesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutFavoritesInput, ClientUpdateWithoutFavoritesInput>, ClientUncheckedUpdateWithoutFavoritesInput>
  }

  export type ContractorUpdateOneRequiredWithoutFavoritedByNestedInput = {
    create?: XOR<ContractorCreateWithoutFavoritedByInput, ContractorUncheckedCreateWithoutFavoritedByInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutFavoritedByInput
    upsert?: ContractorUpsertWithoutFavoritedByInput
    connect?: ContractorWhereUniqueInput
    update?: XOR<XOR<ContractorUpdateToOneWithWhereWithoutFavoritedByInput, ContractorUpdateWithoutFavoritedByInput>, ContractorUncheckedUpdateWithoutFavoritedByInput>
  }

  export type ContractorCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<ContractorCreateWithoutMaterialsInput, ContractorUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutMaterialsInput
    connect?: ContractorWhereUniqueInput
  }

  export type ContractorUpdateOneRequiredWithoutMaterialsNestedInput = {
    create?: XOR<ContractorCreateWithoutMaterialsInput, ContractorUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: ContractorCreateOrConnectWithoutMaterialsInput
    upsert?: ContractorUpsertWithoutMaterialsInput
    connect?: ContractorWhereUniqueInput
    update?: XOR<XOR<ContractorUpdateToOneWithWhereWithoutMaterialsInput, ContractorUpdateWithoutMaterialsInput>, ContractorUncheckedUpdateWithoutMaterialsInput>
  }

  export type EnumActivitySeverityFieldUpdateOperationsInput = {
    set?: $Enums.ActivitySeverity
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type NestedEnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumPhotoTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PhotoType | EnumPhotoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PhotoType[] | ListEnumPhotoTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhotoType[] | ListEnumPhotoTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPhotoTypeFilter<$PrismaModel> | $Enums.PhotoType
  }

  export type NestedEnumPhotoTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PhotoType | EnumPhotoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PhotoType[] | ListEnumPhotoTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhotoType[] | ListEnumPhotoTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPhotoTypeWithAggregatesFilter<$PrismaModel> | $Enums.PhotoType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPhotoTypeFilter<$PrismaModel>
    _max?: NestedEnumPhotoTypeFilter<$PrismaModel>
  }

  export type NestedEnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type NestedEnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type NestedEnumFlaggedByTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FlaggedByType | EnumFlaggedByTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FlaggedByType[] | ListEnumFlaggedByTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlaggedByType[] | ListEnumFlaggedByTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFlaggedByTypeFilter<$PrismaModel> | $Enums.FlaggedByType
  }

  export type NestedEnumFlagStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagStatus | EnumFlagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagStatusFilter<$PrismaModel> | $Enums.FlagStatus
  }

  export type NestedEnumFlaggedByTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlaggedByType | EnumFlaggedByTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FlaggedByType[] | ListEnumFlaggedByTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlaggedByType[] | ListEnumFlaggedByTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFlaggedByTypeWithAggregatesFilter<$PrismaModel> | $Enums.FlaggedByType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlaggedByTypeFilter<$PrismaModel>
    _max?: NestedEnumFlaggedByTypeFilter<$PrismaModel>
  }

  export type NestedEnumFlagStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagStatus | EnumFlagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagStatusWithAggregatesFilter<$PrismaModel> | $Enums.FlagStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlagStatusFilter<$PrismaModel>
    _max?: NestedEnumFlagStatusFilter<$PrismaModel>
  }

  export type NestedEnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type NestedEnumReporterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReporterType | EnumReporterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReporterTypeFilter<$PrismaModel> | $Enums.ReporterType
  }

  export type NestedEnumReporterTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReporterType | EnumReporterTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReporterTypeNullableFilter<$PrismaModel> | $Enums.ReporterType | null
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportPriority | EnumReportPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ReportPriority[] | ListEnumReportPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportPriority[] | ListEnumReportPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumReportPriorityFilter<$PrismaModel> | $Enums.ReportPriority
  }

  export type NestedEnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type NestedEnumReporterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReporterType | EnumReporterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReporterTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReporterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReporterTypeFilter<$PrismaModel>
    _max?: NestedEnumReporterTypeFilter<$PrismaModel>
  }

  export type NestedEnumReporterTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReporterType | EnumReporterTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReporterType[] | ListEnumReporterTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReporterTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReporterType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReporterTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumReporterTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumReportPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportPriority | EnumReportPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ReportPriority[] | ListEnumReportPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportPriority[] | ListEnumReportPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumReportPriorityWithAggregatesFilter<$PrismaModel> | $Enums.ReportPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportPriorityFilter<$PrismaModel>
    _max?: NestedEnumReportPriorityFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumSlotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeFilter<$PrismaModel> | $Enums.SlotType
  }

  export type NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel> | $Enums.SlotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSlotTypeFilter<$PrismaModel>
    _max?: NestedEnumSlotTypeFilter<$PrismaModel>
  }

  export type NestedEnumActivitySeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivitySeverity | EnumActivitySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ActivitySeverity[] | ListEnumActivitySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivitySeverity[] | ListEnumActivitySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumActivitySeverityFilter<$PrismaModel> | $Enums.ActivitySeverity
  }

  export type NestedEnumActivitySeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivitySeverity | EnumActivitySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ActivitySeverity[] | ListEnumActivitySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivitySeverity[] | ListEnumActivitySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumActivitySeverityWithAggregatesFilter<$PrismaModel> | $Enums.ActivitySeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivitySeverityFilter<$PrismaModel>
    _max?: NestedEnumActivitySeverityFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ClientCreateWithoutUserInput = {
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    messages?: MessageCreateNestedManyWithoutClientInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutClientInput
    favorites?: FavoriteContractorCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUserInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    messages?: MessageUncheckedCreateNestedManyWithoutClientInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutClientInput
    favorites?: FavoriteContractorUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUserInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type ContractorCreateWithoutUserInput = {
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ContractorServiceCreateNestedManyWithoutContractorInput
    bookings?: BookingCreateNestedManyWithoutContractorInput
    reviews?: ReviewCreateNestedManyWithoutContractorInput
    messages?: MessageCreateNestedManyWithoutContractorInput
    availability?: AvailabilityCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorCreateNestedManyWithoutContractorInput
    materials?: MaterialCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionCreateNestedOneWithoutContractorInput
  }

  export type ContractorUncheckedCreateWithoutUserInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ContractorServiceUncheckedCreateNestedManyWithoutContractorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutContractorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractorInput
    messages?: MessageUncheckedCreateNestedManyWithoutContractorInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaUncheckedCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorUncheckedCreateNestedManyWithoutContractorInput
    materials?: MaterialUncheckedCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageUncheckedCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutContractorInput
  }

  export type ContractorCreateOrConnectWithoutUserInput = {
    where: ContractorWhereUniqueInput
    create: XOR<ContractorCreateWithoutUserInput, ContractorUncheckedCreateWithoutUserInput>
  }

  export type ClientUpsertWithoutUserInput = {
    update: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUserInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    messages?: MessageUpdateManyWithoutClientNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutClientNestedInput
    favorites?: FavoriteContractorUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClientNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutClientNestedInput
    favorites?: FavoriteContractorUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ContractorUpsertWithoutUserInput = {
    update: XOR<ContractorUpdateWithoutUserInput, ContractorUncheckedUpdateWithoutUserInput>
    create: XOR<ContractorCreateWithoutUserInput, ContractorUncheckedCreateWithoutUserInput>
    where?: ContractorWhereInput
  }

  export type ContractorUpdateToOneWithWhereWithoutUserInput = {
    where?: ContractorWhereInput
    data: XOR<ContractorUpdateWithoutUserInput, ContractorUncheckedUpdateWithoutUserInput>
  }

  export type ContractorUpdateWithoutUserInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ContractorServiceUpdateManyWithoutContractorNestedInput
    bookings?: BookingUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUpdateManyWithoutContractorNestedInput
    messages?: MessageUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUpdateManyWithoutContractorNestedInput
    materials?: MaterialUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUpdateOneWithoutContractorNestedInput
  }

  export type ContractorUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ContractorServiceUncheckedUpdateManyWithoutContractorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUncheckedUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUncheckedUpdateManyWithoutContractorNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUncheckedUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutContractorNestedInput
  }

  export type UserCreateWithoutClientInput = {
    username: string
    password: string
    type: $Enums.UserType
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    facebookId?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor?: ContractorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientInput = {
    id?: number
    username: string
    password: string
    type: $Enums.UserType
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    facebookId?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor?: ContractorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type BookingCreateWithoutClientInput = {
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    completion?: JobCompletionCreateNestedOneWithoutBookingInput
    photos?: JobPhotoCreateNestedManyWithoutBookingInput
    invoice?: InvoiceCreateNestedOneWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    reports?: ReportCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutClientInput = {
    id?: number
    contractorId: number
    serviceId: number
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completion?: JobCompletionUncheckedCreateNestedOneWithoutBookingInput
    photos?: JobPhotoUncheckedCreateNestedManyWithoutBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    reports?: ReportUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutClientInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutClientInput, BookingUncheckedCreateWithoutClientInput>
  }

  export type BookingCreateManyClientInputEnvelope = {
    data: BookingCreateManyClientInput | BookingCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutClientInput = {
    rating: number
    reviewText?: string | null
    createdAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutClientInput = {
    id?: number
    contractorId: number
    rating: number
    reviewText?: string | null
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutClientInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput>
  }

  export type ReviewCreateManyClientInputEnvelope = {
    data: ReviewCreateManyClientInput | ReviewCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutClientInput = {
    subject?: string | null
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutMessagesInput
    chatMessages?: ChatMessageCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutClientInput = {
    id?: number
    contractorId: number
    subject?: string | null
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutClientInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutClientInput, MessageUncheckedCreateWithoutClientInput>
  }

  export type MessageCreateManyClientInputEnvelope = {
    data: MessageCreateManyClientInput | MessageCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type FlaggedMessageCreateWithoutClientInput = {
    messageId?: number | null
    messageText: string
    flaggedBy: $Enums.FlaggedByType
    flaggedById: number
    reason: string
    details?: string | null
    status?: $Enums.FlagStatus
    reviewedBy?: number | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    contractor?: ContractorCreateNestedOneWithoutFlaggedMessagesInput
  }

  export type FlaggedMessageUncheckedCreateWithoutClientInput = {
    id?: number
    messageId?: number | null
    messageText: string
    flaggedBy: $Enums.FlaggedByType
    flaggedById: number
    contractorId?: number | null
    reason: string
    details?: string | null
    status?: $Enums.FlagStatus
    reviewedBy?: number | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type FlaggedMessageCreateOrConnectWithoutClientInput = {
    where: FlaggedMessageWhereUniqueInput
    create: XOR<FlaggedMessageCreateWithoutClientInput, FlaggedMessageUncheckedCreateWithoutClientInput>
  }

  export type FlaggedMessageCreateManyClientInputEnvelope = {
    data: FlaggedMessageCreateManyClientInput | FlaggedMessageCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteContractorCreateWithoutClientInput = {
    createdAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutFavoritedByInput
  }

  export type FavoriteContractorUncheckedCreateWithoutClientInput = {
    id?: number
    contractorId: number
    createdAt?: Date | string
  }

  export type FavoriteContractorCreateOrConnectWithoutClientInput = {
    where: FavoriteContractorWhereUniqueInput
    create: XOR<FavoriteContractorCreateWithoutClientInput, FavoriteContractorUncheckedCreateWithoutClientInput>
  }

  export type FavoriteContractorCreateManyClientInputEnvelope = {
    data: FavoriteContractorCreateManyClientInput | FavoriteContractorCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClientInput = {
    update: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
  }

  export type UserUpdateWithoutClientInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutClientInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutClientInput, BookingUncheckedUpdateWithoutClientInput>
    create: XOR<BookingCreateWithoutClientInput, BookingUncheckedCreateWithoutClientInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutClientInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutClientInput, BookingUncheckedUpdateWithoutClientInput>
  }

  export type BookingUpdateManyWithWhereWithoutClientInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutClientInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: IntFilter<"Booking"> | number
    contractorId?: IntFilter<"Booking"> | number
    clientId?: IntFilter<"Booking"> | number
    serviceId?: IntFilter<"Booking"> | number
    serviceAddress?: StringFilter<"Booking"> | string
    scheduledDate?: DateTimeFilter<"Booking"> | Date | string
    scheduledTime?: StringFilter<"Booking"> | string
    estimatedDuration?: IntNullableFilter<"Booking"> | number | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    price?: FloatNullableFilter<"Booking"> | number | null
    paymentReceived?: BoolFilter<"Booking"> | boolean
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutClientInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutClientInput, ReviewUncheckedUpdateWithoutClientInput>
    create: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutClientInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutClientInput, ReviewUncheckedUpdateWithoutClientInput>
  }

  export type ReviewUpdateManyWithWhereWithoutClientInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutClientInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: IntFilter<"Review"> | number
    contractorId?: IntFilter<"Review"> | number
    clientId?: IntFilter<"Review"> | number
    rating?: IntFilter<"Review"> | number
    reviewText?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutClientInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutClientInput, MessageUncheckedUpdateWithoutClientInput>
    create: XOR<MessageCreateWithoutClientInput, MessageUncheckedCreateWithoutClientInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutClientInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutClientInput, MessageUncheckedUpdateWithoutClientInput>
  }

  export type MessageUpdateManyWithWhereWithoutClientInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutClientInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: IntFilter<"Message"> | number
    contractorId?: IntFilter<"Message"> | number
    clientId?: IntFilter<"Message"> | number
    subject?: StringNullableFilter<"Message"> | string | null
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type FlaggedMessageUpsertWithWhereUniqueWithoutClientInput = {
    where: FlaggedMessageWhereUniqueInput
    update: XOR<FlaggedMessageUpdateWithoutClientInput, FlaggedMessageUncheckedUpdateWithoutClientInput>
    create: XOR<FlaggedMessageCreateWithoutClientInput, FlaggedMessageUncheckedCreateWithoutClientInput>
  }

  export type FlaggedMessageUpdateWithWhereUniqueWithoutClientInput = {
    where: FlaggedMessageWhereUniqueInput
    data: XOR<FlaggedMessageUpdateWithoutClientInput, FlaggedMessageUncheckedUpdateWithoutClientInput>
  }

  export type FlaggedMessageUpdateManyWithWhereWithoutClientInput = {
    where: FlaggedMessageScalarWhereInput
    data: XOR<FlaggedMessageUpdateManyMutationInput, FlaggedMessageUncheckedUpdateManyWithoutClientInput>
  }

  export type FlaggedMessageScalarWhereInput = {
    AND?: FlaggedMessageScalarWhereInput | FlaggedMessageScalarWhereInput[]
    OR?: FlaggedMessageScalarWhereInput[]
    NOT?: FlaggedMessageScalarWhereInput | FlaggedMessageScalarWhereInput[]
    id?: IntFilter<"FlaggedMessage"> | number
    messageId?: IntNullableFilter<"FlaggedMessage"> | number | null
    messageText?: StringFilter<"FlaggedMessage"> | string
    flaggedBy?: EnumFlaggedByTypeFilter<"FlaggedMessage"> | $Enums.FlaggedByType
    flaggedById?: IntFilter<"FlaggedMessage"> | number
    contractorId?: IntNullableFilter<"FlaggedMessage"> | number | null
    clientId?: IntNullableFilter<"FlaggedMessage"> | number | null
    reason?: StringFilter<"FlaggedMessage"> | string
    details?: StringNullableFilter<"FlaggedMessage"> | string | null
    status?: EnumFlagStatusFilter<"FlaggedMessage"> | $Enums.FlagStatus
    reviewedBy?: IntNullableFilter<"FlaggedMessage"> | number | null
    reviewedAt?: DateTimeNullableFilter<"FlaggedMessage"> | Date | string | null
    createdAt?: DateTimeFilter<"FlaggedMessage"> | Date | string
  }

  export type FavoriteContractorUpsertWithWhereUniqueWithoutClientInput = {
    where: FavoriteContractorWhereUniqueInput
    update: XOR<FavoriteContractorUpdateWithoutClientInput, FavoriteContractorUncheckedUpdateWithoutClientInput>
    create: XOR<FavoriteContractorCreateWithoutClientInput, FavoriteContractorUncheckedCreateWithoutClientInput>
  }

  export type FavoriteContractorUpdateWithWhereUniqueWithoutClientInput = {
    where: FavoriteContractorWhereUniqueInput
    data: XOR<FavoriteContractorUpdateWithoutClientInput, FavoriteContractorUncheckedUpdateWithoutClientInput>
  }

  export type FavoriteContractorUpdateManyWithWhereWithoutClientInput = {
    where: FavoriteContractorScalarWhereInput
    data: XOR<FavoriteContractorUpdateManyMutationInput, FavoriteContractorUncheckedUpdateManyWithoutClientInput>
  }

  export type FavoriteContractorScalarWhereInput = {
    AND?: FavoriteContractorScalarWhereInput | FavoriteContractorScalarWhereInput[]
    OR?: FavoriteContractorScalarWhereInput[]
    NOT?: FavoriteContractorScalarWhereInput | FavoriteContractorScalarWhereInput[]
    id?: IntFilter<"FavoriteContractor"> | number
    clientId?: IntFilter<"FavoriteContractor"> | number
    contractorId?: IntFilter<"FavoriteContractor"> | number
    createdAt?: DateTimeFilter<"FavoriteContractor"> | Date | string
  }

  export type UserCreateWithoutContractorInput = {
    username: string
    password: string
    type: $Enums.UserType
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    facebookId?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContractorInput = {
    id?: number
    username: string
    password: string
    type: $Enums.UserType
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    facebookId?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContractorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContractorInput, UserUncheckedCreateWithoutContractorInput>
  }

  export type ContractorServiceCreateWithoutContractorInput = {
    basePrice?: number | null
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutContractorsInput
  }

  export type ContractorServiceUncheckedCreateWithoutContractorInput = {
    id?: number
    serviceId: number
    basePrice?: number | null
    createdAt?: Date | string
  }

  export type ContractorServiceCreateOrConnectWithoutContractorInput = {
    where: ContractorServiceWhereUniqueInput
    create: XOR<ContractorServiceCreateWithoutContractorInput, ContractorServiceUncheckedCreateWithoutContractorInput>
  }

  export type ContractorServiceCreateManyContractorInputEnvelope = {
    data: ContractorServiceCreateManyContractorInput | ContractorServiceCreateManyContractorInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutContractorInput = {
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    completion?: JobCompletionCreateNestedOneWithoutBookingInput
    photos?: JobPhotoCreateNestedManyWithoutBookingInput
    invoice?: InvoiceCreateNestedOneWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    reports?: ReportCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutContractorInput = {
    id?: number
    clientId: number
    serviceId: number
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completion?: JobCompletionUncheckedCreateNestedOneWithoutBookingInput
    photos?: JobPhotoUncheckedCreateNestedManyWithoutBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    reports?: ReportUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutContractorInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutContractorInput, BookingUncheckedCreateWithoutContractorInput>
  }

  export type BookingCreateManyContractorInputEnvelope = {
    data: BookingCreateManyContractorInput | BookingCreateManyContractorInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutContractorInput = {
    rating: number
    reviewText?: string | null
    createdAt?: Date | string
    client: ClientCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutContractorInput = {
    id?: number
    clientId: number
    rating: number
    reviewText?: string | null
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutContractorInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutContractorInput, ReviewUncheckedCreateWithoutContractorInput>
  }

  export type ReviewCreateManyContractorInputEnvelope = {
    data: ReviewCreateManyContractorInput | ReviewCreateManyContractorInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutContractorInput = {
    subject?: string | null
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutMessagesInput
    chatMessages?: ChatMessageCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutContractorInput = {
    id?: number
    clientId: number
    subject?: string | null
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutContractorInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutContractorInput, MessageUncheckedCreateWithoutContractorInput>
  }

  export type MessageCreateManyContractorInputEnvelope = {
    data: MessageCreateManyContractorInput | MessageCreateManyContractorInput[]
    skipDuplicates?: boolean
  }

  export type AvailabilityCreateWithoutContractorInput = {
    dayOfWeek?: number | null
    specificDate?: Date | string | null
    startTime: string
    endTime: string
    maxBookings?: number
    isAvailable?: boolean
    isRecurring?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityUncheckedCreateWithoutContractorInput = {
    id?: number
    dayOfWeek?: number | null
    specificDate?: Date | string | null
    startTime: string
    endTime: string
    maxBookings?: number
    isAvailable?: boolean
    isRecurring?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityCreateOrConnectWithoutContractorInput = {
    where: AvailabilityWhereUniqueInput
    create: XOR<AvailabilityCreateWithoutContractorInput, AvailabilityUncheckedCreateWithoutContractorInput>
  }

  export type AvailabilityCreateManyContractorInputEnvelope = {
    data: AvailabilityCreateManyContractorInput | AvailabilityCreateManyContractorInput[]
    skipDuplicates?: boolean
  }

  export type TimeSlotCreateWithoutContractorInput = {
    date: Date | string
    startTime: string
    endTime: string
    slotType: $Enums.SlotType
    bookingId?: number | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeSlotUncheckedCreateWithoutContractorInput = {
    id?: number
    date: Date | string
    startTime: string
    endTime: string
    slotType: $Enums.SlotType
    bookingId?: number | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeSlotCreateOrConnectWithoutContractorInput = {
    where: TimeSlotWhereUniqueInput
    create: XOR<TimeSlotCreateWithoutContractorInput, TimeSlotUncheckedCreateWithoutContractorInput>
  }

  export type TimeSlotCreateManyContractorInputEnvelope = {
    data: TimeSlotCreateManyContractorInput | TimeSlotCreateManyContractorInput[]
    skipDuplicates?: boolean
  }

  export type ContractorServiceAreaCreateWithoutContractorInput = {
    dayOfWeek?: number | null
    area: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractorServiceAreaUncheckedCreateWithoutContractorInput = {
    id?: number
    dayOfWeek?: number | null
    area: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractorServiceAreaCreateOrConnectWithoutContractorInput = {
    where: ContractorServiceAreaWhereUniqueInput
    create: XOR<ContractorServiceAreaCreateWithoutContractorInput, ContractorServiceAreaUncheckedCreateWithoutContractorInput>
  }

  export type ContractorServiceAreaCreateManyContractorInputEnvelope = {
    data: ContractorServiceAreaCreateManyContractorInput | ContractorServiceAreaCreateManyContractorInput[]
    skipDuplicates?: boolean
  }

  export type FlaggedMessageCreateWithoutContractorInput = {
    messageId?: number | null
    messageText: string
    flaggedBy: $Enums.FlaggedByType
    flaggedById: number
    reason: string
    details?: string | null
    status?: $Enums.FlagStatus
    reviewedBy?: number | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    client?: ClientCreateNestedOneWithoutFlaggedMessagesInput
  }

  export type FlaggedMessageUncheckedCreateWithoutContractorInput = {
    id?: number
    messageId?: number | null
    messageText: string
    flaggedBy: $Enums.FlaggedByType
    flaggedById: number
    clientId?: number | null
    reason: string
    details?: string | null
    status?: $Enums.FlagStatus
    reviewedBy?: number | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type FlaggedMessageCreateOrConnectWithoutContractorInput = {
    where: FlaggedMessageWhereUniqueInput
    create: XOR<FlaggedMessageCreateWithoutContractorInput, FlaggedMessageUncheckedCreateWithoutContractorInput>
  }

  export type FlaggedMessageCreateManyContractorInputEnvelope = {
    data: FlaggedMessageCreateManyContractorInput | FlaggedMessageCreateManyContractorInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteContractorCreateWithoutContractorInput = {
    createdAt?: Date | string
    client: ClientCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteContractorUncheckedCreateWithoutContractorInput = {
    id?: number
    clientId: number
    createdAt?: Date | string
  }

  export type FavoriteContractorCreateOrConnectWithoutContractorInput = {
    where: FavoriteContractorWhereUniqueInput
    create: XOR<FavoriteContractorCreateWithoutContractorInput, FavoriteContractorUncheckedCreateWithoutContractorInput>
  }

  export type FavoriteContractorCreateManyContractorInputEnvelope = {
    data: FavoriteContractorCreateManyContractorInput | FavoriteContractorCreateManyContractorInput[]
    skipDuplicates?: boolean
  }

  export type MaterialCreateWithoutContractorInput = {
    name: string
    price: number
    unit: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialUncheckedCreateWithoutContractorInput = {
    id?: number
    name: string
    price: number
    unit: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialCreateOrConnectWithoutContractorInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutContractorInput, MaterialUncheckedCreateWithoutContractorInput>
  }

  export type MaterialCreateManyContractorInputEnvelope = {
    data: MaterialCreateManyContractorInput | MaterialCreateManyContractorInput[]
    skipDuplicates?: boolean
  }

  export type ContractorLanguageCreateWithoutContractorInput = {
    createdAt?: Date | string
    language: LanguageCreateNestedOneWithoutContractorsInput
  }

  export type ContractorLanguageUncheckedCreateWithoutContractorInput = {
    id?: number
    languageId: number
    createdAt?: Date | string
  }

  export type ContractorLanguageCreateOrConnectWithoutContractorInput = {
    where: ContractorLanguageWhereUniqueInput
    create: XOR<ContractorLanguageCreateWithoutContractorInput, ContractorLanguageUncheckedCreateWithoutContractorInput>
  }

  export type ContractorLanguageCreateManyContractorInputEnvelope = {
    data: ContractorLanguageCreateManyContractorInput | ContractorLanguageCreateManyContractorInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutContractorInput = {
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutContractorInput = {
    id?: number
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutContractorInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutContractorInput, SubscriptionUncheckedCreateWithoutContractorInput>
  }

  export type UserUpsertWithoutContractorInput = {
    update: XOR<UserUpdateWithoutContractorInput, UserUncheckedUpdateWithoutContractorInput>
    create: XOR<UserCreateWithoutContractorInput, UserUncheckedCreateWithoutContractorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContractorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContractorInput, UserUncheckedUpdateWithoutContractorInput>
  }

  export type UserUpdateWithoutContractorInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ContractorServiceUpsertWithWhereUniqueWithoutContractorInput = {
    where: ContractorServiceWhereUniqueInput
    update: XOR<ContractorServiceUpdateWithoutContractorInput, ContractorServiceUncheckedUpdateWithoutContractorInput>
    create: XOR<ContractorServiceCreateWithoutContractorInput, ContractorServiceUncheckedCreateWithoutContractorInput>
  }

  export type ContractorServiceUpdateWithWhereUniqueWithoutContractorInput = {
    where: ContractorServiceWhereUniqueInput
    data: XOR<ContractorServiceUpdateWithoutContractorInput, ContractorServiceUncheckedUpdateWithoutContractorInput>
  }

  export type ContractorServiceUpdateManyWithWhereWithoutContractorInput = {
    where: ContractorServiceScalarWhereInput
    data: XOR<ContractorServiceUpdateManyMutationInput, ContractorServiceUncheckedUpdateManyWithoutContractorInput>
  }

  export type ContractorServiceScalarWhereInput = {
    AND?: ContractorServiceScalarWhereInput | ContractorServiceScalarWhereInput[]
    OR?: ContractorServiceScalarWhereInput[]
    NOT?: ContractorServiceScalarWhereInput | ContractorServiceScalarWhereInput[]
    id?: IntFilter<"ContractorService"> | number
    contractorId?: IntFilter<"ContractorService"> | number
    serviceId?: IntFilter<"ContractorService"> | number
    basePrice?: FloatNullableFilter<"ContractorService"> | number | null
    createdAt?: DateTimeFilter<"ContractorService"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutContractorInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutContractorInput, BookingUncheckedUpdateWithoutContractorInput>
    create: XOR<BookingCreateWithoutContractorInput, BookingUncheckedCreateWithoutContractorInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutContractorInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutContractorInput, BookingUncheckedUpdateWithoutContractorInput>
  }

  export type BookingUpdateManyWithWhereWithoutContractorInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutContractorInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutContractorInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutContractorInput, ReviewUncheckedUpdateWithoutContractorInput>
    create: XOR<ReviewCreateWithoutContractorInput, ReviewUncheckedCreateWithoutContractorInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutContractorInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutContractorInput, ReviewUncheckedUpdateWithoutContractorInput>
  }

  export type ReviewUpdateManyWithWhereWithoutContractorInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutContractorInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutContractorInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutContractorInput, MessageUncheckedUpdateWithoutContractorInput>
    create: XOR<MessageCreateWithoutContractorInput, MessageUncheckedCreateWithoutContractorInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutContractorInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutContractorInput, MessageUncheckedUpdateWithoutContractorInput>
  }

  export type MessageUpdateManyWithWhereWithoutContractorInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutContractorInput>
  }

  export type AvailabilityUpsertWithWhereUniqueWithoutContractorInput = {
    where: AvailabilityWhereUniqueInput
    update: XOR<AvailabilityUpdateWithoutContractorInput, AvailabilityUncheckedUpdateWithoutContractorInput>
    create: XOR<AvailabilityCreateWithoutContractorInput, AvailabilityUncheckedCreateWithoutContractorInput>
  }

  export type AvailabilityUpdateWithWhereUniqueWithoutContractorInput = {
    where: AvailabilityWhereUniqueInput
    data: XOR<AvailabilityUpdateWithoutContractorInput, AvailabilityUncheckedUpdateWithoutContractorInput>
  }

  export type AvailabilityUpdateManyWithWhereWithoutContractorInput = {
    where: AvailabilityScalarWhereInput
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyWithoutContractorInput>
  }

  export type AvailabilityScalarWhereInput = {
    AND?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
    OR?: AvailabilityScalarWhereInput[]
    NOT?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
    id?: IntFilter<"Availability"> | number
    contractorId?: IntFilter<"Availability"> | number
    dayOfWeek?: IntNullableFilter<"Availability"> | number | null
    specificDate?: DateTimeNullableFilter<"Availability"> | Date | string | null
    startTime?: StringFilter<"Availability"> | string
    endTime?: StringFilter<"Availability"> | string
    maxBookings?: IntFilter<"Availability"> | number
    isAvailable?: BoolFilter<"Availability"> | boolean
    isRecurring?: BoolFilter<"Availability"> | boolean
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
  }

  export type TimeSlotUpsertWithWhereUniqueWithoutContractorInput = {
    where: TimeSlotWhereUniqueInput
    update: XOR<TimeSlotUpdateWithoutContractorInput, TimeSlotUncheckedUpdateWithoutContractorInput>
    create: XOR<TimeSlotCreateWithoutContractorInput, TimeSlotUncheckedCreateWithoutContractorInput>
  }

  export type TimeSlotUpdateWithWhereUniqueWithoutContractorInput = {
    where: TimeSlotWhereUniqueInput
    data: XOR<TimeSlotUpdateWithoutContractorInput, TimeSlotUncheckedUpdateWithoutContractorInput>
  }

  export type TimeSlotUpdateManyWithWhereWithoutContractorInput = {
    where: TimeSlotScalarWhereInput
    data: XOR<TimeSlotUpdateManyMutationInput, TimeSlotUncheckedUpdateManyWithoutContractorInput>
  }

  export type TimeSlotScalarWhereInput = {
    AND?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
    OR?: TimeSlotScalarWhereInput[]
    NOT?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
    id?: IntFilter<"TimeSlot"> | number
    contractorId?: IntFilter<"TimeSlot"> | number
    date?: DateTimeFilter<"TimeSlot"> | Date | string
    startTime?: StringFilter<"TimeSlot"> | string
    endTime?: StringFilter<"TimeSlot"> | string
    slotType?: EnumSlotTypeFilter<"TimeSlot"> | $Enums.SlotType
    bookingId?: IntNullableFilter<"TimeSlot"> | number | null
    reason?: StringNullableFilter<"TimeSlot"> | string | null
    createdAt?: DateTimeFilter<"TimeSlot"> | Date | string
    updatedAt?: DateTimeFilter<"TimeSlot"> | Date | string
  }

  export type ContractorServiceAreaUpsertWithWhereUniqueWithoutContractorInput = {
    where: ContractorServiceAreaWhereUniqueInput
    update: XOR<ContractorServiceAreaUpdateWithoutContractorInput, ContractorServiceAreaUncheckedUpdateWithoutContractorInput>
    create: XOR<ContractorServiceAreaCreateWithoutContractorInput, ContractorServiceAreaUncheckedCreateWithoutContractorInput>
  }

  export type ContractorServiceAreaUpdateWithWhereUniqueWithoutContractorInput = {
    where: ContractorServiceAreaWhereUniqueInput
    data: XOR<ContractorServiceAreaUpdateWithoutContractorInput, ContractorServiceAreaUncheckedUpdateWithoutContractorInput>
  }

  export type ContractorServiceAreaUpdateManyWithWhereWithoutContractorInput = {
    where: ContractorServiceAreaScalarWhereInput
    data: XOR<ContractorServiceAreaUpdateManyMutationInput, ContractorServiceAreaUncheckedUpdateManyWithoutContractorInput>
  }

  export type ContractorServiceAreaScalarWhereInput = {
    AND?: ContractorServiceAreaScalarWhereInput | ContractorServiceAreaScalarWhereInput[]
    OR?: ContractorServiceAreaScalarWhereInput[]
    NOT?: ContractorServiceAreaScalarWhereInput | ContractorServiceAreaScalarWhereInput[]
    id?: IntFilter<"ContractorServiceArea"> | number
    contractorId?: IntFilter<"ContractorServiceArea"> | number
    dayOfWeek?: IntNullableFilter<"ContractorServiceArea"> | number | null
    area?: StringFilter<"ContractorServiceArea"> | string
    isActive?: BoolFilter<"ContractorServiceArea"> | boolean
    createdAt?: DateTimeFilter<"ContractorServiceArea"> | Date | string
    updatedAt?: DateTimeFilter<"ContractorServiceArea"> | Date | string
  }

  export type FlaggedMessageUpsertWithWhereUniqueWithoutContractorInput = {
    where: FlaggedMessageWhereUniqueInput
    update: XOR<FlaggedMessageUpdateWithoutContractorInput, FlaggedMessageUncheckedUpdateWithoutContractorInput>
    create: XOR<FlaggedMessageCreateWithoutContractorInput, FlaggedMessageUncheckedCreateWithoutContractorInput>
  }

  export type FlaggedMessageUpdateWithWhereUniqueWithoutContractorInput = {
    where: FlaggedMessageWhereUniqueInput
    data: XOR<FlaggedMessageUpdateWithoutContractorInput, FlaggedMessageUncheckedUpdateWithoutContractorInput>
  }

  export type FlaggedMessageUpdateManyWithWhereWithoutContractorInput = {
    where: FlaggedMessageScalarWhereInput
    data: XOR<FlaggedMessageUpdateManyMutationInput, FlaggedMessageUncheckedUpdateManyWithoutContractorInput>
  }

  export type FavoriteContractorUpsertWithWhereUniqueWithoutContractorInput = {
    where: FavoriteContractorWhereUniqueInput
    update: XOR<FavoriteContractorUpdateWithoutContractorInput, FavoriteContractorUncheckedUpdateWithoutContractorInput>
    create: XOR<FavoriteContractorCreateWithoutContractorInput, FavoriteContractorUncheckedCreateWithoutContractorInput>
  }

  export type FavoriteContractorUpdateWithWhereUniqueWithoutContractorInput = {
    where: FavoriteContractorWhereUniqueInput
    data: XOR<FavoriteContractorUpdateWithoutContractorInput, FavoriteContractorUncheckedUpdateWithoutContractorInput>
  }

  export type FavoriteContractorUpdateManyWithWhereWithoutContractorInput = {
    where: FavoriteContractorScalarWhereInput
    data: XOR<FavoriteContractorUpdateManyMutationInput, FavoriteContractorUncheckedUpdateManyWithoutContractorInput>
  }

  export type MaterialUpsertWithWhereUniqueWithoutContractorInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutContractorInput, MaterialUncheckedUpdateWithoutContractorInput>
    create: XOR<MaterialCreateWithoutContractorInput, MaterialUncheckedCreateWithoutContractorInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutContractorInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutContractorInput, MaterialUncheckedUpdateWithoutContractorInput>
  }

  export type MaterialUpdateManyWithWhereWithoutContractorInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutContractorInput>
  }

  export type MaterialScalarWhereInput = {
    AND?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    OR?: MaterialScalarWhereInput[]
    NOT?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    id?: IntFilter<"Material"> | number
    contractorId?: IntFilter<"Material"> | number
    name?: StringFilter<"Material"> | string
    price?: FloatFilter<"Material"> | number
    unit?: StringFilter<"Material"> | string
    description?: StringNullableFilter<"Material"> | string | null
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
  }

  export type ContractorLanguageUpsertWithWhereUniqueWithoutContractorInput = {
    where: ContractorLanguageWhereUniqueInput
    update: XOR<ContractorLanguageUpdateWithoutContractorInput, ContractorLanguageUncheckedUpdateWithoutContractorInput>
    create: XOR<ContractorLanguageCreateWithoutContractorInput, ContractorLanguageUncheckedCreateWithoutContractorInput>
  }

  export type ContractorLanguageUpdateWithWhereUniqueWithoutContractorInput = {
    where: ContractorLanguageWhereUniqueInput
    data: XOR<ContractorLanguageUpdateWithoutContractorInput, ContractorLanguageUncheckedUpdateWithoutContractorInput>
  }

  export type ContractorLanguageUpdateManyWithWhereWithoutContractorInput = {
    where: ContractorLanguageScalarWhereInput
    data: XOR<ContractorLanguageUpdateManyMutationInput, ContractorLanguageUncheckedUpdateManyWithoutContractorInput>
  }

  export type ContractorLanguageScalarWhereInput = {
    AND?: ContractorLanguageScalarWhereInput | ContractorLanguageScalarWhereInput[]
    OR?: ContractorLanguageScalarWhereInput[]
    NOT?: ContractorLanguageScalarWhereInput | ContractorLanguageScalarWhereInput[]
    id?: IntFilter<"ContractorLanguage"> | number
    contractorId?: IntFilter<"ContractorLanguage"> | number
    languageId?: IntFilter<"ContractorLanguage"> | number
    createdAt?: DateTimeFilter<"ContractorLanguage"> | Date | string
  }

  export type SubscriptionUpsertWithoutContractorInput = {
    update: XOR<SubscriptionUpdateWithoutContractorInput, SubscriptionUncheckedUpdateWithoutContractorInput>
    create: XOR<SubscriptionCreateWithoutContractorInput, SubscriptionUncheckedCreateWithoutContractorInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutContractorInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutContractorInput, SubscriptionUncheckedUpdateWithoutContractorInput>
  }

  export type SubscriptionUpdateWithoutContractorInput = {
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorCreateWithoutSubscriptionInput = {
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContractorInput
    services?: ContractorServiceCreateNestedManyWithoutContractorInput
    bookings?: BookingCreateNestedManyWithoutContractorInput
    reviews?: ReviewCreateNestedManyWithoutContractorInput
    messages?: MessageCreateNestedManyWithoutContractorInput
    availability?: AvailabilityCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorCreateNestedManyWithoutContractorInput
    materials?: MaterialCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageCreateNestedManyWithoutContractorInput
  }

  export type ContractorUncheckedCreateWithoutSubscriptionInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ContractorServiceUncheckedCreateNestedManyWithoutContractorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutContractorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractorInput
    messages?: MessageUncheckedCreateNestedManyWithoutContractorInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaUncheckedCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorUncheckedCreateNestedManyWithoutContractorInput
    materials?: MaterialUncheckedCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageUncheckedCreateNestedManyWithoutContractorInput
  }

  export type ContractorCreateOrConnectWithoutSubscriptionInput = {
    where: ContractorWhereUniqueInput
    create: XOR<ContractorCreateWithoutSubscriptionInput, ContractorUncheckedCreateWithoutSubscriptionInput>
  }

  export type ContractorUpsertWithoutSubscriptionInput = {
    update: XOR<ContractorUpdateWithoutSubscriptionInput, ContractorUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<ContractorCreateWithoutSubscriptionInput, ContractorUncheckedCreateWithoutSubscriptionInput>
    where?: ContractorWhereInput
  }

  export type ContractorUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: ContractorWhereInput
    data: XOR<ContractorUpdateWithoutSubscriptionInput, ContractorUncheckedUpdateWithoutSubscriptionInput>
  }

  export type ContractorUpdateWithoutSubscriptionInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContractorNestedInput
    services?: ContractorServiceUpdateManyWithoutContractorNestedInput
    bookings?: BookingUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUpdateManyWithoutContractorNestedInput
    messages?: MessageUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUpdateManyWithoutContractorNestedInput
    materials?: MaterialUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUpdateManyWithoutContractorNestedInput
  }

  export type ContractorUncheckedUpdateWithoutSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ContractorServiceUncheckedUpdateManyWithoutContractorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUncheckedUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUncheckedUpdateManyWithoutContractorNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUncheckedUpdateManyWithoutContractorNestedInput
  }

  export type ContractorLanguageCreateWithoutLanguageInput = {
    createdAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutLanguagesInput
  }

  export type ContractorLanguageUncheckedCreateWithoutLanguageInput = {
    id?: number
    contractorId: number
    createdAt?: Date | string
  }

  export type ContractorLanguageCreateOrConnectWithoutLanguageInput = {
    where: ContractorLanguageWhereUniqueInput
    create: XOR<ContractorLanguageCreateWithoutLanguageInput, ContractorLanguageUncheckedCreateWithoutLanguageInput>
  }

  export type ContractorLanguageCreateManyLanguageInputEnvelope = {
    data: ContractorLanguageCreateManyLanguageInput | ContractorLanguageCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type ContractorLanguageUpsertWithWhereUniqueWithoutLanguageInput = {
    where: ContractorLanguageWhereUniqueInput
    update: XOR<ContractorLanguageUpdateWithoutLanguageInput, ContractorLanguageUncheckedUpdateWithoutLanguageInput>
    create: XOR<ContractorLanguageCreateWithoutLanguageInput, ContractorLanguageUncheckedCreateWithoutLanguageInput>
  }

  export type ContractorLanguageUpdateWithWhereUniqueWithoutLanguageInput = {
    where: ContractorLanguageWhereUniqueInput
    data: XOR<ContractorLanguageUpdateWithoutLanguageInput, ContractorLanguageUncheckedUpdateWithoutLanguageInput>
  }

  export type ContractorLanguageUpdateManyWithWhereWithoutLanguageInput = {
    where: ContractorLanguageScalarWhereInput
    data: XOR<ContractorLanguageUpdateManyMutationInput, ContractorLanguageUncheckedUpdateManyWithoutLanguageInput>
  }

  export type ContractorCreateWithoutLanguagesInput = {
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContractorInput
    services?: ContractorServiceCreateNestedManyWithoutContractorInput
    bookings?: BookingCreateNestedManyWithoutContractorInput
    reviews?: ReviewCreateNestedManyWithoutContractorInput
    messages?: MessageCreateNestedManyWithoutContractorInput
    availability?: AvailabilityCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorCreateNestedManyWithoutContractorInput
    materials?: MaterialCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionCreateNestedOneWithoutContractorInput
  }

  export type ContractorUncheckedCreateWithoutLanguagesInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ContractorServiceUncheckedCreateNestedManyWithoutContractorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutContractorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractorInput
    messages?: MessageUncheckedCreateNestedManyWithoutContractorInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaUncheckedCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorUncheckedCreateNestedManyWithoutContractorInput
    materials?: MaterialUncheckedCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutContractorInput
  }

  export type ContractorCreateOrConnectWithoutLanguagesInput = {
    where: ContractorWhereUniqueInput
    create: XOR<ContractorCreateWithoutLanguagesInput, ContractorUncheckedCreateWithoutLanguagesInput>
  }

  export type LanguageCreateWithoutContractorsInput = {
    name: string
    code: string
    flag: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type LanguageUncheckedCreateWithoutContractorsInput = {
    id?: number
    name: string
    code: string
    flag: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type LanguageCreateOrConnectWithoutContractorsInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutContractorsInput, LanguageUncheckedCreateWithoutContractorsInput>
  }

  export type ContractorUpsertWithoutLanguagesInput = {
    update: XOR<ContractorUpdateWithoutLanguagesInput, ContractorUncheckedUpdateWithoutLanguagesInput>
    create: XOR<ContractorCreateWithoutLanguagesInput, ContractorUncheckedCreateWithoutLanguagesInput>
    where?: ContractorWhereInput
  }

  export type ContractorUpdateToOneWithWhereWithoutLanguagesInput = {
    where?: ContractorWhereInput
    data: XOR<ContractorUpdateWithoutLanguagesInput, ContractorUncheckedUpdateWithoutLanguagesInput>
  }

  export type ContractorUpdateWithoutLanguagesInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContractorNestedInput
    services?: ContractorServiceUpdateManyWithoutContractorNestedInput
    bookings?: BookingUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUpdateManyWithoutContractorNestedInput
    messages?: MessageUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUpdateManyWithoutContractorNestedInput
    materials?: MaterialUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUpdateOneWithoutContractorNestedInput
  }

  export type ContractorUncheckedUpdateWithoutLanguagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ContractorServiceUncheckedUpdateManyWithoutContractorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUncheckedUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUncheckedUpdateManyWithoutContractorNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutContractorNestedInput
  }

  export type LanguageUpsertWithoutContractorsInput = {
    update: XOR<LanguageUpdateWithoutContractorsInput, LanguageUncheckedUpdateWithoutContractorsInput>
    create: XOR<LanguageCreateWithoutContractorsInput, LanguageUncheckedCreateWithoutContractorsInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutContractorsInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutContractorsInput, LanguageUncheckedUpdateWithoutContractorsInput>
  }

  export type LanguageUpdateWithoutContractorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateWithoutContractorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorServiceCreateWithoutServiceInput = {
    basePrice?: number | null
    createdAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutServicesInput
  }

  export type ContractorServiceUncheckedCreateWithoutServiceInput = {
    id?: number
    contractorId: number
    basePrice?: number | null
    createdAt?: Date | string
  }

  export type ContractorServiceCreateOrConnectWithoutServiceInput = {
    where: ContractorServiceWhereUniqueInput
    create: XOR<ContractorServiceCreateWithoutServiceInput, ContractorServiceUncheckedCreateWithoutServiceInput>
  }

  export type ContractorServiceCreateManyServiceInputEnvelope = {
    data: ContractorServiceCreateManyServiceInput | ContractorServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutServiceInput = {
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutBookingsInput
    client: ClientCreateNestedOneWithoutBookingsInput
    completion?: JobCompletionCreateNestedOneWithoutBookingInput
    photos?: JobPhotoCreateNestedManyWithoutBookingInput
    invoice?: InvoiceCreateNestedOneWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    reports?: ReportCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutServiceInput = {
    id?: number
    contractorId: number
    clientId: number
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completion?: JobCompletionUncheckedCreateNestedOneWithoutBookingInput
    photos?: JobPhotoUncheckedCreateNestedManyWithoutBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    reports?: ReportUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutServiceInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput>
  }

  export type BookingCreateManyServiceInputEnvelope = {
    data: BookingCreateManyServiceInput | BookingCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ContractorServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: ContractorServiceWhereUniqueInput
    update: XOR<ContractorServiceUpdateWithoutServiceInput, ContractorServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<ContractorServiceCreateWithoutServiceInput, ContractorServiceUncheckedCreateWithoutServiceInput>
  }

  export type ContractorServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: ContractorServiceWhereUniqueInput
    data: XOR<ContractorServiceUpdateWithoutServiceInput, ContractorServiceUncheckedUpdateWithoutServiceInput>
  }

  export type ContractorServiceUpdateManyWithWhereWithoutServiceInput = {
    where: ContractorServiceScalarWhereInput
    data: XOR<ContractorServiceUpdateManyMutationInput, ContractorServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutServiceInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutServiceInput, BookingUncheckedUpdateWithoutServiceInput>
    create: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutServiceInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutServiceInput, BookingUncheckedUpdateWithoutServiceInput>
  }

  export type BookingUpdateManyWithWhereWithoutServiceInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutServiceInput>
  }

  export type ContractorCreateWithoutServicesInput = {
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContractorInput
    bookings?: BookingCreateNestedManyWithoutContractorInput
    reviews?: ReviewCreateNestedManyWithoutContractorInput
    messages?: MessageCreateNestedManyWithoutContractorInput
    availability?: AvailabilityCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorCreateNestedManyWithoutContractorInput
    materials?: MaterialCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionCreateNestedOneWithoutContractorInput
  }

  export type ContractorUncheckedCreateWithoutServicesInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutContractorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractorInput
    messages?: MessageUncheckedCreateNestedManyWithoutContractorInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaUncheckedCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorUncheckedCreateNestedManyWithoutContractorInput
    materials?: MaterialUncheckedCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageUncheckedCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutContractorInput
  }

  export type ContractorCreateOrConnectWithoutServicesInput = {
    where: ContractorWhereUniqueInput
    create: XOR<ContractorCreateWithoutServicesInput, ContractorUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutContractorsInput = {
    name: string
    icon: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutContractorsInput = {
    id?: number
    name: string
    icon: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutContractorsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutContractorsInput, ServiceUncheckedCreateWithoutContractorsInput>
  }

  export type ContractorUpsertWithoutServicesInput = {
    update: XOR<ContractorUpdateWithoutServicesInput, ContractorUncheckedUpdateWithoutServicesInput>
    create: XOR<ContractorCreateWithoutServicesInput, ContractorUncheckedCreateWithoutServicesInput>
    where?: ContractorWhereInput
  }

  export type ContractorUpdateToOneWithWhereWithoutServicesInput = {
    where?: ContractorWhereInput
    data: XOR<ContractorUpdateWithoutServicesInput, ContractorUncheckedUpdateWithoutServicesInput>
  }

  export type ContractorUpdateWithoutServicesInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContractorNestedInput
    bookings?: BookingUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUpdateManyWithoutContractorNestedInput
    messages?: MessageUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUpdateManyWithoutContractorNestedInput
    materials?: MaterialUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUpdateOneWithoutContractorNestedInput
  }

  export type ContractorUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUncheckedUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUncheckedUpdateManyWithoutContractorNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUncheckedUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutContractorNestedInput
  }

  export type ServiceUpsertWithoutContractorsInput = {
    update: XOR<ServiceUpdateWithoutContractorsInput, ServiceUncheckedUpdateWithoutContractorsInput>
    create: XOR<ServiceCreateWithoutContractorsInput, ServiceUncheckedCreateWithoutContractorsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutContractorsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutContractorsInput, ServiceUncheckedUpdateWithoutContractorsInput>
  }

  export type ServiceUpdateWithoutContractorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutContractorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ContractorCreateWithoutBookingsInput = {
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContractorInput
    services?: ContractorServiceCreateNestedManyWithoutContractorInput
    reviews?: ReviewCreateNestedManyWithoutContractorInput
    messages?: MessageCreateNestedManyWithoutContractorInput
    availability?: AvailabilityCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorCreateNestedManyWithoutContractorInput
    materials?: MaterialCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionCreateNestedOneWithoutContractorInput
  }

  export type ContractorUncheckedCreateWithoutBookingsInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ContractorServiceUncheckedCreateNestedManyWithoutContractorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractorInput
    messages?: MessageUncheckedCreateNestedManyWithoutContractorInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaUncheckedCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorUncheckedCreateNestedManyWithoutContractorInput
    materials?: MaterialUncheckedCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageUncheckedCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutContractorInput
  }

  export type ContractorCreateOrConnectWithoutBookingsInput = {
    where: ContractorWhereUniqueInput
    create: XOR<ContractorCreateWithoutBookingsInput, ContractorUncheckedCreateWithoutBookingsInput>
  }

  export type ClientCreateWithoutBookingsInput = {
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    messages?: MessageCreateNestedManyWithoutClientInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutClientInput
    favorites?: FavoriteContractorCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutBookingsInput = {
    id?: number
    userId: number
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    messages?: MessageUncheckedCreateNestedManyWithoutClientInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutClientInput
    favorites?: FavoriteContractorUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutBookingsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutBookingsInput, ClientUncheckedCreateWithoutBookingsInput>
  }

  export type ServiceCreateWithoutBookingsInput = {
    name: string
    icon: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    contractors?: ContractorServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    icon: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    contractors?: ContractorServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutBookingsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
  }

  export type JobCompletionCreateWithoutBookingInput = {
    startTime?: Date | string | null
    endTime?: Date | string | null
    materials?: string | null
    notes?: string | null
    audioNoteUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCompletionUncheckedCreateWithoutBookingInput = {
    id?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    materials?: string | null
    notes?: string | null
    audioNoteUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCompletionCreateOrConnectWithoutBookingInput = {
    where: JobCompletionWhereUniqueInput
    create: XOR<JobCompletionCreateWithoutBookingInput, JobCompletionUncheckedCreateWithoutBookingInput>
  }

  export type JobPhotoCreateWithoutBookingInput = {
    filename: string
    originalName: string
    photoType: $Enums.PhotoType
    fileSize: number
    url: string
    createdAt?: Date | string
  }

  export type JobPhotoUncheckedCreateWithoutBookingInput = {
    id?: number
    filename: string
    originalName: string
    photoType: $Enums.PhotoType
    fileSize: number
    url: string
    createdAt?: Date | string
  }

  export type JobPhotoCreateOrConnectWithoutBookingInput = {
    where: JobPhotoWhereUniqueInput
    create: XOR<JobPhotoCreateWithoutBookingInput, JobPhotoUncheckedCreateWithoutBookingInput>
  }

  export type JobPhotoCreateManyBookingInputEnvelope = {
    data: JobPhotoCreateManyBookingInput | JobPhotoCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutBookingInput = {
    amount: number
    taxAmount?: number | null
    totalAmount: number
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    stripePaymentIntentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutBookingInput = {
    id?: number
    amount: number
    taxAmount?: number | null
    totalAmount: number
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    stripePaymentIntentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutBookingInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutBookingInput, InvoiceUncheckedCreateWithoutBookingInput>
  }

  export type PaymentCreateWithoutBookingInput = {
    amount: number
    paymentMethod: string
    stripePaymentId?: string | null
    stripePaymentIntent?: string | null
    platformFee?: number | null
    contractorPayout?: number | null
    stripeTransferId?: string | null
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
    createdAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    id?: number
    invoiceId?: number | null
    amount: number
    paymentMethod: string
    stripePaymentId?: string | null
    stripePaymentIntent?: string | null
    platformFee?: number | null
    contractorPayout?: number | null
    stripeTransferId?: string | null
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentCreateManyBookingInputEnvelope = {
    data: PaymentCreateManyBookingInput | PaymentCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutBookingInput = {
    type: $Enums.ReportType
    reporterType: $Enums.ReporterType
    reporterId: number
    reportedUserId?: number | null
    reportedUserType?: $Enums.ReporterType | null
    reason: string
    description: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    priority?: $Enums.ReportPriority
    assignedTo?: number | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUncheckedCreateWithoutBookingInput = {
    id?: number
    type: $Enums.ReportType
    reporterType: $Enums.ReporterType
    reporterId: number
    reportedUserId?: number | null
    reportedUserType?: $Enums.ReporterType | null
    reason: string
    description: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    priority?: $Enums.ReportPriority
    assignedTo?: number | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutBookingInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutBookingInput, ReportUncheckedCreateWithoutBookingInput>
  }

  export type ReportCreateManyBookingInputEnvelope = {
    data: ReportCreateManyBookingInput | ReportCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type ContractorUpsertWithoutBookingsInput = {
    update: XOR<ContractorUpdateWithoutBookingsInput, ContractorUncheckedUpdateWithoutBookingsInput>
    create: XOR<ContractorCreateWithoutBookingsInput, ContractorUncheckedCreateWithoutBookingsInput>
    where?: ContractorWhereInput
  }

  export type ContractorUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ContractorWhereInput
    data: XOR<ContractorUpdateWithoutBookingsInput, ContractorUncheckedUpdateWithoutBookingsInput>
  }

  export type ContractorUpdateWithoutBookingsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContractorNestedInput
    services?: ContractorServiceUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUpdateManyWithoutContractorNestedInput
    messages?: MessageUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUpdateManyWithoutContractorNestedInput
    materials?: MaterialUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUpdateOneWithoutContractorNestedInput
  }

  export type ContractorUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ContractorServiceUncheckedUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUncheckedUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUncheckedUpdateManyWithoutContractorNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUncheckedUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutContractorNestedInput
  }

  export type ClientUpsertWithoutBookingsInput = {
    update: XOR<ClientUpdateWithoutBookingsInput, ClientUncheckedUpdateWithoutBookingsInput>
    create: XOR<ClientCreateWithoutBookingsInput, ClientUncheckedCreateWithoutBookingsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutBookingsInput, ClientUncheckedUpdateWithoutBookingsInput>
  }

  export type ClientUpdateWithoutBookingsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    messages?: MessageUpdateManyWithoutClientNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutClientNestedInput
    favorites?: FavoriteContractorUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClientNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutClientNestedInput
    favorites?: FavoriteContractorUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ServiceUpsertWithoutBookingsInput = {
    update: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractors?: ContractorServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractors?: ContractorServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type JobCompletionUpsertWithoutBookingInput = {
    update: XOR<JobCompletionUpdateWithoutBookingInput, JobCompletionUncheckedUpdateWithoutBookingInput>
    create: XOR<JobCompletionCreateWithoutBookingInput, JobCompletionUncheckedCreateWithoutBookingInput>
    where?: JobCompletionWhereInput
  }

  export type JobCompletionUpdateToOneWithWhereWithoutBookingInput = {
    where?: JobCompletionWhereInput
    data: XOR<JobCompletionUpdateWithoutBookingInput, JobCompletionUncheckedUpdateWithoutBookingInput>
  }

  export type JobCompletionUpdateWithoutBookingInput = {
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    materials?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    audioNoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCompletionUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    materials?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    audioNoteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPhotoUpsertWithWhereUniqueWithoutBookingInput = {
    where: JobPhotoWhereUniqueInput
    update: XOR<JobPhotoUpdateWithoutBookingInput, JobPhotoUncheckedUpdateWithoutBookingInput>
    create: XOR<JobPhotoCreateWithoutBookingInput, JobPhotoUncheckedCreateWithoutBookingInput>
  }

  export type JobPhotoUpdateWithWhereUniqueWithoutBookingInput = {
    where: JobPhotoWhereUniqueInput
    data: XOR<JobPhotoUpdateWithoutBookingInput, JobPhotoUncheckedUpdateWithoutBookingInput>
  }

  export type JobPhotoUpdateManyWithWhereWithoutBookingInput = {
    where: JobPhotoScalarWhereInput
    data: XOR<JobPhotoUpdateManyMutationInput, JobPhotoUncheckedUpdateManyWithoutBookingInput>
  }

  export type JobPhotoScalarWhereInput = {
    AND?: JobPhotoScalarWhereInput | JobPhotoScalarWhereInput[]
    OR?: JobPhotoScalarWhereInput[]
    NOT?: JobPhotoScalarWhereInput | JobPhotoScalarWhereInput[]
    id?: IntFilter<"JobPhoto"> | number
    bookingId?: IntFilter<"JobPhoto"> | number
    filename?: StringFilter<"JobPhoto"> | string
    originalName?: StringFilter<"JobPhoto"> | string
    photoType?: EnumPhotoTypeFilter<"JobPhoto"> | $Enums.PhotoType
    fileSize?: IntFilter<"JobPhoto"> | number
    url?: StringFilter<"JobPhoto"> | string
    createdAt?: DateTimeFilter<"JobPhoto"> | Date | string
  }

  export type InvoiceUpsertWithoutBookingInput = {
    update: XOR<InvoiceUpdateWithoutBookingInput, InvoiceUncheckedUpdateWithoutBookingInput>
    create: XOR<InvoiceCreateWithoutBookingInput, InvoiceUncheckedCreateWithoutBookingInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutBookingInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutBookingInput, InvoiceUncheckedUpdateWithoutBookingInput>
  }

  export type InvoiceUpdateWithoutBookingInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBookingInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutBookingInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    bookingId?: IntFilter<"Payment"> | number
    invoiceId?: IntNullableFilter<"Payment"> | number | null
    amount?: FloatFilter<"Payment"> | number
    paymentMethod?: StringFilter<"Payment"> | string
    stripePaymentId?: StringNullableFilter<"Payment"> | string | null
    stripePaymentIntent?: StringNullableFilter<"Payment"> | string | null
    platformFee?: FloatNullableFilter<"Payment"> | number | null
    contractorPayout?: FloatNullableFilter<"Payment"> | number | null
    stripeTransferId?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutBookingInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutBookingInput, ReportUncheckedUpdateWithoutBookingInput>
    create: XOR<ReportCreateWithoutBookingInput, ReportUncheckedCreateWithoutBookingInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutBookingInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutBookingInput, ReportUncheckedUpdateWithoutBookingInput>
  }

  export type ReportUpdateManyWithWhereWithoutBookingInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutBookingInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: IntFilter<"Report"> | number
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    reporterType?: EnumReporterTypeFilter<"Report"> | $Enums.ReporterType
    reporterId?: IntFilter<"Report"> | number
    reportedUserId?: IntNullableFilter<"Report"> | number | null
    reportedUserType?: EnumReporterTypeNullableFilter<"Report"> | $Enums.ReporterType | null
    bookingId?: IntNullableFilter<"Report"> | number | null
    reason?: StringFilter<"Report"> | string
    description?: StringFilter<"Report"> | string
    evidence?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    priority?: EnumReportPriorityFilter<"Report"> | $Enums.ReportPriority
    assignedTo?: IntNullableFilter<"Report"> | number | null
    resolution?: StringNullableFilter<"Report"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type BookingCreateWithoutCompletionInput = {
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutBookingsInput
    client: ClientCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    photos?: JobPhotoCreateNestedManyWithoutBookingInput
    invoice?: InvoiceCreateNestedOneWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    reports?: ReportCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCompletionInput = {
    id?: number
    contractorId: number
    clientId: number
    serviceId: number
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: JobPhotoUncheckedCreateNestedManyWithoutBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    reports?: ReportUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCompletionInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCompletionInput, BookingUncheckedCreateWithoutCompletionInput>
  }

  export type BookingUpsertWithoutCompletionInput = {
    update: XOR<BookingUpdateWithoutCompletionInput, BookingUncheckedUpdateWithoutCompletionInput>
    create: XOR<BookingCreateWithoutCompletionInput, BookingUncheckedCreateWithoutCompletionInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutCompletionInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutCompletionInput, BookingUncheckedUpdateWithoutCompletionInput>
  }

  export type BookingUpdateWithoutCompletionInput = {
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutBookingsNestedInput
    client?: ClientUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    photos?: JobPhotoUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    reports?: ReportUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCompletionInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: JobPhotoUncheckedUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateWithoutPhotosInput = {
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutBookingsInput
    client: ClientCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    completion?: JobCompletionCreateNestedOneWithoutBookingInput
    invoice?: InvoiceCreateNestedOneWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    reports?: ReportCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPhotosInput = {
    id?: number
    contractorId: number
    clientId: number
    serviceId: number
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completion?: JobCompletionUncheckedCreateNestedOneWithoutBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    reports?: ReportUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPhotosInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPhotosInput, BookingUncheckedCreateWithoutPhotosInput>
  }

  export type BookingUpsertWithoutPhotosInput = {
    update: XOR<BookingUpdateWithoutPhotosInput, BookingUncheckedUpdateWithoutPhotosInput>
    create: XOR<BookingCreateWithoutPhotosInput, BookingUncheckedCreateWithoutPhotosInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPhotosInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPhotosInput, BookingUncheckedUpdateWithoutPhotosInput>
  }

  export type BookingUpdateWithoutPhotosInput = {
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutBookingsNestedInput
    client?: ClientUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    completion?: JobCompletionUpdateOneWithoutBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    reports?: ReportUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: JobCompletionUncheckedUpdateOneWithoutBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ContractorCreateWithoutMessagesInput = {
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContractorInput
    services?: ContractorServiceCreateNestedManyWithoutContractorInput
    bookings?: BookingCreateNestedManyWithoutContractorInput
    reviews?: ReviewCreateNestedManyWithoutContractorInput
    availability?: AvailabilityCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorCreateNestedManyWithoutContractorInput
    materials?: MaterialCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionCreateNestedOneWithoutContractorInput
  }

  export type ContractorUncheckedCreateWithoutMessagesInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ContractorServiceUncheckedCreateNestedManyWithoutContractorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutContractorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractorInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaUncheckedCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorUncheckedCreateNestedManyWithoutContractorInput
    materials?: MaterialUncheckedCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageUncheckedCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutContractorInput
  }

  export type ContractorCreateOrConnectWithoutMessagesInput = {
    where: ContractorWhereUniqueInput
    create: XOR<ContractorCreateWithoutMessagesInput, ContractorUncheckedCreateWithoutMessagesInput>
  }

  export type ClientCreateWithoutMessagesInput = {
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientInput
    bookings?: BookingCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutClientInput
    favorites?: FavoriteContractorCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutMessagesInput = {
    id?: number
    userId: number
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutClientInput
    favorites?: FavoriteContractorUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutMessagesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutMessagesInput, ClientUncheckedCreateWithoutMessagesInput>
  }

  export type ChatMessageCreateWithoutMessageInput = {
    sender: $Enums.SenderType
    messageText: string
    createdAt?: Date | string
  }

  export type ChatMessageUncheckedCreateWithoutMessageInput = {
    id?: number
    sender: $Enums.SenderType
    messageText: string
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutMessageInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutMessageInput, ChatMessageUncheckedCreateWithoutMessageInput>
  }

  export type ChatMessageCreateManyMessageInputEnvelope = {
    data: ChatMessageCreateManyMessageInput | ChatMessageCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ContractorUpsertWithoutMessagesInput = {
    update: XOR<ContractorUpdateWithoutMessagesInput, ContractorUncheckedUpdateWithoutMessagesInput>
    create: XOR<ContractorCreateWithoutMessagesInput, ContractorUncheckedCreateWithoutMessagesInput>
    where?: ContractorWhereInput
  }

  export type ContractorUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ContractorWhereInput
    data: XOR<ContractorUpdateWithoutMessagesInput, ContractorUncheckedUpdateWithoutMessagesInput>
  }

  export type ContractorUpdateWithoutMessagesInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContractorNestedInput
    services?: ContractorServiceUpdateManyWithoutContractorNestedInput
    bookings?: BookingUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUpdateManyWithoutContractorNestedInput
    materials?: MaterialUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUpdateOneWithoutContractorNestedInput
  }

  export type ContractorUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ContractorServiceUncheckedUpdateManyWithoutContractorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUncheckedUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUncheckedUpdateManyWithoutContractorNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUncheckedUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutContractorNestedInput
  }

  export type ClientUpsertWithoutMessagesInput = {
    update: XOR<ClientUpdateWithoutMessagesInput, ClientUncheckedUpdateWithoutMessagesInput>
    create: XOR<ClientCreateWithoutMessagesInput, ClientUncheckedCreateWithoutMessagesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutMessagesInput, ClientUncheckedUpdateWithoutMessagesInput>
  }

  export type ClientUpdateWithoutMessagesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    bookings?: BookingUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutClientNestedInput
    favorites?: FavoriteContractorUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutClientNestedInput
    favorites?: FavoriteContractorUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutMessageInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutMessageInput, ChatMessageUncheckedUpdateWithoutMessageInput>
    create: XOR<ChatMessageCreateWithoutMessageInput, ChatMessageUncheckedCreateWithoutMessageInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutMessageInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutMessageInput, ChatMessageUncheckedUpdateWithoutMessageInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutMessageInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutMessageInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    messageId?: IntFilter<"ChatMessage"> | number
    sender?: EnumSenderTypeFilter<"ChatMessage"> | $Enums.SenderType
    messageText?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type MessageCreateWithoutChatMessagesInput = {
    subject?: string | null
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutMessagesInput
    client: ClientCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutChatMessagesInput = {
    id?: number
    contractorId: number
    clientId: number
    subject?: string | null
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutChatMessagesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChatMessagesInput, MessageUncheckedCreateWithoutChatMessagesInput>
  }

  export type MessageUpsertWithoutChatMessagesInput = {
    update: XOR<MessageUpdateWithoutChatMessagesInput, MessageUncheckedUpdateWithoutChatMessagesInput>
    create: XOR<MessageCreateWithoutChatMessagesInput, MessageUncheckedCreateWithoutChatMessagesInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutChatMessagesInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutChatMessagesInput, MessageUncheckedUpdateWithoutChatMessagesInput>
  }

  export type MessageUpdateWithoutChatMessagesInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutMessagesNestedInput
    client?: ClientUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutChatMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorCreateWithoutFlaggedMessagesInput = {
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContractorInput
    services?: ContractorServiceCreateNestedManyWithoutContractorInput
    bookings?: BookingCreateNestedManyWithoutContractorInput
    reviews?: ReviewCreateNestedManyWithoutContractorInput
    messages?: MessageCreateNestedManyWithoutContractorInput
    availability?: AvailabilityCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorCreateNestedManyWithoutContractorInput
    materials?: MaterialCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionCreateNestedOneWithoutContractorInput
  }

  export type ContractorUncheckedCreateWithoutFlaggedMessagesInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ContractorServiceUncheckedCreateNestedManyWithoutContractorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutContractorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractorInput
    messages?: MessageUncheckedCreateNestedManyWithoutContractorInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaUncheckedCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorUncheckedCreateNestedManyWithoutContractorInput
    materials?: MaterialUncheckedCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageUncheckedCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutContractorInput
  }

  export type ContractorCreateOrConnectWithoutFlaggedMessagesInput = {
    where: ContractorWhereUniqueInput
    create: XOR<ContractorCreateWithoutFlaggedMessagesInput, ContractorUncheckedCreateWithoutFlaggedMessagesInput>
  }

  export type ClientCreateWithoutFlaggedMessagesInput = {
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientInput
    bookings?: BookingCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    messages?: MessageCreateNestedManyWithoutClientInput
    favorites?: FavoriteContractorCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutFlaggedMessagesInput = {
    id?: number
    userId: number
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    messages?: MessageUncheckedCreateNestedManyWithoutClientInput
    favorites?: FavoriteContractorUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutFlaggedMessagesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutFlaggedMessagesInput, ClientUncheckedCreateWithoutFlaggedMessagesInput>
  }

  export type ContractorUpsertWithoutFlaggedMessagesInput = {
    update: XOR<ContractorUpdateWithoutFlaggedMessagesInput, ContractorUncheckedUpdateWithoutFlaggedMessagesInput>
    create: XOR<ContractorCreateWithoutFlaggedMessagesInput, ContractorUncheckedCreateWithoutFlaggedMessagesInput>
    where?: ContractorWhereInput
  }

  export type ContractorUpdateToOneWithWhereWithoutFlaggedMessagesInput = {
    where?: ContractorWhereInput
    data: XOR<ContractorUpdateWithoutFlaggedMessagesInput, ContractorUncheckedUpdateWithoutFlaggedMessagesInput>
  }

  export type ContractorUpdateWithoutFlaggedMessagesInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContractorNestedInput
    services?: ContractorServiceUpdateManyWithoutContractorNestedInput
    bookings?: BookingUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUpdateManyWithoutContractorNestedInput
    messages?: MessageUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUpdateManyWithoutContractorNestedInput
    materials?: MaterialUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUpdateOneWithoutContractorNestedInput
  }

  export type ContractorUncheckedUpdateWithoutFlaggedMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ContractorServiceUncheckedUpdateManyWithoutContractorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUncheckedUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUncheckedUpdateManyWithoutContractorNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUncheckedUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutContractorNestedInput
  }

  export type ClientUpsertWithoutFlaggedMessagesInput = {
    update: XOR<ClientUpdateWithoutFlaggedMessagesInput, ClientUncheckedUpdateWithoutFlaggedMessagesInput>
    create: XOR<ClientCreateWithoutFlaggedMessagesInput, ClientUncheckedCreateWithoutFlaggedMessagesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutFlaggedMessagesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutFlaggedMessagesInput, ClientUncheckedUpdateWithoutFlaggedMessagesInput>
  }

  export type ClientUpdateWithoutFlaggedMessagesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    bookings?: BookingUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    messages?: MessageUpdateManyWithoutClientNestedInput
    favorites?: FavoriteContractorUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutFlaggedMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClientNestedInput
    favorites?: FavoriteContractorUncheckedUpdateManyWithoutClientNestedInput
  }

  export type BookingCreateWithoutReportsInput = {
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutBookingsInput
    client: ClientCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    completion?: JobCompletionCreateNestedOneWithoutBookingInput
    photos?: JobPhotoCreateNestedManyWithoutBookingInput
    invoice?: InvoiceCreateNestedOneWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutReportsInput = {
    id?: number
    contractorId: number
    clientId: number
    serviceId: number
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completion?: JobCompletionUncheckedCreateNestedOneWithoutBookingInput
    photos?: JobPhotoUncheckedCreateNestedManyWithoutBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutReportsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutReportsInput, BookingUncheckedCreateWithoutReportsInput>
  }

  export type BookingUpsertWithoutReportsInput = {
    update: XOR<BookingUpdateWithoutReportsInput, BookingUncheckedUpdateWithoutReportsInput>
    create: XOR<BookingCreateWithoutReportsInput, BookingUncheckedCreateWithoutReportsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutReportsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutReportsInput, BookingUncheckedUpdateWithoutReportsInput>
  }

  export type BookingUpdateWithoutReportsInput = {
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutBookingsNestedInput
    client?: ClientUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    completion?: JobCompletionUpdateOneWithoutBookingNestedInput
    photos?: JobPhotoUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: JobCompletionUncheckedUpdateOneWithoutBookingNestedInput
    photos?: JobPhotoUncheckedUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ContractorCreateWithoutReviewsInput = {
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContractorInput
    services?: ContractorServiceCreateNestedManyWithoutContractorInput
    bookings?: BookingCreateNestedManyWithoutContractorInput
    messages?: MessageCreateNestedManyWithoutContractorInput
    availability?: AvailabilityCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorCreateNestedManyWithoutContractorInput
    materials?: MaterialCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionCreateNestedOneWithoutContractorInput
  }

  export type ContractorUncheckedCreateWithoutReviewsInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ContractorServiceUncheckedCreateNestedManyWithoutContractorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutContractorInput
    messages?: MessageUncheckedCreateNestedManyWithoutContractorInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaUncheckedCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorUncheckedCreateNestedManyWithoutContractorInput
    materials?: MaterialUncheckedCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageUncheckedCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutContractorInput
  }

  export type ContractorCreateOrConnectWithoutReviewsInput = {
    where: ContractorWhereUniqueInput
    create: XOR<ContractorCreateWithoutReviewsInput, ContractorUncheckedCreateWithoutReviewsInput>
  }

  export type ClientCreateWithoutReviewsInput = {
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientInput
    bookings?: BookingCreateNestedManyWithoutClientInput
    messages?: MessageCreateNestedManyWithoutClientInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutClientInput
    favorites?: FavoriteContractorCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutReviewsInput = {
    id?: number
    userId: number
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutClientInput
    messages?: MessageUncheckedCreateNestedManyWithoutClientInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutClientInput
    favorites?: FavoriteContractorUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutReviewsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
  }

  export type ContractorUpsertWithoutReviewsInput = {
    update: XOR<ContractorUpdateWithoutReviewsInput, ContractorUncheckedUpdateWithoutReviewsInput>
    create: XOR<ContractorCreateWithoutReviewsInput, ContractorUncheckedCreateWithoutReviewsInput>
    where?: ContractorWhereInput
  }

  export type ContractorUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ContractorWhereInput
    data: XOR<ContractorUpdateWithoutReviewsInput, ContractorUncheckedUpdateWithoutReviewsInput>
  }

  export type ContractorUpdateWithoutReviewsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContractorNestedInput
    services?: ContractorServiceUpdateManyWithoutContractorNestedInput
    bookings?: BookingUpdateManyWithoutContractorNestedInput
    messages?: MessageUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUpdateManyWithoutContractorNestedInput
    materials?: MaterialUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUpdateOneWithoutContractorNestedInput
  }

  export type ContractorUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ContractorServiceUncheckedUpdateManyWithoutContractorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutContractorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUncheckedUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUncheckedUpdateManyWithoutContractorNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUncheckedUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutContractorNestedInput
  }

  export type ClientUpsertWithoutReviewsInput = {
    update: XOR<ClientUpdateWithoutReviewsInput, ClientUncheckedUpdateWithoutReviewsInput>
    create: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutReviewsInput, ClientUncheckedUpdateWithoutReviewsInput>
  }

  export type ClientUpdateWithoutReviewsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    bookings?: BookingUpdateManyWithoutClientNestedInput
    messages?: MessageUpdateManyWithoutClientNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutClientNestedInput
    favorites?: FavoriteContractorUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutClientNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClientNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutClientNestedInput
    favorites?: FavoriteContractorUncheckedUpdateManyWithoutClientNestedInput
  }

  export type BookingCreateWithoutInvoiceInput = {
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutBookingsInput
    client: ClientCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    completion?: JobCompletionCreateNestedOneWithoutBookingInput
    photos?: JobPhotoCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    reports?: ReportCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutInvoiceInput = {
    id?: number
    contractorId: number
    clientId: number
    serviceId: number
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completion?: JobCompletionUncheckedCreateNestedOneWithoutBookingInput
    photos?: JobPhotoUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    reports?: ReportUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutInvoiceInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutInvoiceInput, BookingUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateWithoutInvoiceInput = {
    amount: number
    paymentMethod: string
    stripePaymentId?: string | null
    stripePaymentIntent?: string | null
    platformFee?: number | null
    contractorPayout?: number | null
    stripeTransferId?: string | null
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: number
    bookingId: number
    amount: number
    paymentMethod: string
    stripePaymentId?: string | null
    stripePaymentIntent?: string | null
    platformFee?: number | null
    contractorPayout?: number | null
    stripeTransferId?: string | null
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithoutInvoiceInput = {
    update: XOR<BookingUpdateWithoutInvoiceInput, BookingUncheckedUpdateWithoutInvoiceInput>
    create: XOR<BookingCreateWithoutInvoiceInput, BookingUncheckedCreateWithoutInvoiceInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutInvoiceInput, BookingUncheckedUpdateWithoutInvoiceInput>
  }

  export type BookingUpdateWithoutInvoiceInput = {
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutBookingsNestedInput
    client?: ClientUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    completion?: JobCompletionUpdateOneWithoutBookingNestedInput
    photos?: JobPhotoUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    reports?: ReportUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: JobCompletionUncheckedUpdateOneWithoutBookingNestedInput
    photos?: JobPhotoUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type BookingCreateWithoutPaymentsInput = {
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor: ContractorCreateNestedOneWithoutBookingsInput
    client: ClientCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    completion?: JobCompletionCreateNestedOneWithoutBookingInput
    photos?: JobPhotoCreateNestedManyWithoutBookingInput
    invoice?: InvoiceCreateNestedOneWithoutBookingInput
    reports?: ReportCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPaymentsInput = {
    id?: number
    contractorId: number
    clientId: number
    serviceId: number
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completion?: JobCompletionUncheckedCreateNestedOneWithoutBookingInput
    photos?: JobPhotoUncheckedCreateNestedManyWithoutBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutBookingInput
    reports?: ReportUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPaymentsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    amount: number
    taxAmount?: number | null
    totalAmount: number
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    stripePaymentIntentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: number
    bookingId: number
    amount: number
    taxAmount?: number | null
    totalAmount: number
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    stripePaymentIntentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type BookingUpsertWithoutPaymentsInput = {
    update: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type BookingUpdateWithoutPaymentsInput = {
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutBookingsNestedInput
    client?: ClientUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    completion?: JobCompletionUpdateOneWithoutBookingNestedInput
    photos?: JobPhotoUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutBookingNestedInput
    reports?: ReportUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: JobCompletionUncheckedUpdateOneWithoutBookingNestedInput
    photos?: JobPhotoUncheckedUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutBookingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorCreateWithoutAvailabilityInput = {
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContractorInput
    services?: ContractorServiceCreateNestedManyWithoutContractorInput
    bookings?: BookingCreateNestedManyWithoutContractorInput
    reviews?: ReviewCreateNestedManyWithoutContractorInput
    messages?: MessageCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorCreateNestedManyWithoutContractorInput
    materials?: MaterialCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionCreateNestedOneWithoutContractorInput
  }

  export type ContractorUncheckedCreateWithoutAvailabilityInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ContractorServiceUncheckedCreateNestedManyWithoutContractorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutContractorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractorInput
    messages?: MessageUncheckedCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaUncheckedCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorUncheckedCreateNestedManyWithoutContractorInput
    materials?: MaterialUncheckedCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageUncheckedCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutContractorInput
  }

  export type ContractorCreateOrConnectWithoutAvailabilityInput = {
    where: ContractorWhereUniqueInput
    create: XOR<ContractorCreateWithoutAvailabilityInput, ContractorUncheckedCreateWithoutAvailabilityInput>
  }

  export type ContractorUpsertWithoutAvailabilityInput = {
    update: XOR<ContractorUpdateWithoutAvailabilityInput, ContractorUncheckedUpdateWithoutAvailabilityInput>
    create: XOR<ContractorCreateWithoutAvailabilityInput, ContractorUncheckedCreateWithoutAvailabilityInput>
    where?: ContractorWhereInput
  }

  export type ContractorUpdateToOneWithWhereWithoutAvailabilityInput = {
    where?: ContractorWhereInput
    data: XOR<ContractorUpdateWithoutAvailabilityInput, ContractorUncheckedUpdateWithoutAvailabilityInput>
  }

  export type ContractorUpdateWithoutAvailabilityInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContractorNestedInput
    services?: ContractorServiceUpdateManyWithoutContractorNestedInput
    bookings?: BookingUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUpdateManyWithoutContractorNestedInput
    messages?: MessageUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUpdateManyWithoutContractorNestedInput
    materials?: MaterialUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUpdateOneWithoutContractorNestedInput
  }

  export type ContractorUncheckedUpdateWithoutAvailabilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ContractorServiceUncheckedUpdateManyWithoutContractorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUncheckedUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUncheckedUpdateManyWithoutContractorNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUncheckedUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutContractorNestedInput
  }

  export type ContractorCreateWithoutTimeSlotsInput = {
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContractorInput
    services?: ContractorServiceCreateNestedManyWithoutContractorInput
    bookings?: BookingCreateNestedManyWithoutContractorInput
    reviews?: ReviewCreateNestedManyWithoutContractorInput
    messages?: MessageCreateNestedManyWithoutContractorInput
    availability?: AvailabilityCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorCreateNestedManyWithoutContractorInput
    materials?: MaterialCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionCreateNestedOneWithoutContractorInput
  }

  export type ContractorUncheckedCreateWithoutTimeSlotsInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ContractorServiceUncheckedCreateNestedManyWithoutContractorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutContractorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractorInput
    messages?: MessageUncheckedCreateNestedManyWithoutContractorInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaUncheckedCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorUncheckedCreateNestedManyWithoutContractorInput
    materials?: MaterialUncheckedCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageUncheckedCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutContractorInput
  }

  export type ContractorCreateOrConnectWithoutTimeSlotsInput = {
    where: ContractorWhereUniqueInput
    create: XOR<ContractorCreateWithoutTimeSlotsInput, ContractorUncheckedCreateWithoutTimeSlotsInput>
  }

  export type ContractorUpsertWithoutTimeSlotsInput = {
    update: XOR<ContractorUpdateWithoutTimeSlotsInput, ContractorUncheckedUpdateWithoutTimeSlotsInput>
    create: XOR<ContractorCreateWithoutTimeSlotsInput, ContractorUncheckedCreateWithoutTimeSlotsInput>
    where?: ContractorWhereInput
  }

  export type ContractorUpdateToOneWithWhereWithoutTimeSlotsInput = {
    where?: ContractorWhereInput
    data: XOR<ContractorUpdateWithoutTimeSlotsInput, ContractorUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type ContractorUpdateWithoutTimeSlotsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContractorNestedInput
    services?: ContractorServiceUpdateManyWithoutContractorNestedInput
    bookings?: BookingUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUpdateManyWithoutContractorNestedInput
    messages?: MessageUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUpdateManyWithoutContractorNestedInput
    materials?: MaterialUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUpdateOneWithoutContractorNestedInput
  }

  export type ContractorUncheckedUpdateWithoutTimeSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ContractorServiceUncheckedUpdateManyWithoutContractorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUncheckedUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUncheckedUpdateManyWithoutContractorNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUncheckedUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutContractorNestedInput
  }

  export type ContractorCreateWithoutServiceAreasInput = {
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContractorInput
    services?: ContractorServiceCreateNestedManyWithoutContractorInput
    bookings?: BookingCreateNestedManyWithoutContractorInput
    reviews?: ReviewCreateNestedManyWithoutContractorInput
    messages?: MessageCreateNestedManyWithoutContractorInput
    availability?: AvailabilityCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorCreateNestedManyWithoutContractorInput
    materials?: MaterialCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionCreateNestedOneWithoutContractorInput
  }

  export type ContractorUncheckedCreateWithoutServiceAreasInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ContractorServiceUncheckedCreateNestedManyWithoutContractorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutContractorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractorInput
    messages?: MessageUncheckedCreateNestedManyWithoutContractorInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorUncheckedCreateNestedManyWithoutContractorInput
    materials?: MaterialUncheckedCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageUncheckedCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutContractorInput
  }

  export type ContractorCreateOrConnectWithoutServiceAreasInput = {
    where: ContractorWhereUniqueInput
    create: XOR<ContractorCreateWithoutServiceAreasInput, ContractorUncheckedCreateWithoutServiceAreasInput>
  }

  export type ContractorUpsertWithoutServiceAreasInput = {
    update: XOR<ContractorUpdateWithoutServiceAreasInput, ContractorUncheckedUpdateWithoutServiceAreasInput>
    create: XOR<ContractorCreateWithoutServiceAreasInput, ContractorUncheckedCreateWithoutServiceAreasInput>
    where?: ContractorWhereInput
  }

  export type ContractorUpdateToOneWithWhereWithoutServiceAreasInput = {
    where?: ContractorWhereInput
    data: XOR<ContractorUpdateWithoutServiceAreasInput, ContractorUncheckedUpdateWithoutServiceAreasInput>
  }

  export type ContractorUpdateWithoutServiceAreasInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContractorNestedInput
    services?: ContractorServiceUpdateManyWithoutContractorNestedInput
    bookings?: BookingUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUpdateManyWithoutContractorNestedInput
    messages?: MessageUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUpdateManyWithoutContractorNestedInput
    materials?: MaterialUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUpdateOneWithoutContractorNestedInput
  }

  export type ContractorUncheckedUpdateWithoutServiceAreasInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ContractorServiceUncheckedUpdateManyWithoutContractorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUncheckedUpdateManyWithoutContractorNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUncheckedUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutContractorNestedInput
  }

  export type ClientCreateWithoutFavoritesInput = {
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientInput
    bookings?: BookingCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    messages?: MessageCreateNestedManyWithoutClientInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutFavoritesInput = {
    id?: number
    userId: number
    firstName: string
    lastName: string
    email: string
    phone: string
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    notificationEmail?: boolean
    notificationSms?: boolean
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    messages?: MessageUncheckedCreateNestedManyWithoutClientInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutFavoritesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutFavoritesInput, ClientUncheckedCreateWithoutFavoritesInput>
  }

  export type ContractorCreateWithoutFavoritedByInput = {
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContractorInput
    services?: ContractorServiceCreateNestedManyWithoutContractorInput
    bookings?: BookingCreateNestedManyWithoutContractorInput
    reviews?: ReviewCreateNestedManyWithoutContractorInput
    messages?: MessageCreateNestedManyWithoutContractorInput
    availability?: AvailabilityCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutContractorInput
    materials?: MaterialCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionCreateNestedOneWithoutContractorInput
  }

  export type ContractorUncheckedCreateWithoutFavoritedByInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ContractorServiceUncheckedCreateNestedManyWithoutContractorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutContractorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractorInput
    messages?: MessageUncheckedCreateNestedManyWithoutContractorInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaUncheckedCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutContractorInput
    materials?: MaterialUncheckedCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageUncheckedCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutContractorInput
  }

  export type ContractorCreateOrConnectWithoutFavoritedByInput = {
    where: ContractorWhereUniqueInput
    create: XOR<ContractorCreateWithoutFavoritedByInput, ContractorUncheckedCreateWithoutFavoritedByInput>
  }

  export type ClientUpsertWithoutFavoritesInput = {
    update: XOR<ClientUpdateWithoutFavoritesInput, ClientUncheckedUpdateWithoutFavoritesInput>
    create: XOR<ClientCreateWithoutFavoritesInput, ClientUncheckedCreateWithoutFavoritesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutFavoritesInput, ClientUncheckedUpdateWithoutFavoritesInput>
  }

  export type ClientUpdateWithoutFavoritesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    bookings?: BookingUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    messages?: MessageUpdateManyWithoutClientNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutFavoritesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEmail?: BoolFieldUpdateOperationsInput | boolean
    notificationSms?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClientNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ContractorUpsertWithoutFavoritedByInput = {
    update: XOR<ContractorUpdateWithoutFavoritedByInput, ContractorUncheckedUpdateWithoutFavoritedByInput>
    create: XOR<ContractorCreateWithoutFavoritedByInput, ContractorUncheckedCreateWithoutFavoritedByInput>
    where?: ContractorWhereInput
  }

  export type ContractorUpdateToOneWithWhereWithoutFavoritedByInput = {
    where?: ContractorWhereInput
    data: XOR<ContractorUpdateWithoutFavoritedByInput, ContractorUncheckedUpdateWithoutFavoritedByInput>
  }

  export type ContractorUpdateWithoutFavoritedByInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContractorNestedInput
    services?: ContractorServiceUpdateManyWithoutContractorNestedInput
    bookings?: BookingUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUpdateManyWithoutContractorNestedInput
    messages?: MessageUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutContractorNestedInput
    materials?: MaterialUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUpdateOneWithoutContractorNestedInput
  }

  export type ContractorUncheckedUpdateWithoutFavoritedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ContractorServiceUncheckedUpdateManyWithoutContractorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUncheckedUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutContractorNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUncheckedUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutContractorNestedInput
  }

  export type ContractorCreateWithoutMaterialsInput = {
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContractorInput
    services?: ContractorServiceCreateNestedManyWithoutContractorInput
    bookings?: BookingCreateNestedManyWithoutContractorInput
    reviews?: ReviewCreateNestedManyWithoutContractorInput
    messages?: MessageCreateNestedManyWithoutContractorInput
    availability?: AvailabilityCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionCreateNestedOneWithoutContractorInput
  }

  export type ContractorUncheckedCreateWithoutMaterialsInput = {
    id?: number
    userId: number
    firstName?: string | null
    lastName?: string | null
    name: string
    email?: string | null
    phone?: string | null
    description?: string | null
    yearsInBusiness?: number | null
    location?: string | null
    googleBusinessUrl?: string | null
    verified?: boolean
    licensed?: boolean
    insured?: boolean
    afterHoursAvailable?: boolean
    speaksSpanish?: boolean
    hourlyRate?: number | null
    taxRate?: number | null
    rating?: number
    reviewCount?: number
    profilePicture?: string | null
    isActive?: boolean
    isBanned?: boolean
    suspendedUntil?: Date | string | null
    stripeAccountId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    bookingPageSlug?: string | null
    bookingPageEnabled?: boolean
    bookingPagePrimaryColor?: string | null
    bookingPageAccentColor?: string | null
    bookingPageTagline?: string | null
    bookingPageLogo?: string | null
    bookingPageShowReviews?: boolean
    bookingPageShowPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ContractorServiceUncheckedCreateNestedManyWithoutContractorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutContractorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractorInput
    messages?: MessageUncheckedCreateNestedManyWithoutContractorInput
    availability?: AvailabilityUncheckedCreateNestedManyWithoutContractorInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContractorInput
    serviceAreas?: ContractorServiceAreaUncheckedCreateNestedManyWithoutContractorInput
    flaggedMessages?: FlaggedMessageUncheckedCreateNestedManyWithoutContractorInput
    favoritedBy?: FavoriteContractorUncheckedCreateNestedManyWithoutContractorInput
    languages?: ContractorLanguageUncheckedCreateNestedManyWithoutContractorInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutContractorInput
  }

  export type ContractorCreateOrConnectWithoutMaterialsInput = {
    where: ContractorWhereUniqueInput
    create: XOR<ContractorCreateWithoutMaterialsInput, ContractorUncheckedCreateWithoutMaterialsInput>
  }

  export type ContractorUpsertWithoutMaterialsInput = {
    update: XOR<ContractorUpdateWithoutMaterialsInput, ContractorUncheckedUpdateWithoutMaterialsInput>
    create: XOR<ContractorCreateWithoutMaterialsInput, ContractorUncheckedCreateWithoutMaterialsInput>
    where?: ContractorWhereInput
  }

  export type ContractorUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: ContractorWhereInput
    data: XOR<ContractorUpdateWithoutMaterialsInput, ContractorUncheckedUpdateWithoutMaterialsInput>
  }

  export type ContractorUpdateWithoutMaterialsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContractorNestedInput
    services?: ContractorServiceUpdateManyWithoutContractorNestedInput
    bookings?: BookingUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUpdateManyWithoutContractorNestedInput
    messages?: MessageUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUpdateOneWithoutContractorNestedInput
  }

  export type ContractorUncheckedUpdateWithoutMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    yearsInBusiness?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleBusinessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    licensed?: BoolFieldUpdateOperationsInput | boolean
    insured?: BoolFieldUpdateOperationsInput | boolean
    afterHoursAvailable?: BoolFieldUpdateOperationsInput | boolean
    speaksSpanish?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    suspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPageSlug?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    bookingPagePrimaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageAccentColor?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageTagline?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageLogo?: NullableStringFieldUpdateOperationsInput | string | null
    bookingPageShowReviews?: BoolFieldUpdateOperationsInput | boolean
    bookingPageShowPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ContractorServiceUncheckedUpdateManyWithoutContractorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutContractorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContractorNestedInput
    availability?: AvailabilityUncheckedUpdateManyWithoutContractorNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContractorNestedInput
    serviceAreas?: ContractorServiceAreaUncheckedUpdateManyWithoutContractorNestedInput
    flaggedMessages?: FlaggedMessageUncheckedUpdateManyWithoutContractorNestedInput
    favoritedBy?: FavoriteContractorUncheckedUpdateManyWithoutContractorNestedInput
    languages?: ContractorLanguageUncheckedUpdateManyWithoutContractorNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutContractorNestedInput
  }

  export type BookingCreateManyClientInput = {
    id?: number
    contractorId: number
    serviceId: number
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyClientInput = {
    id?: number
    contractorId: number
    rating: number
    reviewText?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateManyClientInput = {
    id?: number
    contractorId: number
    subject?: string | null
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlaggedMessageCreateManyClientInput = {
    id?: number
    messageId?: number | null
    messageText: string
    flaggedBy: $Enums.FlaggedByType
    flaggedById: number
    contractorId?: number | null
    reason: string
    details?: string | null
    status?: $Enums.FlagStatus
    reviewedBy?: number | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type FavoriteContractorCreateManyClientInput = {
    id?: number
    contractorId: number
    createdAt?: Date | string
  }

  export type BookingUpdateWithoutClientInput = {
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    completion?: JobCompletionUpdateOneWithoutBookingNestedInput
    photos?: JobPhotoUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    reports?: ReportUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: JobCompletionUncheckedUpdateOneWithoutBookingNestedInput
    photos?: JobPhotoUncheckedUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutClientInput = {
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutClientInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutMessagesNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlaggedMessageUpdateWithoutClientInput = {
    messageId?: NullableIntFieldUpdateOperationsInput | number | null
    messageText?: StringFieldUpdateOperationsInput | string
    flaggedBy?: EnumFlaggedByTypeFieldUpdateOperationsInput | $Enums.FlaggedByType
    flaggedById?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reviewedBy?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneWithoutFlaggedMessagesNestedInput
  }

  export type FlaggedMessageUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: NullableIntFieldUpdateOperationsInput | number | null
    messageText?: StringFieldUpdateOperationsInput | string
    flaggedBy?: EnumFlaggedByTypeFieldUpdateOperationsInput | $Enums.FlaggedByType
    flaggedById?: IntFieldUpdateOperationsInput | number
    contractorId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reviewedBy?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlaggedMessageUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: NullableIntFieldUpdateOperationsInput | number | null
    messageText?: StringFieldUpdateOperationsInput | string
    flaggedBy?: EnumFlaggedByTypeFieldUpdateOperationsInput | $Enums.FlaggedByType
    flaggedById?: IntFieldUpdateOperationsInput | number
    contractorId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reviewedBy?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteContractorUpdateWithoutClientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutFavoritedByNestedInput
  }

  export type FavoriteContractorUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteContractorUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorServiceCreateManyContractorInput = {
    id?: number
    serviceId: number
    basePrice?: number | null
    createdAt?: Date | string
  }

  export type BookingCreateManyContractorInput = {
    id?: number
    clientId: number
    serviceId: number
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyContractorInput = {
    id?: number
    clientId: number
    rating: number
    reviewText?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateManyContractorInput = {
    id?: number
    clientId: number
    subject?: string | null
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityCreateManyContractorInput = {
    id?: number
    dayOfWeek?: number | null
    specificDate?: Date | string | null
    startTime: string
    endTime: string
    maxBookings?: number
    isAvailable?: boolean
    isRecurring?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeSlotCreateManyContractorInput = {
    id?: number
    date: Date | string
    startTime: string
    endTime: string
    slotType: $Enums.SlotType
    bookingId?: number | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractorServiceAreaCreateManyContractorInput = {
    id?: number
    dayOfWeek?: number | null
    area: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlaggedMessageCreateManyContractorInput = {
    id?: number
    messageId?: number | null
    messageText: string
    flaggedBy: $Enums.FlaggedByType
    flaggedById: number
    clientId?: number | null
    reason: string
    details?: string | null
    status?: $Enums.FlagStatus
    reviewedBy?: number | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type FavoriteContractorCreateManyContractorInput = {
    id?: number
    clientId: number
    createdAt?: Date | string
  }

  export type MaterialCreateManyContractorInput = {
    id?: number
    name: string
    price: number
    unit: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractorLanguageCreateManyContractorInput = {
    id?: number
    languageId: number
    createdAt?: Date | string
  }

  export type ContractorServiceUpdateWithoutContractorInput = {
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutContractorsNestedInput
  }

  export type ContractorServiceUncheckedUpdateWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorServiceUncheckedUpdateManyWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutContractorInput = {
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    completion?: JobCompletionUpdateOneWithoutBookingNestedInput
    photos?: JobPhotoUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    reports?: ReportUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: JobCompletionUncheckedUpdateOneWithoutBookingNestedInput
    photos?: JobPhotoUncheckedUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutContractorInput = {
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    reviewText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutContractorInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutMessagesNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUpdateWithoutContractorInput = {
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    specificDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxBookings?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    specificDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxBookings?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateManyWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    specificDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxBookings?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSlotUpdateWithoutContractorInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSlotUncheckedUpdateWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSlotUncheckedUpdateManyWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorServiceAreaUpdateWithoutContractorInput = {
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    area?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorServiceAreaUncheckedUpdateWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    area?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorServiceAreaUncheckedUpdateManyWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    area?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlaggedMessageUpdateWithoutContractorInput = {
    messageId?: NullableIntFieldUpdateOperationsInput | number | null
    messageText?: StringFieldUpdateOperationsInput | string
    flaggedBy?: EnumFlaggedByTypeFieldUpdateOperationsInput | $Enums.FlaggedByType
    flaggedById?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reviewedBy?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutFlaggedMessagesNestedInput
  }

  export type FlaggedMessageUncheckedUpdateWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: NullableIntFieldUpdateOperationsInput | number | null
    messageText?: StringFieldUpdateOperationsInput | string
    flaggedBy?: EnumFlaggedByTypeFieldUpdateOperationsInput | $Enums.FlaggedByType
    flaggedById?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reviewedBy?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlaggedMessageUncheckedUpdateManyWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: NullableIntFieldUpdateOperationsInput | number | null
    messageText?: StringFieldUpdateOperationsInput | string
    flaggedBy?: EnumFlaggedByTypeFieldUpdateOperationsInput | $Enums.FlaggedByType
    flaggedById?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reviewedBy?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteContractorUpdateWithoutContractorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteContractorUncheckedUpdateWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteContractorUncheckedUpdateManyWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUpdateWithoutContractorInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorLanguageUpdateWithoutContractorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutContractorsNestedInput
  }

  export type ContractorLanguageUncheckedUpdateWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    languageId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorLanguageUncheckedUpdateManyWithoutContractorInput = {
    id?: IntFieldUpdateOperationsInput | number
    languageId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorLanguageCreateManyLanguageInput = {
    id?: number
    contractorId: number
    createdAt?: Date | string
  }

  export type ContractorLanguageUpdateWithoutLanguageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutLanguagesNestedInput
  }

  export type ContractorLanguageUncheckedUpdateWithoutLanguageInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorLanguageUncheckedUpdateManyWithoutLanguageInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorServiceCreateManyServiceInput = {
    id?: number
    contractorId: number
    basePrice?: number | null
    createdAt?: Date | string
  }

  export type BookingCreateManyServiceInput = {
    id?: number
    contractorId: number
    clientId: number
    serviceAddress: string
    scheduledDate: Date | string
    scheduledTime: string
    estimatedDuration?: number | null
    status?: $Enums.BookingStatus
    price?: number | null
    paymentReceived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractorServiceUpdateWithoutServiceInput = {
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ContractorServiceUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutServiceInput = {
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorUpdateOneRequiredWithoutBookingsNestedInput
    client?: ClientUpdateOneRequiredWithoutBookingsNestedInput
    completion?: JobCompletionUpdateOneWithoutBookingNestedInput
    photos?: JobPhotoUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    reports?: ReportUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: JobCompletionUncheckedUpdateOneWithoutBookingNestedInput
    photos?: JobPhotoUncheckedUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractorId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    serviceAddress?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentReceived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPhotoCreateManyBookingInput = {
    id?: number
    filename: string
    originalName: string
    photoType: $Enums.PhotoType
    fileSize: number
    url: string
    createdAt?: Date | string
  }

  export type PaymentCreateManyBookingInput = {
    id?: number
    invoiceId?: number | null
    amount: number
    paymentMethod: string
    stripePaymentId?: string | null
    stripePaymentIntent?: string | null
    platformFee?: number | null
    contractorPayout?: number | null
    stripeTransferId?: string | null
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportCreateManyBookingInput = {
    id?: number
    type: $Enums.ReportType
    reporterType: $Enums.ReporterType
    reporterId: number
    reportedUserId?: number | null
    reportedUserType?: $Enums.ReporterType | null
    reason: string
    description: string
    evidence?: string | null
    status?: $Enums.ReportStatus
    priority?: $Enums.ReportPriority
    assignedTo?: number | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobPhotoUpdateWithoutBookingInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    photoType?: EnumPhotoTypeFieldUpdateOperationsInput | $Enums.PhotoType
    fileSize?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPhotoUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    photoType?: EnumPhotoTypeFieldUpdateOperationsInput | $Enums.PhotoType
    fileSize?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPhotoUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    photoType?: EnumPhotoTypeFieldUpdateOperationsInput | $Enums.PhotoType
    fileSize?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutBookingInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntent?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    contractorPayout?: NullableFloatFieldUpdateOperationsInput | number | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntent?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    contractorPayout?: NullableFloatFieldUpdateOperationsInput | number | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntent?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    contractorPayout?: NullableFloatFieldUpdateOperationsInput | number | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutBookingInput = {
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reporterType?: EnumReporterTypeFieldUpdateOperationsInput | $Enums.ReporterType
    reporterId?: IntFieldUpdateOperationsInput | number
    reportedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    reportedUserType?: NullableEnumReporterTypeFieldUpdateOperationsInput | $Enums.ReporterType | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    priority?: EnumReportPriorityFieldUpdateOperationsInput | $Enums.ReportPriority
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reporterType?: EnumReporterTypeFieldUpdateOperationsInput | $Enums.ReporterType
    reporterId?: IntFieldUpdateOperationsInput | number
    reportedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    reportedUserType?: NullableEnumReporterTypeFieldUpdateOperationsInput | $Enums.ReporterType | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    priority?: EnumReportPriorityFieldUpdateOperationsInput | $Enums.ReportPriority
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reporterType?: EnumReporterTypeFieldUpdateOperationsInput | $Enums.ReporterType
    reporterId?: IntFieldUpdateOperationsInput | number
    reportedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    reportedUserType?: NullableEnumReporterTypeFieldUpdateOperationsInput | $Enums.ReporterType | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    priority?: EnumReportPriorityFieldUpdateOperationsInput | $Enums.ReportPriority
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyMessageInput = {
    id?: number
    sender: $Enums.SenderType
    messageText: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateWithoutMessageInput = {
    sender?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateWithoutMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: number
    bookingId: number
    amount: number
    paymentMethod: string
    stripePaymentId?: string | null
    stripePaymentIntent?: string | null
    platformFee?: number | null
    contractorPayout?: number | null
    stripeTransferId?: string | null
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntent?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    contractorPayout?: NullableFloatFieldUpdateOperationsInput | number | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntent?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    contractorPayout?: NullableFloatFieldUpdateOperationsInput | number | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntent?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    contractorPayout?: NullableFloatFieldUpdateOperationsInput | number | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}